<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Script-Kompatibilität</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Script-Kompatibilität</h1>

<p>Durch grundlegende Unterschiede zwischen AutoHotkey Basic und AutoHotkey_L (insbesondere Unicode- und x64-Versionen) funktionieren möglicherweise einige AutoHotkey-Scripts nicht wie erwartet mit AutoHotkey_L. Dieses Dokument beschreibt bekannte Kompatibilitätsprobleme und -lösungen.</p>

<h2 id="Format">Unicode anstelle von ANSI</h2>
<p>Alle erwarteten oder zurückgegebenen Strings von internen Befehlen, Funktionen und Operatoren haben ein bestimmtes Binärformat im Speicher, bezeichnet als das <i>native Format</i>. Die Art des Formats ist von der AutoHotkey-Version abhängig: <i>Unicode</i> oder <i>ANSI</i>. Scripts, die nur ein bestimmtes Format berücksichtigen, werden oft mit Problemen konfrontiert, wenn sie mit der falschen Version von AutoHotkey laufen. Wenn man sich nicht sicher ist, welche Version zurzeit läuft, verwendet folgendes Script:</p>
<pre>MsgBox % A_IsUnicode ? "Unicode" : "ANSI"</pre>
<p><b>ANSI:</b> Strings werden wie auch in AutoHotkey Basic im Standard-ANSI-Zeichensatz des Betriebssystems gespeichert.  Jedes Zeichen ist ein Byte (8 Bit).</p>
<p><b>Unicode:</b> Strings werden im <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>-Format gespeichert, bei dem jedes Zeichen zwei Bytes ist (16 Bit).</p>
<p>Technisch gesehen werden einige Unicode-Zeichen durch <i>zwei</i> 16-Bit-Code-Einheiten vertreten, auch allgemein bekannt als "Ersatzzeichenpaar" (surrogate pair). Ebenso enthalten einige <a href="http://msdn.microsoft.com/en-us/library/dd317752.aspx">ANSI-Zeichensätze</a> (allgemein bekannt als <a href="http://msdn.microsoft.com/en-us/library/dd317794.aspx">Doppel-Byte-Zeichensätze</a>)  einige Doppel-Byte-Zeichen. Allerdings werden sie normalerweise der Einfachheit halber und im praktischen Sinne als zwei einzelne "Zeichen" behandelt.</p>

<h3>Script-Dateien</h3>
<p>Beachtet, dass obwohl jede Version von AutoHotkey nur ein bestimmtes Format für Strings im Speicher unterstützt, eine Reihe von verschiedenen Kodierungen für Script-Quelldateien verwendet werden können. Wenn ein Script Nicht-ASCII-Zeichen in der falschen Kodierung enthält, dann werden sie falsch geladen. Ahk2Exe und Unicode-Versionen von AutoHotkey_L erwarten standardmäßig <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, während Scripts mit der ANSI-Version ANSI erwarten. Weitere Informationen können in <a href="http://www.autohotkey.net/~Lexikos/AutoHotkey_L/docs/Scripts.htm#cp">Zeichensatz einer Script-Datei</a> gefunden werden.</p>

<h3 id="VarSetCapacity">VarSetCapacity</h3>
<p>VarSetCapacity bestimmt die Kapazität einer Variable <i>in Bytes</i>.  Da die Größe eines Zeichens je nach String-Format variiert, sind möglicherweise einige Berechnungen notwendig:</p>
<pre>VarSetCapacity(ansi_var, size_in_chars)
VarSetCapacity(unicode_var, size_in_chars * 2)
VarSetCapacity(native_var,  size_in_chars * (A_IsUnicode ? 2 : 1))
VarSetCapacity(native_var, t_size(size_in_chars))  <em>; siehe <a href="#NumPutGet">unten</a></em>
</pre>VarSetCapacity wird intern ein <i>Zeichen</i> zur Kapazität hinzufügen, damit die Variable der Sicherheit halber 0-terminiert wird.  Allerdings sollte <code>size_in_chars</code> in der Regel den 0-Terminator aus Konsistenzgründen enthalten, wenn ein String in einem <i>nicht-nativen</i> Format in die Variable gespeichert wird.
<p></p>

<h3 id="DllCall">DllCall</h3>
<p>Wenn der "Str"-Typ verwendet wird, dann ist dieser Typ im ursprünglichen Format der aktuellen Version.  Da einige Funktionen möglicherweise Strings in einem bestimmten Format benötigen oder zurückgeben, stehen die folgenden String-Typen zur Verfügung:</p>
<table class="info">
  <tr><th></th><th>Zeichengröße</th><th>C / Win32-Typen</th><th>Kodierung</th></tr>
  <tr><td class="Syntax" style="text-align:center">WStr</td><td style="text-align:center">16-Bit</td><td>wchar_t*, WCHAR*, LPWSTR, LPCWSTR</td><td>UTF-16</td></tr>
  <tr><td class="Syntax" style="text-align:center">AStr</td><td style="text-align:center">8-Bit</td><td>char*, CHAR*, LPSTR, LPCSTR</td><td>ANSI (der Standard-ANSI-Zeichensatz des Systems)</td></tr>
  <tr><td class="Syntax" style="text-align:center">Str</td><td style="text-align:center">--</td><td>TCHAR*, LPTSTR, LPCTSTR</td><td>Entspricht <b>WStr</b> in Unicode-Versionen und <b>Astr</b> in ANSI-Versionen.</td></tr>
</table>
<br>
<p>Wenn "Str" oder der Gegentyp für die aktuelle Version als ein Parameter verwendet wird, dann wird die Adresse des Strings oder der Variable an die Funktion übergeben, ansonsten wird stattdessen eine temporäre Kopie des Strings im gewünschten Format erstellt und übergeben. Funktionen können eine temporäre Kopie ändern, aber <b>dürfen nicht</b> auf der rechten Seite des 0-Terminators im String schreiben. Allgemein gilt, dass "AStr" und "WStr" nicht für Ausgabe-Parameter verwendet werden sollten.</p>
<p><b>Hinweis:</b> "Astr" und "Wstr" sind bei Parameter und Rückgabewerte der Funktionen gleichberechtigt.</p>
<p>Wenn ein Script im Allgemeinen eine Funktion mithilfe von DllCall aufruft, die einen String als Parameter akzeptiert, dann muss ein folgender Ansatz berücksichtigt werden:</p>
<ol>
  <li>Wenn sowohl Unicode- (W) als auch ANSI-Versionen (A) von der Funktion verfügbar sind, ruft jeweils die passende Funktion für die aktuelle Version auf.  Im folgenden Beispiel ist "DeleteFile" intern als "DeleteFileA" oder "DeleteFileW" bekannt.  Da "DeleteFile" selbst nicht wirklich existiert, versucht DllCall automatisch, "A" oder "W" für die aktuelle Version zu setzen:
  <pre>DllCall("DeleteFile", "Ptr", &Dateiname)
DllCall("DeleteFile", "Str", Dateiname)</pre>
  <p>In diesem Beispiel übergibt <code>&Dateiname</code> exakt die Adresse des Strings, damit die Funktion ein String im gleichen Format wie der "Str"-Typ erwarten muss. Beachtet, dass in AutoHotkey Basic "UInt" anstelle von "PTR" verwendet werden muss, aber der resultierende Code ist möglicherweise nicht 64-Bit-kompatibel.
  <p><b>Hinweis:</b> Wenn die Funktion nicht genau wie angegeben zu finden ist, dann wird AutoHotkey_L das "A"- oder "W"-Suffix anfügen, unabhängig davon, welche DLL angegeben wird.  Allerdings wird AutoHotkey Basic den "A"-Suffix nur für Funktionen in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll anfügen.</p></li>
  <li>Wenn die Funktion nur einen bestimmten String-Typ als Eingabevariable akzeptiert, dann kann das Script den entsprechenden String-Typen verwenden:</li>
  <pre>DllCall("DeleteFileA", "AStr", Dateiname)
DllCall("DeleteFileW", "WStr", Dateiname)</pre>
  <li>Wenn die Funktion einen String ändern muss (in einem nicht-nativen Format), dann muss das Script einen Puffer wie <a href="#VarSetCapacity">oben</a> beschrieben bereitstellen und seine Adresse an die Funktion übergeben.  Wenn der Parameter eine Eingabevariable akzeptiert, dann muss das Script auch den Eingabe-String mithilfe von <a href="commands/StrPutGet.htm">StrPut</a> in das entsprechende Format umwandeln.</li>
  <p></p>
</ol>

<h3 id="NumPutGet">NumPut / NumGet</h3>
<p>Wenn NumPut oder NumGet mit Strings verwendet werden, dann muss der Offset und Typ für den jeweiligen Typ korrekt sein.  Die folgenden Angaben können als Anleitung verwendet werden:</p>
<pre><em>; 8-Bit/ANSI-Strings:  size_of_char=1  type_of_char="Char"
; 16-Bit/UTF-16-Strings:  size_of_char=2  type_of_char="UShort"</em>
<i>n</i>th_char := NumGet(Variable, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)
NumPut(<i>n</i>th_char, Variable, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)</pre>
<p>Wenn die <code>Variable</code> einen String im ursprünglichen Format enthält, dann können die entsprechenden Werte auf Basis des Wertes von <code>A_IsUnicode</code> bestimmt werden:</p>
<pre><i>n</i>th_char := NumGet(Variable, t_size(<i>n</i>-1), t_char())
NumPut(<i>n</i>th_char, Variable, t_size(<i>n</i>-1), t_char())

<em>; Funktionen der Einfachheit und Deutlichkeit halber definieren:</em>
t_char() {
    Return A_IsUnicode ? "UShort" : "Char"
}
t_size(char_count=1) {
    Return A_IsUnicode ? char_count : char_count*2
}</pre>

<h2 id="ptr">Pointer-Größe</h2>
<p>Pointer haben eine Größe von 4 Bytes in 32-Bit-Versionen (einschließlich AutoHotkey Basic) und 8 Bytes in 64-Bit-Versionen. Scripts mit Strukturen oder DllCalls müssen diese möglicherweise nachweisen, damit sie auf beiden Plattformen richtig funktionieren. Bestimmte Bereiche, die auch betroffen sind:</p>
<ul>
  <li>Offset-Berechnung für Felder in Strukturen, die beliebig viele Pointer enthalten.</li>
  <li>Größenberechnung von Strukturen mit beliebig vielen Pointern.</li>
  <li>Typennamen, die mit <a href="commands/DllCall.htm">DllCall</a>, <a href="Functions.htm#NumPut">NumPut</a> oder <a href="Functions.htm#NumGet">NumGet</a> verwendet werden.</li>
</ul>
<p>Verwendet für Größe- und Offset-Berechnungen <a href="Variables.htm#PtrSize">A_PtrSize</a>. Verwendet für DllCall, NumPut und NumGet je nach Bedarf den <a href="commands/DllCall.htm">Ptr</a>-Typ.</p>
<p>Denkt daran, dass der Offset eines Felds in der Regel die Gesamtgröße aller vorherigen Felder ist. Beachtet zudem, dass Handles (auch Typen wie HWND und HBITMAP) hauptsächlich Pointer-Typen sind.</p>
<pre><em>/*
  typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Ptr
    HANDLE hThread;
    DWORD  dwProcessId; // UInt (4 bytes)
    DWORD  dwThreadId;
  } <a href="http://msdn.microsoft.com/en-us/library/ms684873.aspx">PROCESS_INFORMATION</a>, *LPPROCESS_INFORMATION;
*/</em>
VarSetCapacity(pi, A_PtrSize*2 + 8) <em>; Ptr + Ptr + UInt + UInt</em>
DllCall("<a href="http://msdn.microsoft.com/en-us/library/ms682425.aspx">CreateProcess</a>", <span class="dull"><der Kürze halber weggelassen></span>, "Ptr", &pi, <span class="dull"><weggelassen></span>)
hProcess    := NumGet(pi, 0)         <em>; Verwendet standardmäßig "Ptr".</em>
hThread     := NumGet(pi, A_PtrSize) <em>; </em>
dwProcessId := NumGet(pi, A_PtrSize*2,     "UInt")
dwProcessId := NumGet(pi, A_PtrSize*2 + 4, "UInt")

</pre>

<h2 id="Other">Weitere Änderungen</h2>

<h3>Standard-Script</h3>
<p>Wenn AutoHotkey_L ohne Angabe eines Scripts gestartet wird, dann entspricht der Dateiname des Standard-Scripts dem Namen der ausführbaren Datei, aber immer mit der "ahk"-Erweiterung.  Weitere Details können in <a href="Scripts.htm#cmd">Befehlszeilenparameter an ein Script übergeben</a> gefunden werden.</p>

<h3 id="Names">Variablen- und Funktionsnamen</h3>
<p>Die Zeichen [ ] und ? sind nicht länger in Variablennamen gültig.  Folglich benötigt ? (ternär) nicht länger ein Leerzeichen auf jeder Seite.  Siehe auch <a href="Objects.htm#Syntax">Objekt-Syntax</a>.</p>

<h3 id="Validation">Syntaxvalidierung</h3>
<p>Befehlsnamen müssen mit einem Leerzeichen, Tabulator oder Komma terminiert werden.  Im Gegensatz zu AutoHotkey Basic umgehen die folgenden Zeichen nicht diese Anforderung: <code><>:+-*/!~&|^[]</code>. Folglich werden Syntaxfehler wie <code>MsgBox< foo</code> und <code>If!foo</code>, während der Ladezeit abgefangen, nicht als <code>MsgBox,< foo</code> oder <code>If !foo</code> interpretiert.</p>

<h3 id="Transform">Transform</h3>
<p>Einige Unterbefehle von <i>Transform</i> wurden in der <b>Unicode</b>-Version geändert:</p>
<ul>
  <li><span class="Syntax">Unicode</span> ist nicht mehr verfügbar. Um der Zwischenablage ein Unicode-Text zuzuweisen, verwendet eine normale Zuweisung. Siehe auch: <a href="commands/StrPutGet.htm">StrPut/StrGet</a>.</li>
  <li><span class="Syntax">HTML</span> unterstützt <a href="commands/Transform.htm#HTML">zusätzliche Funktionen</a>.</li>
</ul>


<h3 id="IfIs">If Variable is</h3>
<p>Dieser Befehl ignoriert das Gebietsschema des Betriebssystems, es sei denn, <i>StringCaseSense, Locale</i> wurde verwendet.</p>

<h3 id="FileRead">FileRead</h3>
<p><a href="commands/FileRead.htm#Binary">FileRead</a> wandelt den Zeichensatz des Textes in bestimmten Fällen um, wodurch unbrauchbare Binärdaten ausgeben werden können.</p>

<h3 id="ControlZ">Steuerung+Z</h3>
<p><a href="commands/LoopReadFile.htm">dateilesende Schleife</a> und <a href="commands/FileReadLine.htm">FileReadLine</a> interpretieren das Zeichen Steuerung+Z (0x1A) nicht als ein Zeilenumbruchszeichen. Somit wird jedes Steuerung+Z als normales Zeichen behandelt, selbst wenn es am Ende einer Datei erscheint. <a href="commands/FileRead.htm">FileRead</a> verhält sich bereits auf diese Weise.</p>

<h3 id="SetFormat">SetFormat, Integer[Fast], H</h3>
<p>Wenn ein großgeschriebenes H verwendet wird, dann sind hexadezimale Zeichen A-F auch in Großbuchstaben.  Im Gegensatz dazu verwendet AutoHotkey Basic immer kleingeschriebene Zeichen. Siehe <a href="commands/SetFormat.htm">SetFormat</a>.</p>

<h3>Kompatibilitätsmodus</h3>
<p>Wenn in Windows 95, NT4 oder 98/ME der <a href="http://www.microsoft.com/windowsxp/using/helpandsupport/learnmore/appcompat.mspx#ECD">Kompatibilitätsmodus</a> in den Eigenschaften der EXE-Datei   gesetzt wird, um das Script auszuführen, dann verhält sich das Script nicht korrekt.  Denn der Kompatibilitätsmodus bewirkt, dass eine bestimmte Version von Windows der Anwendung gemeldet wird, die jedoch von den vorgefertigten Binärdateien nicht unterstützt wird.  Zum Beispiel bewirkt das Setzen des Kompatibilitätsmodus in Windows 95 oder 98/ME, dass <code>MsgBox %A_OSVersion%</code> den String <code>WIN_NT4</code> meldet.</p>

<h3 id="Run">Run / RunWait <span class="ver">[AHK_L 57+]</span></h3>
<p>Neben der Unterstützung für benutzerdefinierte Verben (<code>Run *Verb Datei</code>) wurde das Verfahren geändert, wie die Aktion und ihre Parameter aus dem <i>Ziel</i>-Parameter extrahiert werden. Im Einzelnen:</p>
<ul>
  <li>Wenn das <i>Ziel</i> mit einem Anführungszeichen beginnt, dann wird alles nach dem Anführungszeichen als die Aktion angesehen.</li>
  <li>Ansonsten wird der erste Teilstring, der bei einem Leerzeichen endet und weder eine vorhandene Datei ist noch mit .exe, .bat, .com, .cmd oder .hta endet, als die Aktion angesehen. Dadurch können Dateitypen wie .ahk, .vbs oder .lnk Parameter akzeptieren, während "bekannte" ausführbare Dateien wie wordpad.exe ohne einen absoluten Pfad wie in vorherigen Versionen immer noch ausgeführt werden können.</li>
</ul>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>
