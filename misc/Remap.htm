<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Neubelegung von Tasten</title>
<meta name="description" content="Free keyboard remapper that can also remap mouse and joystick buttons. It can also automate repetitive tasks by sending keystrokes & mouse clicks.">
<meta name="keywords" content="keyboard,remapper,remap,remapping,keys,key,keystrokes,clicks,mouse,buttons,button,joystick,hotkeys,hotkey">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="alternate" type="application/rss+xml" title="AutoHotkey Forum RSS" href="../../forum/rss.php">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Neubelegung von Tasten</h1>

<h2>Einführung</h2>
<p>Diese Funktion unterstützt weder Joysticks noch funktioniert sie auf Windows 95/98/Me. Dafür gibt es folgende Alternativmethoden:</p>
<ul>
  <li><a href="#Win9x">Neubelegung in Windows 9x</a></li>
  <li><a href="RemapJoystick.htm">Joystick-Neubelegung</a></li>
</ul>
<p><strong>Einschränkung</strong>: Die unten beschriebene Neubelegungsfunktion von AutoHotkey ist in der Regel nicht so unverfälscht und effektiv wie die direkte Neubelegung in der Registrierung von Windows. Für die Vor- und Nachteile der einzelnen Ansätze, siehe <a href="#registry">Neubelegung mit der Registrierung</a>.</p>
<h2 id="Remap">Tastatur und Maus neu belegen</h2>
<p>Die Syntax für die interne Neubelegungsfunktion lautet <em>Originaltaste::Zieltaste</em>. Zum Beispiel verhält sich die Taste "a" wie die Taste "b", wenn sich nur die folgende Zeile in einem <a href="../Scripts.htm">Script</a> befindet:</p>
<pre>a::b</pre>
<p>Das obige Beispiel ändert nicht die Taste "b" selbst. Die Taste "b" sendet weiterhin ein "b", solange sie nicht wie im folgenden Beispiel neu belegt wird:</p>
<pre>a::b
b::a</pre>
<p>Die obigen Beispiele verwenden Kleinbuchstaben, die für die meisten Zwecke empfohlen sind, weil dadurch auch die dazugehörigen Großbuchstaben neu belegt werden (wenn die Feststelltaste aktiv ist oder die Umschalt-Taste gedrückt gehalten wird). Im Gegensatz dazu wird mit einem Großbuchstaben auf der rechten Seite die Großschreibung erzwungen. Zum Beispiel erzeugt die folgende Zeile ein großgeschriebenes B, wenn "a" oder "A" eingegeben wird (solange die Feststelltaste deaktiviert ist):</p>
<pre>a::B</pre>
<p>&nbsp;</p>
<p><strong><a name="RemapMouse"></a>Neubelegung der Maus</strong>: Um die Maus anstelle der Tastatur neu zu belegen, verwendet die gleiche Methode. Zum Beispiel:</p>
<table class="info">
  <tr>
    <td>MButton::Shift</td>
    <td>Die mittlere Maustaste verhält sich wie die Umschalttaste.</td>
  </tr>
  <tr>
    <td>XButton1::LButton</td>
    <td>Die vierte Maustaste verhält sich wie die linke Maustaste.</td>
  </tr>
  <tr>
    <td>RAlt::RButton</td>
    <td>Die rechte Alt-Taste verhält sich wie die rechte Maustaste.</td>
  </tr>
</table>
<p>&nbsp;</p>
<p><strong>Weitere nützliche Neubelegungen:</strong></p>
<table class="info">
  <tr>
    <td>Capslock::Ctrl</td>
    <td>Feststelltaste verhält sich wie die Strg-Taste. Um die Umschaltfähigkeit der Feststelltaste zu erhalten, fügt außerdem die Neubelegung <em>+Capslock::Capslock</em> hinzu (damit wird die Feststelltaste aktiviert oder deaktiviert, wenn der Benutzer die Umschalttaste gedrückt hält und die Feststelltaste drückt).</td>
  </tr>
  <tr>
    <td>XButton2::^LButton</td>
    <td>Die fünfte Maustaste (XButton2) erzeugt Steuerung+Linksklick.</td>
  </tr>
  <tr>
    <td>RAlt::AppsKey</td>
    <td>Die rechte Alt-Taste verhält sich wie die Menü-Taste (die das Kontextmenü öffnet).</td>
  </tr>
  <tr>
    <td>RCtrl::RWin</td>
    <td>Die rechte Strg-Taste verhält sich wie die rechte Win-Taste.</td>
  </tr>
  <tr>
    <td>Ctrl::Alt</td>
    <td>Beide Strg-Tasten verhalten sich wie eine Alt-Taste. Siehe jedoch <a href="#AltTab">Alt-Tab-Probleme</a>.</td>
  </tr>
  <tr>
    <td>^x::^c</td>
    <td>Steuerung+X erzeugt Steuerung+C. Führt auch dazu, dass Steuerung+Alt+X die Tastenkombination Steuerung+Alt+C erzeugt, usw.</td>
  </tr>
  <tr>
    <td>RWin::Return</td>
    <td>Deaktiviert die rechte Win-Taste, indem sie einfach <a href="../commands/Return.htm">zurückgegeben</a> wird.</td>
  </tr>
</table>
<p>Die oben genannten Beispiele können ausprobiert werden, indem sie in einer neuen Textdatei z. B. namens "Remap.ahk" kopiert werden und die Datei danach ausgeführt wird.</p>
<p>In der <a href="../KeyList.htm">Tastenliste</a> können alle Tastennamen der Tastatur und Maus gefunden werden.</p>
<h2>Bemerkungen</h2>
<p>Mit den Anweisungen <a href="../commands/_IfWinActive.htm">#IfWinActive/Exist</a> können die Neubelegungen nur für bestimmte Fenster gültig gemacht werden. Zum Beispiel:</p>
<pre>#IfWinActive ahk_class Notepad
a::b  <em>; Im Editor verhält sich die Taste "a" wie die Taste "b".</em>
#IfWinActive  <em>; Alle nachfolgenden Neubelegungen und Hotkeys gelten für alle Fenster.</em></pre>
<p>Die Neubelegung einer Taste ist bei folgenden Maßnahmen "vollständig":</p>
<ul>
  <li>Wenn ein Modifikator wie Strg oder Umschalt gedrückt gehalten wird, während die originale Taste eingegeben wird, dann wird dieser Modifikator für die Zieltaste wirksam. Zum Beispiel erzeugt b::a die Tastenkombination Steuerung+A, wenn Steuerung+B gedrückt wird.</li>
  <li>Generell beeinflusst die Feststelltaste neu belegte Tasten auf die gleiche Weise wie normale Tasten.</li>
  <li>Die Zieltaste wird gedrückt gehalten, solange die originale Taste gedrückt gehalten wird. Allerdings unterstützen einige Spiele keine Neubelegung. In solchen Fällen verhält sich die Tastatur und Maus so, als wären sie nicht neu belegt.</li>
  <li>Neu belegte Tasten werden automatisch wiederholt, während sie gedrückt gehalten werden (außer Tasten, die mit Maustasten neu belegt wurden).</li>
</ul>
<p><a name="HookHotkeys"></a>Obwohl eine neu belegte Taste normale Hotkeys auslösen kann, kann sie keine Maus- oder <a href="../commands/_UseHook.htm">Hook-Hotkeys</a> auslösen (mit <a href="../commands/ListHotkeys.htm">ListHotkeys</a> können Hook-Hotkeys entdeckt werden). Wenn zum Beispiel die Neubelebung a::b aktiv ist, dann löst das Drücken von Strg+Alt+A den Hotkey ^!b aus, wenn ^!b kein Hook-Hotkey ist. Wenn ^!b ein Hook-Hotkey ist, dann kann ^!a als ein Hotkey definiert werden, damit Strg+Alt+A die gleiche Aktion wie Strg+Alt+B ausführt. Zum Beispiel:</p>
<pre>a::b
^!a::
^!b::
ToolTip %A_ThisHotkey% wurde gedrückt.
Return</pre>
<p><a name="SendPlay"></a>Wenn <a href="../commands/SendMode.htm">SendMode</a> im automatischen Ausführungsbereich verwendet wird (oberste Teil des Scripts), dann werden alle Neubelegungen davon beeinflusst. Da die Neubelegung <a href="../commands/Send.htm#blind">Send {Blind}</a> verwendet, dass vom <a href="../commands/SendMode.htm">SendPlay-Modus</a> nicht vollständig unterstützt wird, funktionieren möglicherweise einige Neubelegungen nicht richtig im SendPlay-Modus (besonders STRG, UMSCHALT, ALT und WIN). Als Übergangslösung sollte SendPlay im automatischen Ausführungsbereich weggelassen werden, wenn Neubelegungen vorhanden sind, und verwendet dann den <a href="../commands/Send.htm#SendPlay">SendPlay</a>-Befehl anstelle von Send. Alternativ können die Neubelegungen auch in Hotkeys umgewandelt werden (wie unten beschrieben), die SendEvent anstelle von Send direkt aufrufen.</p>
<p>Wenn ein Script gestartet wird, dann wird jede Neubelegung in zwei <a href="../Hotkeys.htm">Hotkeys</a> umgewandelt. Zum Beispiel enthält ein Script mit <em>a::b</em> stattdessen die folgenden zwei Hotkeys:</p>
<pre>*<strong>a</strong>::
SetKeyDelay -1   <em>; Wenn die Zieltaste eine Maustaste ist, dann verwendet stattdessen SetMouseDelay.</em>
Send <a href="../commands/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownTemp}  <em>; DownTemp ist wie Down, nur dass andere Send-Befehle im Script nicht davon ausgehen, dass "b" während des Sendens unten bleiben soll.</em>
Return

*<strong>a up</strong>::
SetKeyDelay -1  <em>; Siehe den unteren Hinweis, warum die Druckdauer nicht mit einem der beiden SetKeyDelays angegeben wird.</em>
Send {Blind}{<strong>b</strong> Up}
Return</pre>
<p>Allerdings unterscheiden sich die oberen Hotkeys unter folgenden Umständen:</p>
<ol>
  <li>Wenn die Quelltaste die LCtrl-Taste ist und die Zieltaste eine Alt-Taste ist, dann wird die Zeile <em>Send {Blind}{LAlt DownTemp}</em> mit <em>Send {Blind}<strong>{LCtrl Up}</strong>{LAlt DownTemp}</em> ersetzt. Das Gleiche gilt, wenn die Quelle die RCtrl-Taste ist, nur wird <em>{RCtrl up}</em> nicht verwendet.</li>
  <li>Wenn eine Tastatur-Taste mit einer Maustaste (z. B. RCtrl::RButton) neu belegt ist, dann verwenden die oben genannten Hotkeys SetMouseDelay anstelle von SetKeyDelay. Darüber hinaus wird der erste oben genannte Hotkey mit Folgendem ersetzt, um die automatische Wiederholung von Maustasten zu verhindern:
    <pre>*RCtrl::
SetMouseDelay -1
If not GetKeyState("RButton")  <em>; d. h. die rechte Maustaste wurde noch nicht gedrückt.</em>
    Send {Blind}{RButton DownTemp}
Return</pre>
  </li>
</ol>
<p>Beachtet, dass der zweite Parameter (<a href="../commands/SetKeyDelay.htm#dur">Druckdauer</a>) von SetKeyDelay für die oben genannten Hotkeys entfällt. Denn die Druckdauer gilt nicht für Nur-Down- und Nur-Up-Ereignisse, wie z. B. {b down} und {b up}. Allerdings gilt die Druckdauer für Statusänderungen von Umschalt-/Strg-/Alt-/Win-Tasten, wobei Neubelegungen wie a::B oder a::^b beeinflusst werden. Folglich gilt jede Druckdauer, die im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> aktiviert ist, für alle Neubelegungen.</p>
<p>Obwohl ein Tastenpaar nicht direkt mit einer Taste neu belegt werden kann (z. B. ist <em>a & c::b</em> ungültig), kann dieser Effekt dennoch erreicht werden, wenn die Up- und Down-Hotkeys von weiter oben direkt hinzugefügt werden: ersetzt <em>*a::</em> einfach mit <em>a & c::</em>, und ersetzt <em>*a up::</em> mit <em>a & c up::</em></p>
<p>Da Neubelegungen wie oben beschrieben in Hotkeys umgewandelt werden, werden sie vom <a href="../commands/Suspend.htm">Suspend</a>-Befehl beeinflusst. Ebenso kann mit dem <a href="../commands/Hotkey.htm">Hotkey</a>-Befehl eine Neubelegung deaktiviert oder bearbeitet werden. Zum Beispiel deaktivieren die zwei folgenden Befehle die Neubelegung <em>a::b</em>.</p>
<pre>Hotkey, *a, off
Hotkey, *a up, off</pre>
<p><a name="AltTab"></a>Alt-Tab-Probleme: Wenn eine Taste oder Maustaste mit einer Alt-Taste neubelegt wird, dann ist diese Taste wahrscheinlich nicht in der Lage, ein Alt-Tab-Ereignis richtig auszuführen. Als mögliche Übergangslösung kann der Hotkey <em>*Tab::Send {Blind}{Tab}</em> hinzugefügt werden, der aber die Benutzung der realen Alt-Taste für Alt-Tab wahrscheinlich stört. Daher sollte der Hotkey nur verwendet werden, wenn das Alt-Tab ausschließlich mithilfe neu belegter Tasten und/oder <a href="../Hotkeys.htm#alttab">Alt-Tab-Hotkeys</a> ausgeführt wird.</p>
<p>Zusätzlich zu den Tasten und Maustasten in der <a href="../KeyList.htm">Tastenliste</a> kann die Quelltaste auch eine virtuelle Taste (VKnn) oder ein Scan-Code (SCnnn) sein (siehe <a href="../KeyList.htm#SpecialKeys">Sondertasten</a>). Das Gleiche gilt für die Zieltasten, außer dass nach der virtuellen Taste optional ein Scan-Code angegeben werden kann. Zum Beispiel ist <em>sc01e::vk42sc030</em> bei den meisten Tastaturbelegungen gleichbedeutend mit <em>a::b</em>.</p>
<p>Um eine Taste zu deaktivieren, anstatt neu zu belegen, erstellt ein Hotkey nur mit <a href="../commands/Return.htm">Return</a>. Zum Beispiel deaktiviert <em>F1::Return</em> die F1-Taste.</p>
<p>Die folgenden Tasten werden nicht von der internen Neubelegungsmethode unterstützt:</p>
<ul>
  <li>Das Mausrad (WheelUp/Down/Left/Right).</li>
  <li>Pause und Break als Zieltasten (da sie den Befehlen entsprechen).</li>
  <li>Geschweifte Klammern {} als Zieltasten. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>, z. B. <em>x::+sc01A</em> und <em>y::+sc01B</em>.</li>
  <li>Ein Prozentzeichen (%) als Zieltaste. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>.</li>
  <li>"Return" als Zieltaste. Verwendet stattdessen "Enter".</li>
</ul>
<h2>Den Mauszeiger mit der Tastatur bewegen</h2>
<p>Die Tastatur kann dazu verwendet werden, den Mauszeiger wie im <a href="../scripts/NumpadMouse.htm">Tastatur-zu-Maus-Script</a> zu bewegen. Da das Script eine reibungslose Bewegung, Beschleunigung und andere Funktionen für den Zeiger ermöglicht, dann ist es die empfohlene Vorgehensweise, um die Tastatur als Maus zu verwenden. Im Gegensatz dazu ist das folgende Beispiel eine einfachere Demonstration:</p>
<pre>*#up::MouseMove, 0, -10, 0, R  <em>; Win + Pfeil oben => Zeiger nach oben bewegen</em>
*#Down::MouseMove, 0, 10, 0, R  <em>; Win + Pfeil unten => Zeiger nach unten bewegen</em>
*#Left::MouseMove, -10, 0, 0, R  <em>; Win + Pfeil links => Zeiger nach links bewegen</em>
*#Right::MouseMove, 10, 0, 0, R  <em>; Win + Pfeil rechts => Zeiger nach rechts bewegen</em>

*<#RCtrl::  <em>; WinLinks + SteuerungRechts => Linksklick (Steuerung/Umschalt für Steuerung+Klick oder Umschalt+Klick gedrückt halten).</em>
SendEvent {Blind}{LButton down}
KeyWait RCtrl  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{LButton up}
Return

*<#AppsKey::  <em>; Win links + Menü-Taste => Rechtsklick</em>
SendEvent {Blind}{RButton down}
KeyWait AppsKey  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{RButton up}
Return</pre>
<h2 id="registry">Neubelegung mittels "Scancode Map" von der Registrierung</h2>
<p><strong>Vorteile:</strong></p>
<ul>
  <li>Neubelegung in der Registrierung ist in der Regel eher unverfälscht und effektiv als die <a href="#Remap">Neubelegung von AutoHotkey</a>. Zum Beispiel funktioniert es für einen breiteren Bereich von Spielen, hat keine bekannten <a href="#AltTab">Alt-Tab-Probleme </a>und ist in der Lage, Hook-Hotkeys von AutoHotkey auszuführen (während die Neubelegung von AutoHotkey eine <a href="#HookHotkeys">Übergangslösung</a> benötigt).</li>
  <li>Wenn der Wunsch besteht, die Registrierungseinträge manuell zu bearbeiten (siehe unten), dann ist absolut keine externe Software notwendig, um die Tastatur neu zu belegen. Selbst wenn <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> für die Registrierungseinträge verwenden wird, muss dieses Programm nicht die ganze Zeit laufen (im Gegensatz zu AutoHotkey).</li>
</ul>
<p><strong>Nachteile:</strong></p>
<ul>
  <li>Die Neubelegung in der Registrierung ist relativ permanent: ein Neustart wird benötigt, um die Änderungen rückgängig oder wirksam zumachen.</li>
  <li>Die Auswirkung ist global: es können keine Neubelegungen für bestimmte Benutzer, Anwendungen oder Gebietsschemen erstellt werden.</li>
  <li>Es können keine Tastatureingaben gesendet werden, die durch Umschalt, Strg, Alt oder AltGr modifiziert sind. Zum Beispiel kann ein Kleinbuchstabe nicht mit einem Großbuchstaben neu belegt werden.</li>
  <li>Es wird nicht von Windows 95/98/Me unterstützt (AutoHotkey ermöglicht eine <a href="#Win9x">begrenzte Neubelegung in Win9x</a>).</li>
  <li>Es wird nur die Tastatur unterstützt (AutoHotkey ermöglicht eine <a href="#RemapMouse">Neubelegung der Maus</a> und einige <a href="RemapJoystick.htm">begrenzte Joystick-Neubelegungen</a>).</li>
</ul>
<p><strong>Wie Änderungen an der Registrierung vorgenommen werden können:</strong> Es gibt mindestens zwei Methoden, um Tasten mittels der Registrierung neu zu belegen:</p>
<ol>
  <li>Verwendet ein Programm wie <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> (Freeware), um Tasten visuell neu zu belegen. Damit wird die Registrierung geändert. </li>
  <li>Tasten können manuell neu belegt werden, wenn eine .reg-Datei (Klartext) erstellt und in die Registrierung geladen wird. Das wird auf <a href="http://www.autohotkey.com/forum/post-56216.html#56216">www.autohotkey.com/forum/post-56216.html#56216</a> demonstriert.</li>
</ol>
<h2 id="alt"><a name="Win9x"></a>Neubelegungsmethode für Windows 95/98/Me</h2>
<p>Nichts anderes als die Verwendung von <a href="../commands/Send.htm">Send</a> und <a href="../commands/KeyWait.htm">KeyWait</a>. Zum Beispiel ermöglicht der folgende Hotkey, dass die Taste "A" sich wie die linke Pfeiltaste verhält:</p>
<pre>a::
Send {Left down}  <em>; Hält die linke Pfeiltaste gedrückt.</em>
KeyWait a  <em>; Wartet, bis die Taste losgelassen wird.</em>
Send {Left up}  <em>; Lässt die linke Pfeiltaste los.</em>
Return</pre>
<h2>Verwandte Befehle</h2>
<p><a href="../KeyList.htm#Joystick">Tastenliste</a><br> <a href="../commands/GetKeyState.htm">GetKeyState</a><br> <a href="RemapJoystick.htm">Neubelegung eines Joysticks</a></p>
</body>
</html>
