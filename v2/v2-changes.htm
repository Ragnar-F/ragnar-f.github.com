<!DOCTYPE html>
<html>
<head>
<title>v2-changes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<script src="/cdn-cgi/apps/head/21XiSFXBdVHXl7A_izEkLSn9ayc.js"></script>
<link href="docs/static/theme.css" rel="stylesheet" type="text/css" media="all" />
</head>
<body>
<h1>Änderungen zwischen v1.1 und v2.0</h1>
<h2>Sprache</h2>
<h3>Veraltete Syntax entfernt</h3>
<p>Direkt geschriebene Zuweisungen entfernt: <code>Var = Wert</code></p>
<p>Alle alten If-Anweisungen entfernt, so dass nur <code>if Ausdruck</code> übrig bleibt, welches nie Klammern  erfordert (aber sie erlaubt, wie bei jedem Ausdruck).</p>
<p>Die "Befehlssyntax" wurde entfernt. Das heißt, dass ein "Befehl" jetzt nur noch ein Funktions- oder Methodenaufruf ohne runden Klammern ist (am Anfang einer Zeile). Das bedeutet:</p>
<ul>
<li>Alle ehemaligen Befehle sind jetzt Funktionen (außer Ablaufsteuerungsanweisungen).</li>
<li>Alle Funktionen können ohne runde runden Klammern aufgerufen werden.</li>
<li>Alle Parameter sind Ausdrücke, demzufolge muss direkt geschriebener Text von Anführungszeichen umschlossen sein.</li>
<li>Parameter sind dieselben, unabhängig von runden Klammern; bei dem Szenario, wo es keine Ausgabevariable für den Rückgabewert gibt, wird er verworfen, wenn die runden Klammern weggelassen werden.</li>
<li>Normale Variablenverweise werden nie von Prozentzeichen umschlossen. Benutze Verkettung oder Format(), um Variablen in einen Text einzufügen.</li>
<li>Es gibt kein Komma zwischen dem Funktionsnamen und Parameter; zum Beispiel wäre <code>MouseGetPos(, y)</code> das gleiche wie <code>MouseGetPos , y</code> (x wird weggelassen). Ein Leer- oder Tabulatorzeichen ist erforderlich, um es verständlich zu machen. Um Konsistenz zu bewahren, folgen auch Direktiven der neuen Konvention (es darf kein Komma zwischen dem Namen der Direktive und dem Parameter stehen).</li>
<li>Ein Prozentzeichen als Präfix ist nicht mehr notwendig, um ein Ausdruck zu erzwingen.</li>
<li>Methodenaufrufe sind auf eine einfache Variable, gefolgt von einem oder mehreren via Punkte getrennte Identifikatoren, beschränkt, z. B. <code>MeineVar.MeineEigenschaft.MeineMethode "String zum Übergeben"</code>.</li>
</ul>
<p>Die Umwandlung von v1-Befehlen zu Funktionen geschieht in der Regel wie folgt (aber einige Funktionen wurden geändert, wie weiter unten dokumentiert):</p>
<ul>
<li>Wenn der erste Parameter des Befehls eine Ausgabevariable ist und der zweite Parameter nicht, wird er zum Rückgabewert und aus der Parameterliste entfernt. Ansonsten wird RunWait den Exitcode zurückgeben, und alle anderen Befehle, die ErrorLevel setzen, bei Erfolg einen Wert ungleich Null und bei Misserfolg eine Null zurückgeben (außer SendMessage). Die meisten altmodischen Funktionen setzen immer noch ErrorLevel.</li>
<li>Die übrigen Ausgabevariablen werden wie ByRef-Parameter behandelt, allerdings wird eine Ausnahme ausgelöst, wenn die Funktion inkorrekt aufgerufen wird. Die Übergabe einer leeren Zeichenkette ist das gleiche wie, als würde man den Parameter weglassen, aber jeder andere Wert (der nicht ein Variablenverweis ist) ist verboten.</li>
</ul>
<p>Loop akzeptiert auch Ausdrücke. Das Schlüsselwort <code>Files</code>, <code>Parse</code>, <code>Read</code> oder <code>Reg</code> darf nicht in Anführungszeichen gesetzt werden. Derzeit kann nach dem Schlüsselwort ein Komma folgen, aber es ist nicht erforderlich, da dies kein Parameter ist. OTB wird unterstützt.</p>
<p>Die Parameterlisten von allen Ablaufsteuerungsanweisungen (außer Zwei-Wort-Loop-Anweisungen) können mit runden Klammern umschlossen werden, ohne Leerzeichen zwischen dem Namen und der Klammer. Zum Beispiel <code>return(var)</code>. Allerdings sind das keine Funktionen; zum Beispiel wäre <code>x := return(y)</code> ungültig. If und While unterstützen diese Methode bereits.</p>
<p>Goto, Gosub, Break und Continue benötigen einen Labelnamen ohne Anführungszeichen, so ähnlich wie in v1 (<code>Goto Label</code> springt zu <code>Label:</code>). Um ein Label dynamisch anspringen oder aufrufen zu können, müssen runde Klammern direkt nach dem Namen benutzt werden: <code>Goto(Ausdruck)</code> oder <code>Gosub(Ausdruck)</code>. Allerdings sind das keine Funktionen und können deshalb nicht inmitten eines Ausdrucks benutzt werden. Es können runde Klammern können bei break oder continue verwendet werden, aber in diesem Fall muss der Parameter eine einzelne direkt geschriebene Zahl oder eine in Anführungszeichen gesetzte Zeichenkette sein.</p>
<h3>Variablen</h3>
<p>Variablennamen können nicht mehr mit einer Zahl beginnen und dürfen keines der folgenden Zeichen, die vorher erlaubt waren, enthalten: <code>@ # $</code>. Nur Buchstaben, Zahlen, Unterstriche und Nicht-ASCII-Zeichen sind erlaubt.</p>
<p>Reservierte Wörter: Deklarationsschlüsselwörter und Namen von Ablaufsteuerungsanweisungen können nicht als Variablen-, Funktions- oder Klassennamen verwendet werden. Dazu gehören Local, Global, Static, If, Else, Loop, For, While, Until, Break, Continue, Goto, Gosub, Return, Try, Catch, Finally und Throw. Dies dient in erster Linie dazu, Fehler zu erkennen, wie z. B. <code>if (ex) break</code>.</p>
<p>Reservierte Wörter: Namen von Ausdrucksoperator-Schlüsselwörtern können nicht als Variablen-, Funktions- oder Klassennamen verwendet werden. Dazu gehören Or, And, Not, New, Is, In und Contains. Dies dient in erster Linie der Konsistenz: In v1 war <code>and := 1</code> auf einer eigenen Zeile erlaubt, aber <code>(and := 1)</code> würde nicht funktionieren.</p>
<p>Die oben aufgelisteten Wörter können zum Benennen von Methoden oder Fenstergruppen genutzt werden. Methodennamen, die aufgerufen werden, müssen immer einen <code>.</code> davor haben, um zu verhindern, dass das Wort als Operator interpretiert wird. Schlüsselwörter hingegen werden nie als Variablen- oder Funktionsnamen innerhalb eines Ausdrucks interpretiert. Zum Beispiel ist <code>new(x)</code> das gleiche wie <code>(new x)</code>.</p>
<p>Die Namen <code>Object</code>, <code>Array</code> und <code>Map</code> werden von vordefinierten Klassen verwendet, können aber innerhalb einer Funktion durch explizite Deklaration einer lokalen Variable oder eines Parameters oder im Force-Local-Modus als Variablen-, Funktions- oder Klassennamen verwendet werden.</p>
<p>Doppeldereferenzierungen sind nun konsistent mit Variablen, die bei der Ladezeit aufgelöst werden. Das heißt, dass ein dynamischer Variablenverweis nur global (nicht superglobal) wird, wenn die Funktion im global-behandelnden Modus ist oder wenn die Variable in der Funktion als global deklariert wurde.</p>
<p>Doppeldereferenzierungen, die fehlschlagen, weil sie leer oder zu lang sind, zeigen eine Fehlermeldung an und führen zum Abbruch des Threads, anstatt still und heimlich eine leere Zeichenkette zu erzeugen. Dies macht sie konsistenter in Verbindung mit Eingabe-/Ausgabevariablen. Illegale Zeichen in Variablennamen verursachten schon immer eine Fehlermeldung.</p>
<p>Eine lokale Variable in eine Funktion zu deklarieren, wird die Funktion nicht in den global-behandelnden Modus versetzen.</p>
<h3>Ausdrücke (Expressions)</h3>
<p>Direkt geschriebene Zeichenketten können in <code>"doppelten"</code> oder <code>'einfachen'</code> Anführungszeichen gesetzt werden, die untereinander nicht austauschbar sind. Direkt geschriebene Anführungszeichen müssen mit einem Escapezeichen versehen werden - <code>`"</code> oder <code>`'</code> - oder mit dem gegenteiligen Anführungszeichen ersetzt werden: <code>'"42" ist die Antwort'</code>. Doppelte Anführungszeichen haben keine besondere Bedeutung, und lösen einen Fehler aus, weil sie als Auto-Verkettung ein Leerzeichen benötigen.</p>
<p>Die Operatoren <code>&amp;&amp;</code>, <code>||</code>, <code>and</code> und <code>or</code> geben den gewinnenden Wert zurück, ähnlich wie JavaScript und Lua. Zum Beispiel wäre der Rückgabewert von <code>"" or "default"</code> gleich <code>"default"</code> statt <code>1</code>. Skripte, die einen reinen logischen Rückgabewert (0 oder 1) benötigen, können so etwas wie <code>!!(x or y)</code> oder <code>(x or y) ? 1 : 0</code> benutzen.</p>
<p>Auto-Verkettungen benötigen nun mindestens ein Leer- oder Tabulatorzeichen (die v1-Dokumentation sagte, da "sollte" ein Leerzeichen sein).</p>
<p>Das Ergebnis eines Mehrfachanweisungsausdrucks wie <code>x(), y()</code> ist der letzte (ganz rechts befindliche) Teilausdruck, anstatt der erste (ganz links). In v1 als auch v2 werden Teilausdrücke von links nach rechts ausgewertet.</p>
<p>Gleichheitszeichen nach einem Komma sind nicht länger Zuweisungen: <code>y=z</code> in <code>x:=y, y=z</code> wäre nicht eine Zuweisung, sondern ein wirkungsloser Vergleich.</p>
<p><code>:= += -= *= /= ++ --</code> haben konsistentes Verhalten, egal ob sie einzeln oder in Kombination mit anderen Operatoren, wie z. B. <code>x := y, y += 2</code>, benutzt werden. Zum Beispiel würde <code>x := %y%()</code> nicht länger eine leere Zeichenkette in x speichern, wenn der dynamische Aufruf fehlschlägt. (Dieses Beispiel ist vermutlich nicht mehr relevant, da dynamische Aufrufe jetzt Ausnahmefehler auslösen.)</p>
<p><code>!=</code> ist nun wie <code>=</code> immer nicht-Groß-/Kleinschreibung-sensitiv. Außerdem wurde <code>!==</code> als Counterpart zu <code>==</code> hinzugefügt.</p>
<p><code>&lt;&gt;</code> wurde entfernt.</p>
<p>Die wissenschaftliche Schreibweise kann ohne Dezimalpunkt erfolgen (aber erzeugt immer eine Gleitkommazahl). Die wissenschaftliche Schreibweise wird auch unterstützt, wenn numerische Zeichenketten in Integer-Zahlen umgewandelt werden (z. B. wird "1e3" als 1000 statt als 1 interpretiert).</p>
<p>Doppeldereferenzierungen und dynamische Funktionsaufrufe erlauben nun fast jeden Ausdruck (nicht nur Variablen) als Quelle für den Variablen-/Funktionsnamen. Zum Beispiel sind <code>Fn%n+1%()</code> und <code>%(%triple%)%</code> gültig.</p>
<p>Die Ausdrücke <code>funkName[""]()</code> und <code>funkName.()</code> rufen nicht länger eine Funktion via Name auf. Das Weglassen des Methodennamens wie in <code>.()</code> verursacht nun eine Ladezeit-Fehlermeldung. Stattdessen sollte man <code>%funkName%()</code> verwenden.</p>
<p>Leere Zuweisungen wie <code>var :=</code> lösen einen Fehler aus während der Ladezeit. In v1 war diese Schreibweise ein Ersatz für <code>var := ""</code>, das aber in Kombination mit einem anderen Ausdruck still und heimlich fehlschlug - zum Beispiel: <code>x :=, y :=</code>.</p>
<p>Direkt geschriebene Zeichenketten, gefolgt von einem mehrdeutigen einstelligen/zweistelligen Operator, lösen einen Fehler aus während der Ladezeit. Zum Beispiel würde <code>"x" &amp;y</code> das <code>"x"</code> mit der Adresse von <code>y</code> automatisch verketten, aber technisch gesehen wäre diese eine ungültige Bitweises-Und-Operation.</p>
<p>Innerhalb eines Ausdrucks wird das Wort <code>new</code> nicht länger als Variable behandelt. Komplexere Ausdrücke werden unterstützt; z. B. <code>new (getClass())(params)</code> or <code>new new {...}(inner_prms)(outer_prms)</code>.</p>
<p>Initialisierungen von klassischen Variablen - die als Zuweisungen innerhalb einer Klasse, aber außerhalb einer Methode, gelten - lösen nicht länger die __Set-Meta-Funktion aus.</p>
<p><code>Wort ++</code> und <code>Wort --</code> sind nicht länger Ausdrücke, da <code>Wort</code> eine benutzerdefinierte Funktion sein kann (und nach ++/- kann ein Ausdruck folgen, der einen Variablenverweis erzeugt). Um einen alleinstehenden Post-Inkrement- oder Post-Dekrement-Ausdruck zu schreiben, muss man entweder das Leerzeichen zwischen Variable und Operator weglassen, oder die Variable oder den Ausdruck in Klammern setzen.</p>
<p><code>Wort ? x : y</code> ist immer noch ein ternärer Ausdruck, allerdings werden bei komplexeren Fällen, die mit einem Wort beginnen, z. B. <code>Wort1 Wort2 ? x : y</code>, das <em>Wort1</em> immer als Funktionsaufruf interpretiert (selbst wenn so eine Funktion nicht existiert). Um einen alleinstehenden ternären Ausdruck mit einer komplexen Bedingung zu schreiben, umschließt man die Bedingung mit runden Klammern.</p>
<p><a name="is"></a>Der neue Operator <code>is</code> ersetzt <code>if Var is Typ</code>. Da <em>Typ</em> eine Zeichenkette ist, muss es in Anführungszeichen gesetzt werden (oder eine Variable sein). Die alten Typ-Namen können weiterverwendet werden, plus <code>object</code> und <code>byref</code>. Darüber hinaus kann mit <code>x is y</code>, wo <em>y</em> ein Objekt ist, überprüft werden, ob <em>x</em> direkt oder indirekt von <em>y</em> abgeleitet wurde.</p>
<p>Die Schlüsselwörter <code>in</code> und <code>contains</code> sind für die zukünftige Verwendung reserviert.</p>
<p><code>&amp;int</code> (Adresse-von): Da reine Zahlen und Zeichenketten nun verschiedene Typen sind, wird <code>&amp;(var := 123)</code> absofort die Adresse von einer int64 zurückgeben, anstatt die Adresse einer Zeichenkette. Aus Konsistenzgründen wird VarSetCapacity eine 6 zurückgeben (die Größe von int64 minus Null-Terminator).</p>
<p><code>&amp;"str"</code> (Adresse-von): Es ist nun möglich, die Adresse einer direkt geschriebenen oder temporären Zeichenkette abzurufen, wie z. B. das Ergebnis einer Verkettung oder einer Zeichenkette, die von einer Funktion oder einer internen Variablen zurückgegeben wird. In der Dokumentation finden Sie Informationen zu den Einschränkungen.</p>
<p>Die Länge der Zeichenkette wird nun während der Ausdrucksauswertung im Cache zwischengespeichert. Dies erhöht die Performance und ermöglicht, dass Zeichenketten eine binäre Null enthalten dürfen. Genauer gesagt:</p>
<ul>
<li>Wenn man zwei Zeichenketten, die binäre Nullen enthalten, verkettet, werden die Daten nicht länger gekürzt. Wenn man aber einer MsgBox oder Ähnliches das Ergebnis übergibt, wird das Ergebnis nur bis zur ersten binären Null angezeigt.</li>
<li>Mit dem case-sensitiven Gleichheitsoperator (<code>==</code>) können binäre Daten verglichen werden. Die anderen Vergleichsoperatoren können nur bis zur ersten binären Null "sehen".</li>
<li>Binäre Daten können von Funktionen zurückgegeben und in Objekten gespeichert werden.</li>
</ul>
<p>Viele Befehle und Funktionen erwarten immer noch null-terminierte Zeichenketten; das heißt, dass sie nur bis zur ersten binären Null "sehen" können.</p>
<p>Der <code>*</code>deref-Operator wurde entfernt. Benutze stattdessen NumGet.</p>
<p>Der <code>~</code>-Operator (bitweises NICHT) behandelt seinen Eingabewert nun immer als 64-Bit-Integer; er behandelt Werte zwischen 0 und 4294967295 nicht mehr als vorzeichenlose 32-Bit-Integer.</p>
<p>Fat-Arrow-Funktionen hinzugefügt. Der Ausdruck <code>Fn(Parameter) =&gt; Ausdruck</code> definiert eine Funktion namens <em>Fn</em> (das weggelassen werden kann) und gibt ein Func- oder Closure-Objekt zurück. Wenn dieser Ausdruck aufgerufen wird, wird die Funktion <em>Ausdruck</em> auswerten und das Ergebnis zurückgeben. Wenn dieser Ausdruck in einer anderen Funktion ist, kann <em>Ausdruck</em> auf die Variablen der äußeren Funktion zugreifen (dies kann auch mit einer normalen Funktionsdefinition erfolgen).</p>
<p>Die Fat-Arrow-Syntax kann auch genutzt werden, um Methoden und Eigenschaft-Getter/Setter zu definieren (in diesem Fall ist die Methoden-/Eigenschaftsdefinition selbst kein Ausdruck; ihr Körper gibt einfach nur einen Ausdruck zurück).</p>
<p>Direkt geschriebene Zahlen werden nun auf der linken Seite des Objektelementzugriffs (Punkt) vollständig unterstützt. <code>0.1</code> beispielsweise ist eine Zahl, aber <code>0.min</code> und <code>0.1.min</code> greifen auf die <em>min</em>-Eigenschaft zu, die von den Standard-Meta-Funktionen behandelt werden kann. <code>1..2</code> oder <code>1.0.2</code> ist die Zahl 1.0, gefolgt von der Eigenschaft 2. Dies könnte z. B. für Maßeinheiten, direkt geschriebenen Versionsnummern oder Zahlenbereichen verwendet werden.</p>
<h3>Objekte (Sonstiges)</h3>
<p>Siehe auch: <a href="#objects">Objekte</a></p>
<p>Der Zugriff auf Eigenschaften via <code>.</code> und der Zugriff auf Daten via <code>[]</code> (Elemente, Array- oder Map-Elemente) werden nun getrennt voneinander behandelt. <code>dictionary["Count"]</code> beispielsweise kann die Definition von "Count" zurückgeben, während <code>dictionary.Count</code> die Anzahl der darin enthaltenen Wörter zurückgibt. Benutzerdefinierte Objekte können dies durch Definieren einer indexierten <code>__Item[]</code>-Eigenschaft nutzen.</p>
<p>Wenn der Name einer Eigenschaft oder Methode nicht im Voraus bekannt ist, kann (und muss) der Zugriff auf diese via Prozentzeichen erfolgen. <code>obj.%varname%()</code> beispielsweise ist das v2-Äquivalent zu <code>obj[varname]()</code>. Die Verwendung von <code>[]</code> ist für Daten (z. B. Array-Elemente) reserviert.</p>
<p><code>%Fn%()</code> - Fn ist in diesem Fall eine Funktion oder ein Objekt - ruft <code>Fn.Call()</code> auf, anstatt <code>Fn[""]()</code>. Funktionen unterstützen nicht mehr die namenlose Methode.</p>
<p><code>this.Method()</code> ruft <code>Fn.Call(this)</code> statt <code>Fn[this]()</code> auf (wenn <code>Fn</code> das Funktionsobjekt ist, das die Methode implementiert). Funktionsobjekte sollten eine <em>Call</em>-Methode implementiert haben, anstatt die <em>__Call</em>-Meta-Funktion.</p>
<p><code>new Obj()</code> schlägt nun fehl beim Erstellen des Objekts, wenn die <code>__New</code>-Meta-Methode definiert wurde, aber nicht aufgerufen werden konnte (weil sie z. B. Parameter benötigte, die aber nicht gegeben sind).</p>
<p>Objekte, die innerhalb eines Ausdrucks erstellt oder von einer Funktion zurückgegeben werden, werden nun zurückgehalten, bis die Ausdrucksauswertung abgeschlossen ist, und dann freigegeben. Dieses Verhalten ermöglicht eine geringfügig verbesserte Performance und eine Speicherverwaltung innerhalb eines Ausdrucks mit temporären Objekten, ohne befürchten zu müssen, dass Objekte vorzeitig freigegeben werden.</p>
<p>Objekte können Zeichenkettenwerte (aber nicht Keys) mit binären Nullen enthalten. Beim Klonen eines Objekts werden Binärdaten in Zeichenketten beibehalten, bis zur gespeicherten Länge der Zeichenkette (nicht deren Kapazität). In der Vergangenheit wurden Daten über die Länge des Wertes hinaus geschrieben, wenn es um binäre Daten oder Strukturen ging; jetzt sollte stattdessen ein Buffer-Objekt verwendet werden.</p>
<p>Zuweisungsausdrücke wie <code>x.y := z</code> liefern nun immer den Wert <code>z</code>, egal wie <code>x.y</code> implementiert wurde. Der Rückgabewert eines Eigenschaft-Setters wird nun ignoriert. <code>__Set</code> muss derzeit noch explizit via <code>return</code> abgeschlossen werden, um zu signalisieren, dass die Operation behandelt wurde, aber der Wert wird ignoriert. Vorher:</p>
<ul>
<li>Einige interne Objekte gaben <code>z</code> zurück, andere gaben <code>x.y</code> zurück (z. B. <code>c := gui.BackColor := "red"</code>, das <code>c</code> auf <code>0xFF0000</code> gesetzt hat), und andere gaben einen falschen Wert zurück.</li>
<li>Benutzerdefinierte Eigenschaft-Setter haben eventuell unerwartete Werte zurückgegeben oder konnten nichts zurückgeben.</li>
</ul>
<p><code>x.y(z) := v</code> führt nun zu einem Syntaxfehler. Vorher war es äquivalent zu <code>x.y[z] := v</code>. Grundsätzlich sind <code>x.y(z)</code> (Methodenaufruf) und <code>x.y[z]</code> (parametrisierte Eigenschaft) zwei verschiedene Operationen, allerdings werden diese als gleichwertig angesehen, wenn <code>x</code> ein COM-Objekt ist (aufgrund von Einschränkungen der COM-Schnittstelle).</p>
<p>Beim Aufrufen eines Objekts via IDispatch (die COM-Schnittstelle) führen unbehandelte Ausnahmen, die nicht an den Aufrufer zurückgegeben werden können, zu einem Fehlerdialogfenster. (Der Aufrufer kann nach Belieben ein zusätzliches Fehlerdialogfenster ohne spezifische Details anzeigen.) Dies gilt auch für den Aufruf von Ereignishandlern durch Verwendung von ComObjConnect.</p>
<h3>Funktionen</h3>
<p>Funktionen können nicht mehr dynamisch mit mehr Parametern aufgerufen werden, als sie formal akzeptieren (variadische Funktionen können aber immer noch beliebig viele Parameter akzeptieren).</p>
<p>Variadische Funktionen sind von der obigen Einschränkung nicht betroffen, erstellen aber normalerweise bei jedem Aufruf ein Array, um die überschüssigen Parameter zu behalten. Wenn dieses Array nicht benötigt wird, kann der Parametername nun weggelassen werden, um seine Erstellung zu verhindern:</p>
<pre><code>AcceptsOneOrMoreArgs(first, *) {
  ...
}
</code></pre>
<p>Dies kann für Callbacks verwendet werden, bei denen die zusätzlichen Parameter nicht benötigt werden.</p>
<p>Variadische Funktionsaufrufe erlauben nun ein beliebiges enumerierbares Objekt in Situationen, wo sie bisher ein Standardobjekt mit sequentiellen numerischen Keys benötigten. Wenn der Enumerator mehr als einen Wert pro Iteration zurückgibt, wird nur der erste Wert verwendet. <code>Array(mymap*)</code> beispielsweise erstellt ein Array, das die Keys von <em>mymap</em> enthält.</p>
<h3>Verschachtelte Funktionen</h3>
<p>Eine Funktion kann in einer anderen Funktion definiert werden. Eine verschachtelte Funktion (sofern nicht Force-Local) kann auf lokale und statische Variablen der äußeren Funktion zugreifen.</p>
<p>Übergibt man den Namen einer verschachtelten Funktion an <code>Func()</code> (oder einer anderen internen Funktion wie SetTimer), wird eventuell ein <code>Closure</code>-Objekt erzeugt, das die verschachtelte Funktion an den aktuellen Satz lokaler Variablen der äußeren Funktion bindet. Es hat die gleichen Eigenschaften wie ein <code>Func</code>-Objekt.</p>
<p>Der neue Fat-Arrow-Operator <code>=&gt;</code> kann auch genutzt werden, um verschachtelte Funktionen zu erstellen.</p>
<p>Weitere Details finden Sie in der Dokumentation.</p>
<h3>Sonstiges</h3>
<p>Beim Initialisieren einer deklarierten Variable oder eines optionalen Parameters muss <code>:=</code> statt <code>=</code> verwendet werden.</p>
<p><code>Return %var%</code> bewirkt nun eine Doppeldereferenzierung; vorher war es das gleiche wie <code>return var</code>.</p>
<p>#Include ist standardmäßig relativ zum Verzeichnis, das die aktuelle Datei enthält.</p>
<p>Labels innerhalb einer Funktion werden lokal behandelt; sie sind nur innerhalb der Funktion nutzbar und können nicht mit anderen Labels außerhalb dieser Funktion in Konflikt geraten. Es ist nicht möglich, lokale Labels extern aufzurufen (auch nicht via interner Funktionen). Stattdessen können verschachtelte Funktionen verwendet werden, die die volle Nutzung lokaler Variablen ermöglichen.</p>
<p><code>For k, v in obj</code> macht k und v nun zu "lokalen Variablen". Wenn die Schleife unterbrochen wurde oder fertig ist, bekommen k und v wieder ihren ursprünglichen Wert zugewiesen. Zusätzlich wird eine Ausnahme ausgelöst, wenn <em>obj</em> kein Objekt ist oder es ein Problem beim Abrufen oder Aufrufen des Enumerators gibt.</p>
<p>Ein Komma mit einem Escapezeichen zu versehen, hat keine Bedeutung mehr. Früher wurde ein Komma, das sich in einem Ausdruck innerhalb eines Befehlsparameters befand und nicht mit runden Klammern umschlossen war, als Mehrfachanweisungsoperator interpretiert, anstatt als Trennung für Parameter. Diese Methode funktionierte nur bei Befehlen, nicht bei Funktionen oder Variablendeklarationen.</p>
<p>Die Escapesequenz <code>`s</code> ist nun überall dort erlaubt, wo <code>`t</code> unterstützt wird. Zuvor war sie nur bei #IfWin und (Join erlaubt.</p>
<p><code>*/</code> kann nun am Ende einer Zeile stehen, um einen mehrzeiligen Kommentar zu schließen und um zu bewirken, dass <code>/* */</code> sich so verhält wie bei anderen Sprachen. Um das Risiko einer Mehrdeutigkeit zu verhindern (z. B. ein Hotstring, der mit <code>*/</code> endet), wird jedes <code>*/</code>, das nicht ein <code>/*</code> davor hat, nicht länger ignoriert (eine Änderung in AHK_L Revision 54 wurde rückgängig gemacht).</p>
<p>Integer-Konstanten und numerische Zeichenketten außerhalb des unterstützten Bereichs (von vorzeichenbehafteten 64-Bit-Integern) werden nun überlaufen/umgekehrt, anstatt auf den Minimal-/Maximalwert begrenzt zu werden. Dies ist konsistent mit mathematischen Operatoren, daher ist <code>9223372036854775807+1 == 9223372036854775808</code> (aber beide erzeugen -9223372036854775808). Dies ermöglicht bitweise Operationen bei 64-Bit-Werten.</p>
<p>Bei numerischen Zeichenketten kommt es eher selten vor, dass neben Leer- oder Tabulatorzeichen noch andere Arten von Leerraumzeichen vor der Zahl erlaubt sind. In der Regel gilt (sowohl in v1 als auch v2), dass nur Leer- und Tabulatorzeichen erlaubt sind, aber in einigen Fällen werden andere Typen von Leerraumzeichen aufgrund der Konventionen der C-Laufzeitbibliothek toleriert.</p>
<p>Wenn eine Skriptdatei Zeilen enthält, die die Grenze von 16383 Zeichen überschreiten, wird ein Fehler angezeigt, anstatt die Zeile stillschweigend zu splitten.</p>
<h3>Fortsetzungsbereiche</h3>
<p>Intelligentes LTrim: Standardmäßig werden alle Leer- und Tabulatorzeichen gezählt, die am Anfang der ersten Zeile unterhalb der Fortsetzungsbereichsoptionen vorkommen, und danach genauso viele Zeichen bei nachfolgenden Zeilen entfernt. Enthält die erste Zeile eine Mischung aus Leer- und Tabulatorzeichen, wird nur der erste Zeichentyp als Einrückung behandelt. Wenn jede Zeile weniger eingerückt ist als die erste Zeile oder mit den falschen Zeichen eingerückt ist, werden alle führenden Leerraumzeichen auf dieser Zeile beibehalten.</p>
<p>Anführungszeichen werden automatisch mit einem Escapezeichen versehen (also als direkt geschriebene Zeichen interpretiert), wenn der Fortsetzungsbereich innerhalb einer in Anführungszeichen gesetzte Zeichenkette beginnt. Dadurch wird verhindert, dass Anführungszeichen in mehrzeiligen Zeichenketten mit einem Escapezeichen versehen werden müssen (wenn das beginnende und endende Anführungszeichen außerhalb des Fortsetzungsbereichs liegen), während mehrzeilige Ausdrücke immer noch Anführungszeichen enthalten können.</p>
<p>Wenn die Zeile über dem Fortsetzungsbereich mit einem Namenszeichen endet und der Bereich nicht innerhalb eines Anführungszeichens beginnt, wird automatisch ein einzelnes Leerzeichen eingefügt, um den Namen vom Inhalt des Fortsetzungsbereichs zu trennen. Dadurch kann ein Fortsetzungsbereich für einen mehrzeiligen Ausdruck verwendet werden, der nach einem <code>return</code>, Funktionsaufrufanweisungen und so weiter erfolgt. Es stellt auch sicher, dass Variablennamen nicht mit anderen Tokens (oder Namen) verbunden werden, was zu ungültigen Ausdrücken führt.</p>
<p>Zeilenumbruchszeichen (<code>`n</code>) werden innerhalb von Ausdrücken als Leerzeichen behandelt. Dadurch können Ausdrücke mehrzeilig gemacht werden, mithilfe eines Fortsetzungsbereichs mit Standardoptionen (das heißt, dass <code>Join</code> nicht mehr notwendig ist).</p>
<p>Die Optionen <code>`</code> und <code>%</code> wurden entfernt, da solche Zeichen nicht mehr mit einem Escapezeichen versehen werden müssen.</p>
<p>Eine neue Methode der Zeilenfortsetzung wird in Ausdrücken und Funktions-/Eigenschaftsdefinitionen unterstützt, die die Tatsache ausnutzt, dass jedes <code>(</code>/<code>[</code>/<code>{</code> mit einem entsprechenden <code>)</code>/<code>]</code>/<code>}</code> abgeglichen werden muss. Sprich, enthält eine Zeile eine nicht geschlossene Klammer <code>(</code>/<code>[</code>/<code>{</code>, wird sie mit nachfolgenden Zeilen verbunden, bis sich die Anzahl der Start- und Endklammern ausgleicht. Eine geschweifte Startklammer <code>{</code> am Ende einer Zeile wird als OTB (und nicht als Anfang einer direkten Objektschreibweise) angesehen, wenn es keine anderen ungeschlossenen Symbole gibt und unmittelbar vor der Klammer kein Operator steht.</p>
<p><strong>Bekannte Einschränkung:</strong> Wenn vor der geschweiften Startklammer <code>{</code>, die eine mehrzeilige direkte Objektschreibweise beginnt, kein Operator steht (z. B. wenn sie als Parameter übergeben wird), kann diese Klammer nicht das letzte Zeichen auf der Zeile sein, es sei denn, es gibt noch ein anderes ungeschlossenes <code>(</code>/<code>[</code>/<code>{</code>.</p>
<h3>Fortsetzungszeilen</h3>
<p><code>is</code>, <code>in</code> und <code>contains</code> können für die Zeilenfortsetzung genutzt werden, obwohl <code>in</code> und <code>contains</code> noch nicht als Operatoren reserviert/implementiert sind.</p>
<p><code>und</code>, <code>or</code>, <code>is</code>, <code>in</code> und <code>contains</code> agieren als Zeilenfortsetzungsoperatoren, auch wenn danach eine Zuweisung oder ein anderer binärer Operator erfolgt, da diese keine gültigen Variablennamen mehr sind. AHK v1 hingegen hatte Ausnahmen für <code>and</code>/<code>or</code>, gefolgt von einem beliebigen Zeichen aus <code>&lt;&gt;=/|^,:</code></p>
<h3>Typen</h3>
<p>In der Regel erzeugt v2 konsistentere Ergebnisse als v1 bei einem Code, das vom Typ eines Wertes abhängig ist.</p>
<p>In v1 kann eine Variable sowohl eine Zeichenkette als auch eine zwischengespeicherte Binärzahl enthalten, die immer dann aktualisiert wird, wenn die Variable als Zahl verwendet wird. Da diese zwischengespeicherten Binärzahl das einzige Mittel zur Erkennung des Werttyps ist, wird das Caching, welches intern via Ausdrücke wie <code>var+1</code> oder <code>abs(var)</code> erfolgt, effektiv den "Typ" von <code>Var</code> ändern. v2 deaktiviert dieses Caching, so dass <code>str := "123"</code> immer eine Zeichenkette und <code>int := 123</code> immer ein Integer sein kann. Infolgedessen muss <code>str</code> bei Bedarf jedes Mal in eine Zahl umgewandelt werden (statt nur beim ersten Mal).</p>
<p>Die internen Variablen <code>True</code>, <code>False</code>, <code>A_PtrSize</code>, <code>A_IsUnicode</code>, <code>A_Index</code> und <code>A_EventInfo</code> geben immer einen reinen Integer statt Zeichenketten zurück. In v1 geben sie manchmal Zeichenketten zurück, aufgrund von Optimierungen, die in v2 ersetzt wurden.</p>
<p>Alle direkt geschriebene Zahlen werden während der Ladezeit in reine Binärzahlen umgewandelt und deren Repräsentierung als Zeichenketten verworfen. Zum Beispiel wäre <code>MsgBox 0x1</code> das gleiche wie <code>MsgBox 1</code>, oder <code>MsgBox 1.0000</code> das gleiche wie <code>MsgBox 1.0</code> (weil die interne Gleitkommaformatierung geändert wurde). Eine Zahl, die man in eine Variable speichert oder von einer UDF zurückgeben lässt, wird ihren reinen numerischen Zustand beibehalten.</p>
<p>Die standardmäßig verwendete Formatangabe für Floating-Point-Zahlen ist nun <code>.17g</code> (vorher war es <code>0.6f</code>), was in vielen Fällen kompakter und genauer ist. Dieser Standard kann nicht geändert werden, aber mit <code>Format</code> können andere Formatierungen erzielt werden.</p>
<p>Direkt geschriebene Zeichenketten in Anführungszeichen und Zeichenketten, die mit mehreren literalen Zeichenketten in Anführungszeichen gebildet werden, werden nicht länger bedingungslos als nicht-numerisch angesehen. Stattdessen werden sie wie Zeichenketten behandelt, die in Variablen gespeichert oder von Funktionen zurückgegeben worden sind. Dies hat folgende Auswirkungen:</p>
<ul>
<li>Direkt geschriebene Anweisungen in Anführungszeichen wie <code>"0"</code> werden als False angesehen.</li>
<li><code>("0xA") + 1</code> und <code>("0x" Chr(65)) + 1</code> erzeugen 11 statt einen Fehler.</li>
<li><code>x[y:="0"]</code> und <code>x["0"]</code> verhalten sich nun gleich.</li>
</ul>
<p>Die Art und Weise wurde geändert, wie Objekte verschiedene Typen von Keys interpretieren. Im <a href="#objects"><em>Objekte</em></a>-Abschnitt, der auf dieser Seite zu finden ist, erfährst du mehr.</p>
<p>Vergleichsoperatoren wie =, &lt; und &gt;= funktionieren etwas anders. Wenn beide Operanden numerisch sind und mindestens ein Operand eine <em>reine</em> Zahl ist, werden sie numerisch verglichen. Ansonsten werden sie alphabetisch verglichen. So zum Beispiel werden 54 und "530" numerisch verglichen, während "54" und "530" alphabetisch verglichen werden. Darüber hinaus werden Zeichenketten, die in Variablen gespeichert sind, genauso wie direkt geschriebene Zeichenketten behandelt.</p>
<p><code>Type(Wert)</code> gibt eine der folgenden Zeichenketten zurück: String, Integer, Float, oder die spezifische Klasse eines Objekts.</p>
<p><code>Float(v)</code>, <code>Integer(v)</code> and <code>String(v)</code> konvertieren <code>v</code> in den jeweiligen Typ, oder lösen eine Ausnahme aus, wenn die Konvertierung nicht durchgeführt werden kann (z.B. <code>Integer("1z")</code>). <code>String</code> ruft <code>v.ToString()</code> auf, wenn <code>v</code> ein Objekt ist. (Idealerweise wäre das für jede implizite Konvertierung von Objekt zu Zeichenkette wünschenswert, aber die aktuelle Implementierung macht dies schwierig.)</p>
<h2>Objekte</h2>
<p>Objekte verwenden nun einen strukturierteren Klassen-Prototypen-Ansatz, um Klassen- und statische Elemente von Instanzelementen zu trennen. Viele der internen Methoden und Obj-Funktionen wurden verschoben, umbenannt, geändert oder entfernt.</p>
<ul>
<li>Jede benutzerdefinierte oder interne Klasse ist ein Klassenobjekt (eine Instanz von <code>Class</code>), das nur Methoden und Eigenschaften, die mit dem Schlüsselwort <code>static</code> definiert wurden (einschließlich statischer Elemente, die von der Base-Klasse geerbt wurden) und verschachtelten Klassen offenlegt.</li>
<li>Jedes Klassenobjekt hat eine <code>Prototype</code>-Eigenschaft, die zum <code>Base</code> aller Instanzen dieser Klasse wird. Alle nicht-statischen Methoden- und Eigenschaftsdefinitionen innerhalb des Klassenkörpers sind mit dem Prototype-Objekt verbunden.</li>
<li>Die Instanziierung erfolgt durch Aufruf der <code>new</code>-Methode, wie in <code>myClass.new()</code>. Im Moment ist <code>new myClass</code> äquivalent zu diesem Methodenaufruf. Dadurch kann die Klasse das Konstruktionsverhalten vollständig überschreiben (z. B. um eine Class Factory oder ein Singleton zu implementieren), obwohl die Initialisierung typischerweise noch in <code>__New</code> durchgeführt werden sollte. Der Rückgabewert von <code>__New</code> wird nun ignoriert; um den Rückgabewert zu überschreiben, verwenden Sie die <code>New</code>-Methode.</li>
</ul>
<p>Der gemischte Objekttyp wurde in <code>Object</code>, <code>Array</code> und <code>Map</code> (assoziatives Array) aufgeteilt. Derzeit sind nur diese drei Klassen und <code>Class</code> vordefiniert (und als superglobale Variablen zugänglich).</p>
<p>Object ist nun die Stammklasse für alle benutzerdefinierten <strong>und internen</strong> Objekte (außer COM-Objekte). <code>x is Object</code> ist demzufolge True, wenn x ein AutoHotkey-Objekt ist. Elemente, die zu <code>Object.Prototype</code> hinzugefügt wurden, werden von allen AutoHotkey-Objekte geerbt.</p>
<p>Der Operator <code>is</code> erwartet nun eine Klasse, also wird <code>x is y</code> nun nach <code>y.Prototype</code> in der Base-Objekt-Kette suchen und überprüfen. Um nach <code>y</code> selbst zu suchen und zu überprüfen, rufen Sie <code>x.HaseBase(y)</code> auf.</p>
<p>Benutzerdefinierte Klassen können auch explizit <code>Object</code>, <code>Array</code> oder <code>Map</code> erweitern (via "extends"), mit <code>Object</code> als Standard-Base-Klasse ist, wenn keine angegeben ist.</p>
<p>GetCapacity und SetCapacity wurden entfernt.</p>
<ul>
<li>ObjGetCapacity und ObjSetCapacity haben nur noch Einfluss auf die Kapazität des Objekts zur Aufnahme von Eigenschaften, und kommen voraussichtlich nur selten zum Einsatz. Das Setzen der Kapazität des Zeichenkettenpuffers einer Eigenschaft, eines Array-Elements oder eines Map-Elements wird nicht unterstützt; für Binärdaten können Sie ein Buffer-Objekt nutzen.</li>
<li>Array- und Map-Objekte haben eine Capacity-Eigenschaft, die der aktuellen Array- oder Map-Speicherzuweisung des Objekts entspricht.</li>
</ul>
<h3>Eigenschaften und Methoden</h3>
<p>Eigenschaften und Methoden werden nun getrennt behandelt, wie es bei Variablen und Funktionen der Fall ist:</p>
<ul>
<li>Eine Methode und eine Eigenschaft mit demselben Namen können koexistieren.</li>
<li>Es ist nicht möglich, beim Zuweisen einer Eigenschaft an ein Objekt eine Methode zu erstellen oder <strong>versehentlich zu deaktivieren</strong>.</li>
<li>Methoden und Eigenschaften können unabhängig voneinander definiert, erkannt, abgerufen und enumeriert werden. Zum Beispiel unterscheidet sich eine Methode von einer Eigenschaft, die zufällig ein <code>Func</code> zurückgibt.</li>
</ul>
<p>Die Object-Klasse definiert neue Methoden für den Umgang mit Eigenschaften und Methoden: DefineMethod, DefineProp, DeleteMethod, DeleteProp, GetMethod, GetOwnPropDesc, HasMethod, HasOwnMethod, HasOwnProp, HasProp, HasProp, OwnMethods, OwnProps.</p>
<p>Da Object, Array und Map nun getrennte Typen sind, werden Array-Elemente und Eigenschaften auch getrennt behandelt.</p>
<p>Alle internen Methoden und Eigenschaften (einschließlich <code>base</code>) werden wie benutzerdefinierte Methoden definiert. Dadurch wird sichergestellt, dass diese sich konsistent verhalten und dass sowohl interne als auch benutzerdefinierte Elemente erkannt, abgerufen oder neu definiert werden können.</p>
<p>Wenn eine Eigenschaft keine Parameter akzeptiert, werden diese automatisch an das von der Eigenschaft zurückgegebene Objekt übergeben (oder es löst eine Ausnahme aus).</p>
<p>Mehrdimensionale Array-Hacks wurden entfernt. <code>x.y[z]:=1</code> erzeugt nicht länger ein Objekt in <code>x.y</code>, außerdem ist <code>x[y,z]</code> ein Fehler, es sei denn, x.__item (oder x.__item.__item etc.) behandelt zwei Parameter.</p>
<p>Wenn eine Eigenschaft <code>get</code>, aber nicht <code>set</code> definiert, wird beim Zuweisen eines Wertes eine Ausnahme ausgelöst, anstatt die Eigenschaft überschrieben.</p>
<h3>Metafunktionen</h3>
<p>Die Metafunktionen wurden stark vereinfacht; sie verhalten sich wie normale Methoden:</p>
<ul>
<li>Es spielt keine Rolle, wo sie innerhalb der Hierarchie definiert sind.</li>
<li>Wenn die Metafunktion überschrieben ist, wird die Base-Version nicht automatisch aufgerufen. Skripte können bei Bedarf <code>base.__xxx()</code> aufrufen.</li>
<li>Wenn die Metafunktion definiert ist, muss sie die Standardaktion ausführen; wenn z. B. __set keinen Wert speichert, wird er nicht gespeichert.</li>
<li>Das Verhalten ist nicht davon abhängig, ob die Methode <code>return</code> verwendet (aber natürlich müssen __get und __call noch einen Wert zurückgeben).</li>
</ul>
<p>Methoden- und Eigenschaftsparameter werden als Array-Objekt übergeben. Dies optimiert verkettete Base/Superklassen-Aufrufe und unterstützt Autoren (in Kombination mit der MaxParams-Validierung), die Parameter zu behandeln. Bei __set wird der Zuweisungswert separat übergeben.</p>
<pre><code>this.__call(name, args)
this.__get(name, args)
this.__set(name, args, value)
</code></pre>
<p>Definierte Eigenschaften und Methoden haben Vorrang vor Metafunktionen, egal ob sie in einem Base-Objekt definiert wurden.</p>
<p>Die statische Methode __New wird für jede Klasse beim Start aufgerufen, wenn sie von dieser Klasse definiert oder von einer Superklasse geerbt wurde. Aktuell werden Klassen in der Reihenfolge ihrer Definition initialisiert, daher ist nicht garantiert, dass Superklassen vor Unterklassen initialisiert werden.</p>
<h3>Array</h3>
<p><code>class Array extends Object</code></p>
<p>Ein Array-Objekt enthält eine Liste oder Sequenz von Werten, hierbei ist Index 1 das erste Element.</p>
<p>Beim Zuweisen oder Abrufen eines Array-Elements muss der Absolutwert des Index zwischen 1 und der Länge des Arrays liegen, sonst wird eine Ausnahme ausgelöst. Die Größe eines Arrays kann durch Einfügen oder Entfernen von Elementen mit der entsprechenden Methode oder durch Ändern der Länge geändert werden.</p>
<p>Aktuell sind eckige Klammern beim Zugriff auf Elemente erforderlich; sprich, <code>a.1</code> bezieht sich auf eine Eigenschaft und <code>a[1]</code> auf ein Element.</p>
<p>Negative Werte können verwendet werden, um rückwärts zu indexieren.</p>
<p>Die Funktionsweise von Clone, Delete, InsertAt, Pop, Push und RemoveAt ist grundsätzlich gleich geblieben. HasKey wurde in Has umbenannt. Length ist nun eine Eigenschaft. Die Capacity-Eigenschaft wurde hinzugefügt.</p>
<p>Arrays können mit <code>Array(values*)</code> oder <code>Array.new(values*)</code> konstruiert werden.</p>
<p>Die Funktionsweise der For-Schleife ist <code>for val in arr</code> oder <code>for idx, val in arr</code>, wenn standardmäßig <code>idx = A_Index</code>. Das heißt, dass Elemente ohne Wert weiterhin enumeriert werden und dass der Index nicht zurückgegeben wird, wenn nur eine Variable übergeben wurde.</p>
<h3>Map</h3>
<p>Ein Map-Objekt ist ein assoziatives Array ähnlich dem v1-Objekt, aber mit geringerer Mehrdeutigkeit.</p>
<ul>
<li>Clone wird wie bisher verwendet.</li>
<li>Delete kann immer nur einen Key auf einmal löschen.</li>
<li>HasKey wurde in Has umbenannt.</li>
<li>Count ist jetzt eine Eigenschaft.</li>
<li>Die Capacity- und Clear-Eigenschaft wurde hinzugefügt.</li>
<li>Zeichenketten-Keys sind Groß-/Kleinschreibung-sensitiv und werden nie in Integer umgewandelt.</li>
</ul>
<p>Derzeit werden Float-Keys noch in Zeichenketten umgewandelt.</p>
<p>Eckige Klammern beim Zugriff auf Elemente erforderlich; sprich, <code>a.b</code> bezieht sich auf eine Eigenschaft und <code>a["b"]</code> auf ein Element. Im Gegensatz zu v1 kann eine Eigenschaft oder Methode nicht versehentlich durch die Zuweisung eines Array-Elements deaktiviert werden.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn man versucht, den Wert eines nicht existierenden Elements abzurufen.</p>
<p>Nutzen Sie <code>Map(Key, Value, ...)</code>, um ein Map-Objekt mit einer Liste von Key-Value-Paaren zu erstellen. <code>Map.new()</code> akzeptiert derzeit keine Parameter.</p>
<h3>Enumeration</h3>
<p>Das Enumeratormodell wurde geändert, um Funktionsobjekte als Enumeratoren zuzulassen.</p>
<ul>
<li>_NewEnum() wurde mit __Enum(n) ersetzt.</li>
<li>Der Pflichtparameter n enthält die Anzahl der Variablen in der For-Schleife, damit die Enumeration beeinflusst werden kann, ohne die Initialisierung verzögern zu müssen, bis IsByRef() aufgerufen werden kann.</li>
<li>Next() wurde mit Call() ersetzt, mit der gleichen Funktionsweise.</li>
<li>Wenn __Enum nicht vorhanden ist, wird das Objekt als Enumerator vermutet.</li>
</ul>
<p>Da Array-Elemente, Eigenschaften und Methoden nun getrennt behandelt werden, muss zum Enumerieren von Eigenschaften und Methoden explizit ein Enumerator via OwnMethods oder OwnProps erstellt werden.</p>
<h2>Liste</h2>
<p>Entfernt:</p>
<ul>
<li>Asc() (benutze Ord())</li>
<li>AutoTrim (benutze Trim())</li>
<li>ComObjMissing() (schreibe stattdessen zwei aufeinanderfolgende Kommas)</li>
<li>ComObjUnwrap() (benutze stattdessen ComObjValue(), und bei Bedarf ObjAddRef())</li>
<li>ComObjEnwrap() (benutze stattdessen ComObject(), und bei Bedarf ObjAddRef())</li>
<li>ComObjXXX(), wo XXX nichts anderes ist als eine der explizit definierten ComObj-Funktionen (benutze stattdessen ComObjActive() oder ComObject()).</li>
<li>ControlSendRaw (benutze stattdessen <code>ControlSend "{Raw}"</code> oder ControlSendText)</li>
<li>EnvDiv</li>
<li>EnvMult</li>
<li>EnvUpdate (dessen Nutzen war sehr begrenzt und kann mit einer einfachen SendMessage-Anweisung ersetzt werden)</li>
<li>FileReadLine (benutze eine Datei-lesende Schleife oder FileOpen)</li>
<li>Gui, GuiControl, GuiControlGet (siehe <a href="#gui">Gui</a>)</li>
<li>IfEqual</li>
<li>IfExist</li>
<li>IfGreater</li>
<li>IfGreaterOrEqual</li>
<li>IfInString</li>
<li>IfLess</li>
<li>IfLessOrEqual</li>
<li>IfMsgBox (MsgBox gibt nun den Button-Namen zurück)</li>
<li>IfNotEqual</li>
<li>IfNotExist</li>
<li>IfNotInString</li>
<li>IfWinActive</li>
<li>IfWinExist</li>
<li>IfWinNotActive</li>
<li>IfWinNotExist</li>
<li>If between/is/in/contains (aber siehe <a href="#is"><code>is</code>-Operator</a>)</li>
<li>Menu (benutze MenuCreate/MenuBarCreate, Menu-Objekt, TraySetIcon, A_IconTip, A_IconHidden und A_AllowMainWindow)</li>
<li>MenuGetHandle (benutze Menu.Handle)</li>
<li>MenuGetName (es gibt keine Menünamen; MenuFromHandle ist der nächstliegende Ersatz)</li>
<li>Progress (benutze Gui)</li>
<li>SendRaw (benutze stattdessen <code>Send "{Raw}"</code> oder SendText)</li>
<li>SetBatchLines (-1 ist nun das Standardverhalten)</li>
<li>SetEnv</li>
<li>SetFormat (format() kann zum Formatieren einer Zeichenkette benutzt werden)</li>
<li>SoundGetWaveVolume/SoundSetWaveVolume (verhalten sich etwas anders als wie SoundGet/SoundSet in Bezug auf die Balance, aber keins von denen behält die Balance bei)</li>
<li>SplashImage (benutze Gui)</li>
<li>SplashTextOn/Off (benutze Gui)</li>
<li>StringGetPos (benutze InStr)</li>
<li>StringLeft<br />

StringLen<br />

StringMid<br />

StringRight<br />

StringTrimLeft<br />
StringTrimRight -- benutze stattdessen SubStr.</li>
<li>StringReplace (benutze stattdessen StrReplace)</li>
<li>StringSplit (benutze stattdessen StrSplit)</li>
<li>Transform</li>
<li>WinGetActiveStats</li>
<li>WinGetActiveTitle</li>
<li>#CommentFlag</li>
<li>#Delimiter</li>
<li>#DerefChar</li>
<li>#EscapeChar</li>
<li>#IfWinActive, #IfWinExist, #IfWinNotActive, #IfWinNotExist (siehe <a href="#-if">#If</a>)</li>
<li>#LTrim</li>
<li>#MaxMem</li>
<li>#NoEnv (gilt jetzt immer)</li>
</ul>
<p>Umbenannt:</p>
<ul>
<li>ComObjParameter() -&gt; ComObject()</li>
<li>DriveSpaceFree -&gt; DriveGetSpaceFree</li>
<li>EnvAdd -&gt; DateAdd()</li>
<li>EnvSub -&gt; DateDiff()</li>
<li>FileCopyDir -&gt; DirCopy</li>
<li>FileCreateDir -&gt; DirCreate</li>
<li>FileMoveDir -&gt; DirMove</li>
<li>FileRemoveDir -&gt; DirDelete</li>
<li>FileSelectFile -&gt; FileSelect</li>
<li>FileSelectFolder -&gt; DirSelect</li>
<li>StringLower -&gt; StrLower (geändert)</li>
<li>StringUpper -&gt; StrUpper (geändert)</li>
<li>UrlDownloadToFile -&gt; Download</li>
<li>WinMenuSelectItem -&gt; MenuSelect</li>
<li>LV-, TV- und SB-Funktionen -&gt; Methoden von GuiControl</li>
<li>File.__Handle -&gt; File.Handle</li>
</ul>
<h3>Geänderte Befehle/Funktionen</h3>
<blockquote>
<p>Die Überschrift soll nicht suggerieren, dass es Befehle in v2 gibt. Es gibt nur Funktionen. Die Überschrift bezieht sich auf beide Versionen.</p>
</blockquote>
<p><code>Chr(0)</code> gibt eine Zeichenkette mit einer Länge von 1 zurück, weil eine binäre Null enthalten ist. Diese Änderung beruht auf der verbesserten Unterstützung für binäre Nullen in Zeichenketten.</p>
<p>ClipWait gibt nun 0 zurück, wenn die Wartezeit abgelaufen ist, ansonsten 1. ErrorLevel wird nicht gesetzt.</p>
<p><code>ComObject(pdsp)</code>, <code>ComObject(9, pdsp)</code> und <code>ComObject(13, pdsp)</code> rufen standardmäßig nicht mehr AddRef auf; sie nehmen den Pointer standardmäßig "in Besitz". Viele v1-Skripte, die <code>ComObjEnwrap(pdsp)</code> benutzen (die auf den ersten Seiten von Google zu finden sind), benutzten es falsch; genauer gesagt, sie gaben ihre eigene Kopie des Pointers nicht frei. In v2 muss das Skript <code>ObjAddRef(pdsp)</code> vor <code>ComObject(pdsp)</code> aufrufen, wenn es den Verweis nicht "besitzt" (weil der Pointer ansonsten automatisch freigegeben werden würde, wenn entweder das Wrapper-Objekt freigegeben wird oder direkt als Nebeneffekt vom Abfragen des IDispatch innerhalb eines ComObject()). Der <em>Flags</em>-Parameter hat nur noch Einfluss auf SafeArrays.</p>
<p>Control: Es wurden mehrere Änderungen am <em>Steuerelement</em>-Parameter durchgeführt, der von den Control-Funktionen, SendMessage und PostMessage verwendet wird:</p>
<ul>
<li>Dieser akzeptiert nun einen HWND (muss ein reiner Integer sein), oder ein Objekt mit einer <code>Hwnd</code>-Eigenschaft wie z. B. ein GuiControl-Objekt. Der HWND kann ein Steuerelement oder ein nicht-untergeordnetes Fenster identifizieren, obwohl letzteres in der Regel nur für einige wenige Funktionen sinnvoll ist (siehe unten).</li>
<li>Dieser Parameter ist nicht mehr optional, außer bei Funktionen, die mit einem nicht-untergeordneten Fenster agieren können (ControlSend[Text], ControlClick, SendMessage, PostMessage) oder wenn andere optionale Parameter davor sind (ControlGetList, ControlGetPos, ControlMove).</li>
<li>Fehlt dieser Parameter, wird stattdessen das Zielfenster verwendet. Diese Änderung entspricht dem vorherigen Verhalten von SendMessage/PostMessage und ersetzt den von ControlSend verwendeten speziellen Wert <code>ahk_parent</code>.</li>
<li>Leere Werte sind ungültig. Standardmäßig agieren solche Funktionen nie mit dem obersten Steuerelement des Zielfensters.</li>
</ul>
<p>ControlGetFocus gibt nun den HWND statt ClassNN des  Steuerelements zurück, und setzt ErrorLevel auf 0 statt 1, wenn es erfolgreich feststellen konnte, dass das Fenster kein fokussiertes Steuerelement hat.</p>
<p>ControlMove, ControlGetPos und ControlClick verwenden nun Clientkoordinaten (wie GuiControl) statt Fensterkoordinaten. Clientkoordinaten sind relativ zur oberen linken Ecke des Clientbereichs (das ist der Bereich ohne Titelleiste und Rahmen). (Steuerelemente werden nur im Clientbereich gerendert.)</p>
<p>Die Parameterreihenfolge von ControlMove, ControlSend und ControlSetText ist nun im Einklang mit anderen Control-Funktionen; das heißt, dass <em><strong>Steuerelement</strong>, Fenstertitel, Fenstertext, Titelausnahme, Textausnahme</em> immer zusammen sind (am Ende der Parameterliste), um das Einprägen der Parameter zu fördern.</p>
<p>DllCall: Wenn ein Typ-Parameter eine Variable ist, wird immer der Inhalt dieser Variable verwendet, niemals ihr Name. Das heißt, dass Typennamen ohne Anführungszeichen nicht mehr unterstützt werden - die Namen der Typen müssen in Anführungszeichen gesetzt werden.</p>
<p>DllCall: AStr kann nur noch ein Eingabeparameter sein. Da der Puffer immer nur so groß wie die Eingabezeichenkette sein kann, war AStr nie nützlich für Ausgabeparameter. Dies gilt für WStr statt AStr, wenn das Skript in ANSI kompiliert wurde (aber v2 ist aktuell nur Unicode).</p>
<p>DllCall akzeptiert nun ein Objekt für jeden <code>Ptr</code>-Parameter; das Objekt muss eine <code>Ptr</code>-Eigenschaft haben. Für Puffer, die vom Skript reserviert werden, wird das neue <code>Buffer</code>-Objekt gegenüber einer Variable bevorzugt.</p>
<p>FileAppend nutzt standardmäßig End-of-Line-Umwandlungen, um konsistent mit FileRead und FileOpen zu sein. FileAppend und FileRead haben jeweils einen separaten <em>Optionen</em>-Parameter, der die Optionspräfixe ersetzt und optional einen Kodierungsnamen enthalten kann (um FileRead's <code>*Pnnn</code>-Option abzulösen). FileAppend, FileRead und FileOpen benutzen <code>"`n"</code>, um End-of-Line-Umwandlungen zu aktivieren. FileAppend und FileRead unterstützen die Option <code>"RAW"</code>, um die Zeichensatzkonvertierung zu deaktivieren (Lesen/Schreiben von binären Daten); FileRead gibt in diesem Fall ein <code>Buffer</code>-Objekt zurück. Diese Option ersetzt <code>*c</code> (siehe ClipboardAll). FileAppend kann ein <code>Buffer</code>-ähnliches Objekt akzeptieren, in diesem Fall werden keine Konvertierungen durchgeführt.</p>
<p>File.RawRead und File.RawWrite akzeptieren jetzt eine Variable, die eine Adresse enthält (als reiner Integer); früher wurde die zwischengespeicherte numerische Zeichenkette der Variable benutzt oder überschrieben, was zu inkonsistenten Ergebnissen führte.</p>
<p>Für Puffer, die vom Skript reserviert werden, wird das neue <code>Buffer</code>-Objekt gegenüber einer Variable bevorzugt; es kann ein beliebiges Objekt verwendet werden, solange es über die Eigenschaften <code>Ptr</code> und <code>Size</code> verfügt.</p>
<blockquote>
<p><strong>Hinweis:</strong> Ein zukünftiges Update wird die Unterstützung eventuell entfernen, den Zeichenkettenpuffer einer Variable für andere Zwecke zu nutzen. Skripte sollten zukünftig <code>BufferAlloc()</code> verwenden.</p>
</blockquote>
<p><strong>Bereits veraltet:</strong> Wenn File.RawRead eine Variable gegeben wird, ist <em>Bytes</em> optional und standardmäßig die Kapazität der Variable. Die Länge der Variable wird auf die Zeichenlänge der Daten aktualisiert (<code>Ceil(bytes_lesen / 2)</code>).</p>
<p>File.RawWrite kann eine Zeichenkette (oder eine Variable mit einer Zeichenkette) akzeptieren - in diesem Fall ist <em>Bytes</em> standardmäßig die Größe der Zeichenkette in Bytes. Die Zeichenkette kann binäre Nullen enthalten.</p>
<p>File.ReadLine unterstützt nun immer <code>`r</code>, <code>`n</code> und <code>`r`n</code> als Zeilenenden. Zeilenenden werden weiterhin so wie sind via Read() an das Skript zurückgegeben, wenn die EOL-Umwandlung deaktiviert ist.</p>
<p>FileEncoding ermöglicht nun die Angabe von Zeichensätzen via Nummer, ohne dass das Präfix <code>CP</code> notwendig ist.</p>
<p>FileExist ignoriert nun <code>.</code> und <code>..</code>, das in jeder Verzeichnisliste vorkommt, demzufolge ist <code>FileExist("dir\*")</code> nun False statt True, wenn das Verzeichnis existiert aber leer ist.</p>
<p>FileSelectFile (jetzt unter dem Namen FileSelect bekannt) hatte zwei Mehrfachauswahl-Modi, die über Option 4 und M erreichbar waren. Option 4 und der entsprechende Modus wurden entfernt; sie waren eine lange Zeit nicht in der Doku erwähnt.</p>
<p>FileSetAttrib überschreibt absofort Attribute, wenn kein +, - oder ^ als Präfix vorhanden ist, anstatt nichts zu tun. Zum Beispiel würde <code>FileSetAttrib(FileGetAttrib(Datei2), Datei1)</code> die Attribute von Datei2 nach Datei1 kopieren (fügt alles hinzu, das Datei2 hat, und entfernt alles, das es nicht hat).</p>
<p>FileSetAttrib und FileSetTime: Die Parameter OrdnerEinbeziehen? und Rekursiv?- wurden mit einem Einzelmodusparameter ersetzt, so ähnlich wie beim LoopFile-Befehl. Zum Beispiel <code>FileSetAttrib("+a", "*.zip", "RF")</code> (Nur Dateien rekursiv abarbeiten).</p>
<p><code>File.ReadLine()</code> fügt nicht länger das Zeilenende in den Rückgabewert ein.</p>
<p><code>Func(Fn)</code> gibt eine leere Zeichenkette (statt 0) zurück, wenn die Funktion nicht existiert. Wenn <em>Fn</em> eine verschachtelte Funktion ist (nicht möglich in v1), wird sie eventuell ein neues <code>Closure</code> zurückgeben.</p>
<p>GetKeyState gibt nun immer 0 oder 1 zurück.</p>
<p>GroupAdd: Der Label-Parameter und ähnliche Funktionalitäten wurden entfernt. Diese nicht sehr intuitive Methode war eine Möglichkeit, um festzustellen, ob GroupActivate passende Fenster finden konnte; stattdessen ist ErrorLevel sinnvoll.</p>
<p><code>Hotkey</code> benutzt nicht länger standardmäßig das <code>#If</code> ganz unten im Skript. Hotkey/Hotstring-Threads benutzen standardmäßig dasselbe Kriterium wie der Hotkey, demzufolge würde <code>Hotkey A_ThisHotkey, "Off"</code> den aktuellen Hotkey deaktivieren, sogar wenn er kontextabhängig wäre. Alle anderen Threads benutzen standardmäßig die zuletzt im automatischen Ausführungsbereich definierte Einstellung, die selbst standardmäßig auf kein Kriterium gesetzt ist (globale Hotkeys).</p>
<p><code>Hotkey</code> erteilt folgenden Werten absofort eine Spezialbehandlung und wird sie nie als Label-/Funktionsnamen behandeln: <code>On</code>, <code>Off</code>, <code>Toggle</code>, <code>AltTab</code>, <code>ShiftAltTab</code>, <code>AltTabAndMenu</code>, <code>AltTabMenuDismiss</code>. Früher wurde das Label oder die Funktion sofern vorhanden benutzt, aber nur, wenn der <em>Label</em>-Parameter keinen Variablenverweis oder Ausdruck enthielt.</p>
<p><code>Hotkey</code>'s <em>Label</em>-Parameter unterstützt nun jede Art von Ausdruck, der ein Objekt zurückgibt, und benötigt keinen Variablenverweis. Wenn der Name eines Labels genutzt wird, muss es global sein (außerhalb einer Funktion definiert sein).</p>
<p><code>Hotkey "If"</code> erkennt nun Ausdrücke, die die Operatoren <code>and</code> oder <code>or</code> benutzen. In v1 hat das nicht funktioniert, weil solche Operatoren während der Ladezeit mit <code>&amp;&amp;</code> oder <code>||</code> ersetzt wurden.</p>
<p><code>Hotkey "If.."</code> setzt nie den ErrorLevel. Bei Misserfolg wird eine Ausnahme ausgelöst.</p>
<p><code>#If</code> wurde so optimiert, dass einfache Aufrufe von WinActive() oder WinExist() direkt vom Hook-Thread ausgewertet werden können (wie es bei #IfWin in v1 der Fall war, und bei <code>Hotkey("IfWin...</code> noch der Fall ist). Dies verbessert die Performance und reduziert das Risiko von Problemen, wenn das Skript beschäftigt ist oder nicht reagiert. Diese Optimierung gilt für Ausdrücke, die einen einzelnen Aufruf von WinActive() oder WinExist() mit bis zu zwei Parametern enthalten, wo jeder Parameter eine einfache in Anführungszeichen gesetzte Zeichenkette ist und das Ergebnis optional mit <code>!</code> oder <code>not</code> invertiert wird. Zum Beispiel <code>#If WinActive("Chrome")</code> oder <code>#If !WinExist("Popup")</code>. In solchen Fällen kann der erste Ausdruck mit einer beliebigen Kombination von Kriterien entweder via Ausdruck oder via Fensterkriterien identifiziert werden. Zum Beispiel verweisen <code>Hotkey('If', '!WinExist("Popup")')</code> und <code>Hotkey("IfWinNotExist", "Popup")</code> auf dieselben Hotkey-Varianten.</p>
<p>ImageSearch gibt 1 (true) zurück, wenn das Bild im angegebenen Bereich gefunden wurde, oder 0 (false), wenn es nicht gefunden wurde, oder löst eine Ausnahme aus, wenn die Suche nicht durchgeführt werden konnte. ErrorLevel wird nicht gesetzt.</p>
<p>IniRead gibt als Standardwert eine leere Zeichenkette aus, wenn der <em>Standardwert</em>-Parameter fehlt, statt des Wortes <code>ERROR</code>. Zusätzlich wird ErrorLevel gesetzt, wenn ein Fehler auftritt.</p>
<p>Input gibt nun immer die Endungszeichen a-z als Kleinbuchstaben zurück, um konsistent mit anderen Zeichen (oder Nicht-US-Tastatur-Layouts) zu sein. Früher begann <code>Input x</code> die Eingabe zu erfassen, während <code>Input</code> selbst nur jegliche laufende Eingabe terminierte. Da es keinen AusgabeVar-Parameter mehr gibt, beginnt <code>Input</code> nun immer die Eingabe zu erfassen, während <code>InputEnd</code> die Eingabe terminiert. Der ursprüngliche <code>Input</code>-Aufruf setzt ErrorLevel auf "Stopped", wenn InputEnd aufgerufen wurde. Input behandelt nun UMSCHALT+RÜCKTASTE wie RÜCKTASTE, anstatt es in <code>`b</code> zu übersetzen.</p>
<p>Die Syntax von InputBox wurde komplett überarbeitet, um dessen Benutzerfreundlichkeit zu verbessern (weniger Parameter). Siehe <a href="#inputbox">InputBox</a>, um mehr zu erfahren.</p>
<p>InStr's <em>CaseSensitive</em>-Parameter wird nun nach den üblichen booleschen Regeln ausgewertet. In v1 wurden nicht-numerische Werte in <code>0</code> (<em>False</em>) umgewandelt. In v2 werden nicht-numerische Werte außer <code>""</code> als <em>True</em> angesehen.</p>
<p><code>IsFunc(Fn)</code> löst nun eine Ausnahme aus, wenn ein Objekt übergeben wird. Es sollte nur zur Validierung von Funktionsnamen verwendet werden.</p>
<p>KeyWait gibt nun 0 zurück, wenn die Wartezeit abgelaufen ist, ansonsten 1. ErrorLevel wird nicht gesetzt.</p>
<p>Die Syntax von MsgBox wurde geändert, um dessen häufig benutzten Parameter zu priorisieren und Benutzerfreundlichkeit zu verbessern. Die "intelligente" Kommahandhabung wurde entfernt; das heißt, dass Kommas genauso behandelt werden wie bei anderen Funktionen. Siehe <a href="#msgbox">MsgBox</a>, um mehr zu erfahren.</p>
<p>NumPut/NumGet: Übergibt man eine Variable mit einer reinen Zahl an die <code>VarOderAdresse</code>-Parameter, wird der Variablenwert statt der Variablenadresse genutzt. Für Puffer, die vom Skript reserviert werden, wird das neue <code>Buffer</code>-Objekt gegenüber einer Variable bevorzugt; es kann ein beliebiges Objekt verwendet werden, solange es über die Eigenschaften <code>Ptr</code> und <code>Size</code> verfügt.</p>
<blockquote>
<p><strong>Hinweis:</strong> Ein zukünftiges Update wird die Unterstützung eventuell entfernen, den Zeichenkettenpuffer einer Variable für andere Zwecke zu nutzen. Skripte sollten zukünftig <code>BufferAlloc()</code> verwenden.</p>
</blockquote>
<p>NumPut erhält einen zusätzlichen Modus, mit dem mehrere Nummern pro Aufruf geschrieben werden können, indem jeder Nummer der Typ als Zeichenkette vorangestellt wird. Zum Beispiel: <code>NumPut("ptr", a, "int", b, "int", c, addrOrBuffer, offset)</code>.</p>
<blockquote>
<p><strong>Hinweis:</strong> Die alten Modi von NumPut werden eventuell entfernt. Genauer gesagt <code>NumPut(num, addr, offset, type)</code>, <code>NumPut(num, addr, type)</code> und <code>NumPut(num, addr)</code>. Die oben gezeigte neue Syntax wird eventuell verpflichtend.</p>
</blockquote>
<p><code>Object()</code> und <code>{}</code> bewirken nicht länger, dass <code>__Set</code> bei jedem Key-Value-Paar aufgerufen wird. <code>Object(obj)</code> wird nicht länger AddRef aufrufen und die Adresse des Objekts zurückgeben. Bei Bedarf kann man stattdessen <code>ObjAddRef(addr := &amp;obj)</code> benutzen.</p>
<p><code>OnExit</code> (der Befehl) wurde entfernt; benutze stattdessen die OnExit()-Funktion, die es seit v1.1.20 gibt. A_ExitReason wurde ebenfalls entfernt; dessen Wert erhält man jetzt über einen Parameter der OnExit-Callback-Funktion.</p>
<p><code>OnClipboardChange:</code> (das Label) wird nicht mehr automatisch aufgerufen, wenn es vorhanden ist. Benutze stattdessen die OnClipboardChange()-Funktion, die es seit v1.1.20 gibt.</p>
<p>OnMessage wurde geändert, um Funktionsnamen genauso zu behandeln, wie Funktionsverweise in v1.1.20 behandelt werden. Das heißt, dass <code>OnMessage(x, "MeineFunk")</code> MeineFunk für Nachricht x registriert, aber anderen Funktionen erlaubt, Nachricht x zu überwachen. Die Funktion kann mit <code>OnMessage(x, "MeineFunk", 0)</code> deregistriert werden, nicht mit  <code>OnMessage(x, "")</code>, das nun einen Fehler erzeugen würde. <code>OnMessage(x)</code> erzeugt absofort auch einen Fehler. Bei Misserfolg wird OnMessage eine Ausnahme auslösen.</p>
<p>PixelSearch und PixelGetColor nutzen RGB- statt BGR-Farbwerte, um konsistent mit anderen Funktionen zu sein. Beide Funktionen lösen eine Ausnahme aus, wenn ein Problem auftritt, und setzen keinen ErrorLevel mehr. PixelSearch gibt 1 (true) zurück, wenn die Farbe gefunden wurde. PixelSearch verwendet nun standardmäßig den Fast-Modus und hat eine Option für den Slow-Modus.</p>
<p>PostMessage: Siehe SendMessage.</p>
<p><code>Random, , NeuerStartwert</code> wurde früher benutzt, um einen neuen Startwert für den Zufallszahlengenerator zu bestimmen. Da Random keinen AusgabeVar-Parameter zum Weglassen mehr hat, wird dieses Verfahren durch <code>RandomSeed</code> ersetzt.</p>
<p>Die RegExMatch-Optionen O und P wurden entfernt; der O-Modus (Objekt) ist nun fest integriert. Das RegExMatch-Objekt unterstützt nun die Enumeration (For-Schleife).</p>
<p>RegisterCallback wurde in CallbackCreate umbenannt und zugunsten für Closures verbessert:</p>
<ul>
<li>Unterstützung für Funktionsobjekte hinzugefügt.</li>
<li>EventInfo-Parameter entfernt (nutzen Sie stattdessen ein Closure oder eine Bound-Funktion).</li>
<li>Das spezielle Verhalten von variadischen Callback-Funktionen wurde entfernt und die <code>&amp;</code>-Option hinzugefügt (Adresse der Parameterliste übergeben).</li>
<li><code>CallbackFree(Adresse)</code> hinzugefügt, um den Callback-Speicher freizugeben und das dazugehörige Funktionsobjekt freizugeben.</li>
</ul>
<p>Registry-Funktionen (RegRead, RegWrite, RegDelete): die neu hinzugefügte Syntax seit v1.1.21 ist nun die einzige Syntax. Rootkey und Subkey wurden zusammengefasst. Schreibe statt <code>RootKey, Key</code> nun <code>RootKey\Key</code>. Um eine Verbindung zu einer Remote-Registry aufzubauen, muss <code>\\ComputerName\RootKey\Key</code> statt <code>\\ComputerName:RootKey, Key</code> benutzt werden.</p>
<p>Die Parameter von RegWrite wurden neu angeordnet, so dass <em>Wert</em> der erste Parameter ist, wie bei  IniWrite (aber dies hat keinen Einfluss auf den Einzelparametermodus, wo <em>Wert</em> der einzige Parameter war).</p>
<p>Wenn <em>KeyName</em> fehlt und das aktuelle Registry-Schleifenelement ein Subkey ist, wird RegDelete, RegRead und RegWrite nun Werte innerhalb dieses Subkeys abarbeiten; das heißt, dass <em>KeyName</em> in diesem Fall standardmäßig <code>A_LoopRegKey "\" A_LoopRegName</code> ist (beachte, dass A_LoopRegKey und A_LoopRegSubKey zusammengefasst worden sind). Früher verhielten sie sich wie folgt:</p>
<ul>
<li>RegRead las einen Wert mit dem gleichen Namen wie der Subkey, wenn einer im übergeordneten Key vorhanden war.</li>
<li>RegWrite gab einen Fehler zurück.</li>
<li>RegDelete löschte den Subkey.</li>
</ul>
<p>Bei RegDelete, RegRead und RegWrite kann nun <em>Wertname</em> angegeben werden, wenn man <em>KeyName</em> weglässt:</p>
<ul>
<li>Wenn das aktuelle Registry-Schleifenelement ein Subkey ist, wird <em>Wertname</em> standardmäßig leer (der Standardwert des Subkeys) und <em>Werttyp</em> zwingend notwendig sein.</li>
<li>Wenn das aktuelle Registry-Schleifenelement ein Wert ist, wird <em>Wertname</em> und <em>Werttyp</em> standardmäßig der Name und Typ des Wertes sein, die einzeln oder beide überschrieben werden können.</li>
</ul>
<p>Ansonsten wird RegDelete mit leerem oder fehlendem <em>Wertname</em> den Standardwert des Keys (nicht den Key selbst) nun löschen, um konsistent mit RegWrite, RegRead und A_LoopRegName zu sein. Das Schlüsselwort "AHK_DEFAULT" hat keine besondere Bedeutung mehr. Mit RegDeleteKey (neu) kann ein Key gelöscht werden.</p>
<p>RegRead hatte einen undokumentierten 5-Parameter-Modus, wo man den Werttyp nach der Ausgabevariable angeben konnte. Dieser wurde entfernt.</p>
<p>Run und RunWait ignorieren absofort die <code>UseErrorLevel</code>-Option. Verwenden Sie stattdessen try/catch. <code>A_LastError</code> wird bedingungslos gesetzt und kann nach dem Abfangen/Unterdrücken einer Ausnahme überprüft werden. RunWait gibt den Exitcode zurück. ErrorLevel wird nicht gesetzt.</p>
<p>Die wParam- und lParam-Parameter von SendMessage und PostMessage müssen nun Integer oder Objekte mit Ptr-Eigenschaft sein; es wird eine Ausnahme ausgelöst, wenn ihnen eine nicht-numerische Zeichenkette oder Floating-Point-Zahl zugewiesen wird. Früher wurde eine Zeichenkette via Adresse übergeben, wenn der Ausdruck mit <code>"</code> begann, aber andere Zeichenketten wurden zwangsweise in Integern umgewandelt. <code>&amp;var</code> zu übergeben bewirkt nicht länger, dass die Länge der Variable aktualisiert wird (nutzen Sie <code>VarSetCapacity(var, -1)</code>).</p>
<p>SendMessage setzt ErrorLevel nun nur noch auf 0 oder 1, um zu kennzeichnen, ob ein Fehler aufgetreten ist, und gibt die Antwort der Meldung zurück (oder bei Misserfolg eine leere Zeichenkette).</p>
<p>SetTimer's erster Parameter unterstützt nun jede Art von Ausdruck, der ein Objekt zurückgibt, und benötigt keinen Variablenverweis. Labelnamen werden länger unterstützt.</p>
<p>Sort: Der <em>VarName</em>-Parameter wurde aus Flexibilitätsgründen in einzelne Eingabe-/Ausgabeparameter aufgeteilt. Sort wird jetzt wie folgt genutzt: <code>Ausgabe := Sort(Eingabe [, Optionen, Callback])</code>.</p>
<p>SoundGet gibt nun 1 oder 0 für boolesche Einstellungen anstelle von "On" oder "Off" zurück, was das Invertieren des Wertes erleichtert (<code>not</code>/<code>!</code>).</p>
<p>StrGet: Wenn der Wert in <em>Länge</em> negativ ist, wird sein absoluter Wert die genaue Anzahl der Zeichen bestimmen, die umgewandelt werden sollen, einschließlich aller binären Nullen, die die Zeichenkette enthalten könnte - das heißt, dass das Ergebnis immer eine Zeichenkette mit exakt dieser Länge sein wird. Wenn der Wert in <em>Länge</em> positiv ist, wird die Zeichenkette wie in v1 bei der ersten binären Null enden.</p>
<p>StrGet/StrPut: Der <em>Adresse</em>-Parameter kann ein Objekt mit den Eigenschaften <code>Ptr</code> und <code>Size</code> sein, wie z. B. das neue <code>Buffer</code>-Objekt. Das Lesen/Schreiben wird automatisch via <code>Size</code> limitiert (in Bytes). Wenn zudem <em>Length</em> angegeben ist, darf es nicht <em>Size</em> überschreiten (multipliziert mit 2 bei UTF-16).</p>
<p>Der Rückgabewert von StrPut ist nun in Bytes, so dass er direkt an BufferAlloc() oder VarSetCapacity() übergeben werden kann.</p>
<p>Suspend: Die erste Zeile eines Hotkeys oder Hotstrings dazu bringen, Suspend aufzurufen, führt nicht länger dazu, dass der Hotkey oder Hotstring automatisch von Sperrung befreit wird. Verwenden Sie stattdessen <code>#SuspendExempt</code>. Der Permit-Parameter ist nicht länger gültig.</p>
<p>SysGet hat jetzt nur noch numerische Unterbefehle; alle anderen Unterbefehle wurden in Funktionen aufgeteilt. Siehe <a href="#sub-commands">Unterbefehle</a>, um mehr zu erfahren.</p>
<p>TrayTip's Syntax wurde geändert zu <code>TrayTip [, Text, Titel, Optionen]</code>. <em>Optionen</em> ist eine Zeichenkette bestehend aus eine oder mehreren Optionen, deren Groß-/Kleinschreibung egal ist und mit Leer- oder Tabulatorzeichen voneinander getrennt sind. Die Optionen sind <code>Iconx</code>, <code>Icon!</code>, <code>Iconi</code>, <code>Mute</code> und/oder nach wie vor ein beliebiger numerischer Wert. TrayTip wird jetzt auch angezeigt, wenn <em>Text</em> weggelassen wird (das nun im Gegensatz zu v1 seltener aus Versehen passieren kann). Der <em>Sekunden</em>-Parameter ist nicht mehr vorhanden (er funktionierte nicht in Windows Vista oder höher).</p>
<p><code>VarSetCapacity(var, -1)</code> erkennt nun, wenn var nicht null-terminiert ist, und beendet das Programm mit einer Fehlermeldung, da eine sichere Ausführung nicht garantiert werden kann.</p>
<p>Die Parameterreihenfolge von WinSetTitle und WinMove ist nun im Einklang mit anderen Fensterfunktionen; das heißt, dass <em>Fenstertitel, Fenstertext, Titelausnahme, Textausnahme</em> immer zusammen sind (am Ende der Parameterliste), um das Einprägen der Parameter zu fördern.</p>
<p>WinMove erteilt dem Wort <code>DEFAULT</code> nicht länger eine Spezialbehandlung. Lass den Parameter stattdessen weg oder verwende eine leere Zeichenkette (funktioniert sowohl in v1 als auch in v2).</p>
<p>WinWait, WinWaitClose, WinWaitActive und WinWaitNotActive geben einen Wert ungleich Null zurück, wenn sie aufhören zu warten (Zeitlimit nicht überschritten wurde), und setzen kein ErrorLevel. WinWait und WinWaitActive geben das HWND des gefundenen Fensters zurück. WinWaitClose setzt nun das Zuletzt Gefundene Fenster; das heißt, wenn WinWaitClose das Zeitlimit überschritten hat, gibt es False zurück und bewirkt, dass <code>WinExist()</code> dessen Zuletzt Gefundene Fenster zurückgibt.</p>
<p><strong>Unsortiert:</strong></p>
<p>Eine negative <em>Startposition</em> bei InStr, SubStr, RegExMatch und RegExReplace wird als Endposition der Zeichenkette angesehen, beginnend bei 1. Position -1 ist das Zeichen ganz rechts (in v1 war es die Position 0), und Position 0 ist ungültig.</p>
<p>Funktionen, die On/Off/Toggle akzeptieren, werden absofort auch 1/0/-1 akzeptieren (was bei Ausdrücken praktischer ist).</p>
<p>Die folgenden Funktionen geben einen reinen Integer statt eine hexadezimale Zeichenkette zurück:</p>
<ul>
<li>ControlGetExStyle</li>
<li>ControlGetHwnd</li>
<li>ControlGetStyle</li>
<li>MouseGetPos</li>
<li>WinActive</li>
<li>WinExist</li>
<li>WinGetID</li>
<li>WinGetIDLast</li>
<li>WinGetList</li>
<li>WinGetStyle</li>
<li>WinGetStyleEx</li>
<li>WinGetControlsHwnd</li>
</ul>
<p><code>A_ScriptHwnd</code> gibt aufgrund von technischen Einschränkungen eine Zeichenkette zurück, aber aus Konsistenzgründen in dezimal.</p>
<h4>Loop-Unterbefehle</h4>
<p>Der Unterbefehl muss direkt geschrieben werden; er darf weder in Anführungszeichen stehen noch eine Variable oder ein Ausdruck sein. Alle anderen Parameter sind Ausdrücke. Alle Loop-Unterbefehle unterstützen nun OTB.</p>
<p>Entfernt:</p>
<pre><code>Loop, Dateimuster [, OrdnerEinbeziehen?, Rekursiv?]
Loop, Rootkey [, Key, SubkeysEinbeziehen?, Rekursiv?]
</code></pre>
<p>Benutze stattdessen folgendes (seit v1.1.21 verfügbar):</p>
<pre><code>Loop Files, Dateimuster [, Modus]
Loop Reg, Rootkey\Key [, Modus]
</code></pre>
<p>A_LoopRegKey enthält nun den Rootkey und Subkey, und A_LoopRegSubKey wurde entfernt.</p>
<h4>InputBox</h4>
<pre><code>AusgabeVar := InputBox([Text, Titel, Optionen, Standardwert])
</code></pre>
<p>Der Optionen-Parameter akzeptiert eine Zeichenkette mit 0 oder mehreren case-insensitiven Optionen, jeweils getrennt mit einem Leer- oder Tabulatorzeichen, so ähnlich wie Gui-Steuerelement-Optionen. Die folgende Zeichenkette würde alle unterstützten Optionen enthalten: <code>x0 y0 w100 h100 T10.0 Password*</code>. <code>T</code> ist Timeout (Zeitlimit); <code>Password</code> stimmt mit der gleichwertigen Edit-Steuerelement-Option überein.</p>
<p>Der Titel wird leer sein, wenn der Titel-Parameter eine leere Zeichenkette ist. Der Titel wird standardmäßig <code>A_ScriptName</code> sein, wenn der Parameter komplett fehlt, um konsistent mit optionalen Parametern von benutzerdefinierten Funktionen zu sein.</p>
<h4>MsgBox</h4>
<pre><code>Ergebnis := MsgBox([Text, Titel, Optionen])
</code></pre>
<p>Der Optionen-Parameter akzeptiert eine Zeichenkette mit 0 oder mehreren case-insensitiven Optionen, jeweils getrennt mit einem Leer- oder Tabulatorzeichen, so ähnlich wie Gui-Steuerelement-Optionen.</p>
<ul>
<li><code>Iconx</code>, <code>Icon?</code>, <code>Icon!</code> und <code>Iconi</code> setzen das Symbol.</li>
<li><code>Default</code>, unmittelbar gefolgt von einem Integer, bestimmt den <em>n</em>-ten Button als Standard-Button.</li>
<li><code>T</code>, unmittelbar gefolgt von einem Integer oder einer Gleitkommazahl, bestimmt den Timeout in Sekunden.</li>
<li><code>Owner</code>, unmittelbar gefolgt von einem HWND-Wert, bestimmt das übergeordnete Fenster, und überschreibt die <code>+OwnDialogs</code>-Gui-Option.</li>
<li>Folgende Zeichenketten (schließen sich gegenseitig aus) bestimmen die Auswahl der Buttons: <code>OK</code>, <code>OKCancel</code>, <code>AbortRetryIgnore</code>, <code>YesNoCancel</code>, <code>YesNo</code>, <code>RetryCancel</code>, <code>CancelTryAgainContinue</code>, oder einfach die via Schrägstrich getrennte Initialen (<code>o/c</code>, <code>y/n</code>, etc.), oder einfach die Initialen ohne Schrägstrich.</li>
<li>Beliebiger numerischer Wert, so wie bei v1. Numerische Werte können mit Zeichenkettenoptionen kombiniert werden, oder Optionen kann ein reiner Integer sein.</li>
</ul>
<p>Der Rückgabewert ist der Name des Buttons, ohne Leerzeichen. Diese Zeichenketten sind dieselben, die bei IfMsgBox in v1 benutzt wurden.</p>
<p>Der Titel wird leer sein, wenn der Titel-Parameter eine leere Zeichenkette ist. Der Titel wird standardmäßig <code>A_ScriptName</code> sein, wenn der Parameter komplett fehlt, um konsistent mit optionalen Parametern von benutzerdefinierten Funktionen zu sein.</p>
<h4>Unterbefehle</h4>
<p>Unterbefehle von Control, ControlGet, Drive, DriveGet, WinGet, WinSet und Process wurden durch einzelne Funktionen ersetzt, und die Hauptbefehle wurden entfernt. Namen und Benutzung wurden bei mehreren Funktionen geändert. Diese Funktion werden jetzt wie folgt benutzt:</p>
<pre><code>; Die "..." sind die optionalen Parameter Steuerelement, Fenstertitel, etc.

Boolean := ControlGetChecked(...)
Boolean := ControlGetEnabled(...)
Boolean := ControlGetVisible(...)
Integer := ControlGetTab(...)
Zkette  := ControlGetChoice(...)
Zkette  := ControlGetList([Optionen, ...])
Integer := ControlGetLineCount(...)
Integer := ControlGetCurrentLine(...)
Integer := ControlGetCurrentCol(...)
Zkette  := ControlGetLine(N [, ...])
Zkette  := ControlGetSelected(...)
Integer := ControlGetStyle(...)
Integer := ControlGetExStyle(...)
Integer := ControlGetHwnd(...)

           ControlSetChecked(TrueFalseOnOffToggle [, ...])
           ControlSetEnabled(TrueFalseOnOffToggle [, ...])
           ControlShow(...)
           ControlHide(...)
           ControlSetStyle(Wert [, ...])
           ControlSetExStyle(Wert [, ...])
           ControlShowDropDown(...)
           ControlHideDropDown(...)
           ControlSetTab(Index [, ...])
           ControlChoose(Index [, ...])
Index   := ControlChooseString(Zeichenkette [, ...])
           ControlEditPaste(Zeichenkette [, ...])

Index   := ControlFindItem(Zeichenkette [, ...])
Index   := ControlAddItem(Zeichenkette [, ...])
           ControlDeleteItem(Index [, ...])

           DriveEject([Laufwerk, Schließen := false])
           DriveLock(Laufwerk)
           DriveUnlock(Laufwerk)
           DriveSetLabel(Laufwerk [, Label])

Zkette  := DriveGetList([Typ])
Zkette  := DriveGetFilesystem(Laufwerk)
Zkette  := DriveGetLabel(Laufwerk)
Zkette  := DriveGetSerial(Laufwerk)
Zkette  := DriveGetType(Pfad)
Zkette  := DriveGetStatus(Pfad)
Zkette  := DriveGetStatusCD(Laufwerk)
Integer := DriveGetCapacity(Pfad)
Integer := DriveGetSpaceFree(Pfad)

; Die "..." sind die optionalen Parameter Fenstertitel, etc.

Integer := WinGetID(...)
Integer := WinGetIDLast(...)
Integer := WinGetPID(...)
Zkette  := WinGetProcessName(...)
Zkette  := WinGetProcessPath(...)
Integer := WinGetCount(...)
Array   := WinGetList(...)
Integer := WinGetMinMax(...)
Array   := WinGetControls(...)
Array   := WinGetControlsHwnd(...)
Integer := WinGetTransparent(...)
Zkette  := WinGetTransColor(...)
Integer := WinGetStyle(...)
Integer := WinGetExStyle(...)

           WinSetTransparent(N [, ...])
           WinSetTransColor("Farbe [N]" [, ...]),
           WinSetAlwaysOnTop([Wert := "Toggle", ...])
           WinSetStyle(Wert [, ...])
           WinSetExStyle(Wert [, ...])
           WinSetEnabled(Wert [, ...])
           WinSetRegion(Wert [, ...])

           WinRedraw(...)
           WinMoveBottom(...)
           WinMoveTop(...)

; Diese Vier haben alle aktuell einen AusgabeVar:
PID     := ProcessExist([PID_oder_Name])
PID     := ProcessClose(PID_oder_Name)
PID     := ProcessWait(PID_oder_Name [, Timeout])
PID     := ProcessWaitClose(PID_oder_Name [, Timeout])

           ProcessSetPriority(Priorität [, PID_oder_Name])
</code></pre>
<p>ProcessExist, ProcessClose, ProcessWait und ProcessWaitClose setzen kein ErrorLevel mehr; stattdessen geben sie die PID zurück.</p>
<p>HWNDs und Styles werden immer als reiner Integer zurückgegeben, nicht als hexadezimale Zeichenketten.</p>
<p>ControlChoose akzeptiert 0, um das aktuelle Element/alle Elemente abzuwählen.</p>
<p>ControlGetTab gibt 0 zurück, wenn kein Tab ausgewählt ist (selten aber gültig).</p>
<p>WinGetList, WinGetControls und WinGetControlsHwnd geben Arrays zurück, keine via Zeilenumbruchszeichen getrennte Liste.</p>
<p>Abkürzungen wie Topmost, Trans, FS und Cap wurden entfernt. Benutze den vollen Funktionsnamen oder schreibe deine eigene Wrapperfunktion mit dem Namen deiner Wahl.</p>
<p>Ruft man eine WinSet-Funktion mithilfe der Funktionssyntax auf, wird sie bei Erfolg eine 1 und bei Misserfolg eine 0 zurückgeben, während ErrorLevel bei Erfolg auf 0 und bei Misserfolg auf 1 gesetzt wird. Allerdings setzen einige der anderen Funktionen nur ErrorLevel.</p>
<p>Die folgenden Funktionen waren ehemals Unterbefehle von SysGet:</p>
<pre><code>Vorhanden := MonitorGet([N, Links, Oben, Rechts, Unten])
Vorhanden := MonitorGetWorkArea([N, Links, Oben, Rechts, Unten])
Anzahl    := MonitorGetCount()
Primär    := MonitorGetPrimary()
Name      := MonitorGetName([N])
</code></pre>
<h3>Neue Befehle/Funktionen</h3>
<p><code>BufferAlloc(Größe)</code> erzeugt und gibt einen <code>Buffer</code>-Objekt zurück, für das ein Speicherblock in <em>Größe</em> Bytes reserviert ist, der zunächst mit Nullen gefüllt ist. <code>Buffer.Ptr</code> ermittelt die Adresse und <code>Buffer.Size</code> ermittelt oder setzt die Größe in Bytes (inklusive Neureservierung des Speicherblocks). Es kann ein beliebiges Objekt mit den Eigenschaften Ptr und Size an <code>NumPut</code>, <code>NumGet</code>, <code>StrPut</code>, <code>StrGet</code>, <code>File.RawRead</code>, <code>File.RawWrite</code> und <code>FileAppend</code> übergeben werden. Es kann ein beliebiges Objekt mit einer Ptr-Eigenschaft an <code>SendMessage</code>, <code>PostMessage</code>, und <code>DllCall</code>-Parametern vom Typ Ptr übergeben werden.</p>
<p><code>CaretGetPos([X, Y])</code> ermittelt die aktuellen Koordinaten des Text-Cursors. Dadurch wird sichergestellt, dass die X- und Y-Koordinaten immer übereinstimmen und dass es kein Caching gibt, das zu unerwartetem Verhalten führt (wenn A_CaretX/Y beispielsweise einen Wert zurückgibt, der nicht im aktuellen CoordMode liegt).</p>
<p><code>ClipboardAll([Daten, Größe])</code> erstellt ein Objekt, das alles, was in der Zwischenablage ist, enthält (und akzeptiert optional Daten, die vorher aus der Zwischenablage abgerufen wurden, anstatt den aktuellen Inhalt der Zwischenablage zu verwenden). Die Methoden zum Lesen und Schreiben von Dateidaten der Zwischenablage sind unterschiedlich. Das Datenformat ist das gleiche, außer dass die Datengröße immer 32-Bit ist, so dass die Daten zwischen 32-Bit- und 64-Bit-Builds portierbar sind. Weitere Informationen sind in der v2-Dokumentation zu finden.</p>
<p>ControlGetClassNN gibt die ClassNN eines bestimmten Steuerelements zurück.</p>
<p>ControlSendText, das das Äquivalent zu ControlSendRaw ist, aber den {Text}- statt {Raw}-Modus verwendet.</p>
<p><code>DirExist(Pfad)</code>, so ähnlich wie FileExist. Beachte, dass <code>InStr(FileExist(Muster), "D")</code> nur mitteilt, ob die <em>zuerst</em> gefundene Datei ein Ordner ist, nicht ob ein Ordner existiert.</p>
<p><code>Float(v)</code>: siehe Typen.</p>
<p><code>Integer(v)</code>: siehe Typen.</p>
<p><code>MenuCreate()</code>/<code>MenuBarCreate()</code> gibt ein neues Menu/MenuBar-Objekt zurück, das folgende Elemente, die den Unterbefehlen von v1-Menu entsprechen, enthält. Methoden: Add, <strong>Add</strong>Standard, Check, Delete, Disable, Enable, Insert, Rename, <strong>Set</strong>Color, <strong>Set</strong>Icon, Show, ToggleCheck, ToggleEnable, Uncheck. Eigenschaften: Click<strong>Count</strong>, Default, Handle (ersetzt MenuGetHandle). <code>A_TrayMenu</code> gibt auch ein Menu-Objekt zurück. Es gibt keinen UseErrorLevel-Modus, keine globalen Menünamen, und kein explizites Löschen des Menüs selbst (dies geschieht, wenn alle Verweise freigegeben sind; Menu.Delete() entspricht dem v1-DeleteAll). Labels werden nicht unterstützt, nur Funktionen und Objekte. Menu.AddStandard() fügt die vordefinierten Menüpunkte hinzu und ermöglicht, dass sie wie benutzerdefinierte Menüpunkte individuell geändert werden können. Im Gegensatz zu v1 wird das Win32-Menü nur zerstört, wenn das Objekt gelöscht wird.</p>
<p><code>MenuFromHandle(Handle)</code> gibt das Menu-Objekt eines dazugehörigen Win32-Menü-Handles zurück, wenn es von AutoHotkey erstellt wurde.</p>
<p><code>RegDeleteKey("Rootkey\Subkey")</code> löscht einen Registry-Key. (RegDelete löscht jetzt nur noch Werte, außer wenn alle Parameter in einer Registry-Schleife weggelassen werden.)</p>
<p>SendText, das das Äquivalent zu SendRaw ist, aber den {Text}- statt {Raw}-Modus verwendet.</p>
<p><code>StrCompare(Zkette1, Zkette2 [, GroßKleinSensitiv := false])</code> gibt -1 (Zkette1 kleiner als Zkette2), 0 (gleich) oder 1 (größer als) zurück.</p>
<p><code>String(v)</code>: siehe Typen.</p>
<p><code>SysGetIPAddresses()</code> Gibt ein Array mit IP-Adressen zurück, was das Äquivalent zu den entfernten A_IPAddress-Variablen ist. Jede Referenz auf <code>A_IPAddress%N%</code> rief alle Adressen ab, aber gab nur eine zurück, so dass das Abrufen mehrerer Adressen exponentiell länger als nötig dauerte. Das zurückgegebene Array kann keine oder mehr Elemente enthalten.</p>
<p><code>TraySetIcon([Dateiname, Symbolnummer, Einfrieren])</code> ersetzt <code>Menu Tray, Icon</code>.</p>
<p><code>WinGetClientPos([X, Y, W, H, Fenstertitel, ...])</code> ermittelt die Position und Größe des Clientbereichs eines Fensters, in Bildschirmkoordinaten.</p>
<h3>Interne Variablen</h3>
<p>A_OSVersion wird immer eine Zeichenkette im Format <code>Haupt.Neben.Build</code> zurückgeben, wie z. B. <code>6.1.7601</code> für Windows 7 SP1. A_OSType wurde entfernt, da nur NT-basierte Systeme unterstützt wurden.</p>
<p>Umbenannt:</p>
<ul>
<li>A_LoopFileFullPath -&gt; A_LoopFilePath (gibt einen relativen Pfad zurück, wenn Loop's Parameter relativ ist, daher ist "FullPath" irreführend)</li>
<li>A_LoopFileLongPath -&gt; A_LoopFileFullPath</li>
<li>ComSpec -&gt; A_ComSpec</li>
</ul>
<p>Entfernt:</p>
<ul>
<li>ClipboardAll (ersetzt durch die ClipboardAll-Funktion)</li>
<li>ProgramFiles (benutze A_ProgramFiles)</li>
<li>A_AutoTrim</li>
<li>A_BatchLines</li>
<li>A_CaretX, A_CaretY (benutze CaretGetPos)</li>
<li>A_DefaultGui, A_DefaultListView, A_DefaultTreeView</li>
<li>A_ExitReason</li>
<li>A_FormatFloat</li>
<li>A_FormatInteger</li>
<li>A_Gui, A_GuiControl, A_GuiControlEvent, A_GuiEvent, A_GuiX, A_GuiY, A_GuiWidth, A_GuiHeight (alle ersetzt durch Parameter von Ereignis-Handlern)</li>
<li>A_IPAddress1, A_IPAddress2, A_IPAddress3, A_IPAddress4 (benutze SysGetIPAddresses)</li>
<li>A_ThisMenu (benutze eine Funktion mit Parametern anstelle eines Labels für die Menüpunkt-Callback-Funktion)</li>
<li>A_ThisMenuItem</li>
<li>A_ThisMenuItemPos</li>
<li>A_LoopRegSubKey (A_LoopRegKey enthält nun den Rootkey und Subkey)</li>
</ul>
<p>Hinzugefügt:</p>
<ul>
<li>A_AllowMainWindow (Lesen/Schreiben; ersetzt <code>Menu Tray, MainWindow/NoMainWindow</code>)</li>
<li>A_InitialWorkingDir (siehe <a href="#default-settings">Standardeinstellungen</a>)</li>
</ul>
<p>In folgenden internen Variablen können Werte gespeichert werden:</p>
<ul>
<li>A_ControlDelay</li>
<li>A_CoordMode..</li>
<li>A_DefaultMouseSpeed</li>
<li>A_DetectHiddenText (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li>A_DetectHiddenWindows (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li>A_EventInfo</li>
<li>A_FileEncoding (diese Variable gibt nun "CP0" anstelle von "" zurück, außerdem kann ihr ein Integer ohne CP-Präfix zugewiesen werden)</li>
<li>A_IconHidden</li>
<li>A_IconTip (Außerdem spiegelt es nun immer das ToolTip wider, auch wenn es Standard oder leer ist)</li>
<li>A_Index: Bei endlichen Schleifen wird ein hier gespeicherter Wert die Anzahl der Durchläufe beeinflusst. (Die globale Ausrichtung der internen Variablen hat zur Folge, dass die Next-Methode eines Enumerators den Index setzen könnte, der von einer For-Schleife gesehen wird.)</li>
<li>A_KeyDelay</li>
<li>A_KeyDelayPlay</li>
<li>A_KeyDuration</li>
<li>A_KeyDurationPlay</li>
<li>A_LastError: Ruft die Win32-SetLastError()-Funktion auf. Zudem gibt diese interne Variable nun einen vorzeichenlosen Wert zurück.</li>
<li>A_ListLines</li>
<li>A_MouseDelay</li>
<li>A_MouseDelayPlay</li>
<li>A_RegView</li>
<li>A_ScriptName: Ändert den Standard-Dialogfenster-Titel.</li>
<li>A_SendLevel</li>
<li>A_SendMode</li>
<li>A_StoreCapslockMode (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li>A_StringCaseSense</li>
<li>A_TitleMatchMode</li>
<li>A_TitleMatchModeSpeed</li>
<li>A_WinDelay</li>
<li>A_WorkingDir: Das gleiche wie, als würde man SetWorkingDir aufrufen.</li>
</ul>
<h3>Interne Objekte</h3>
<p>File-Objekte benötigen nun zwingend die Eigenschaftssyntax zum Aufrufen von Eigenschaften und die Methodensyntax zum Aufrufen von Methoden. Zum Beispiel ist <code>File.Pos(n)</code> ungültig. Es wird eine Ausnahme ausgelöst, wenn zu wenige oder zu viele Parameter vorhanden sind oder wenn eine schreibgeschützte Eigenschaft einen Wert zugewiesen bekommt.</p>
<p><code>File.Tell()</code> wurde entfernt.</p>
<p><code>Func.IsByRef()</code> funktioniert nun mit internen Funktionen.</p>
<h2>Gui</h2>
<p>Gui, GuiControl und GuiControlGet wurden durch GuiCreate() und Gui/GuiControl-Objekte ersetzt, die in der Regel flexibler, konsistenter und wohl leichter zu bedienen sind.</p>
<p>Einzelheiten zur Nutzung sind in der neuen v2-Dokumentation zu finden.</p>
<p>Eine GUI wird normalerweise nicht via Name/Nummer angesteuert (allerdings kann sie weiterhin mit der Eigenschaft Gui.Name benannt werden). Stattdessen wird ein GUI-Objekt (und Fenster) durch den expliziten Aufruf von GuiCreate() erstellt, das ein Gui-Objekt zurückgibt. Dieses Objekt hat Methoden und Eigenschaften, die die Gui-Unterbefehle ersetzen. Gui.Add() gibt ein GuiControl-Objekt zurück, das über Methoden und Eigenschaften verfügt, die die GuiControl- und GuiControlGet-Befehle ersetzen. Man kann dieses Objekt in einer Variablen speichern, oder <code>Gui.Control["Name"]</code> oder <code>GuiCtrlFromHwnd(hwnd)</code> benutzen, um das Objekt abzurufen. Es wird auch als Parameter übergeben, wenn ein Event-Handler (der Ersatz für ein g-Label) aufgerufen wird.</p>
<p>Die Verwendung dieser Methoden und Eigenschaften ist nicht 1:1. Viele Teile wurden überarbeitet, um konsistenter und flexibler zu sein und um Fehler oder Einschränkungen zu beheben.</p>
<p>Es gibt keine Standard-GUIs, da das zu bearbeitende Gui- oder GuiControl-Objekt immer angegeben ist. LV/TV/SB-Funktionen wurden durch Methoden (des GuiControl-Objekts) ersetzt, so dass es viel einfacher ist, mehrere ListViews/TreeViews zu verwenden.</p>
<p>Es gibt keine internen Variablen, die Informationen über Ereignisse enthalten. Die Informationen werden als Parameter an eine Funktion/Methode übergeben, die das Ereignis behandelt, einschließlich das zu bearbeitende Gui oder Steuerelement.</p>
<p>Steuerelement können weiterhin benannt und via Name angesteuert werden. Allerdings ist das nur ein Name (benutzbar mit <code>Gui.Control["Name"]</code> und <code>Gui.Submit()</code>), nicht eine zugewiesene Variable, daher müssen keine globalen oder statischen Variablen deklariert oder erstellt werden. Der Wert wird niemals automatisch in eine Variable gespeichert, aber er ist via <code>GuiCtrl.Value</code> abrufbar. <code>Gui.Submit()</code> gibt ein neues assoziatives Array zurück, das die Namen der Steuerelemente als Keys benutzt.</p>
<p>Die v<em>Name</em>-Option setzt nun nur noch den Namen des Steuerelements auf <em>Name</em>.</p>
<p>Die +Hwnd<em>VarName</em>-Option wurde zugunsten von <code>GuiCtrl.Hwnd</code> entfernt.</p>
<p>Es gibt keine "g-Labels" oder Labels/Funktionen mehr, die automatisch GUI-Ereignisse behandeln. Das Skript muss jedes gewünschte Ereignis registrieren, indem es die OnEvent-Methode des Gui oder GuiControl aufruft. Zum Beispiel, anstatt in einem g-Label zu überprüfen <code>if (A_GuiEvent = "I" &amp;&amp; InStr(ErrorLevel, "F", true))</code>, würde das Skript einen Handler für das <code>ItemFocus</code>-Ereignis registrieren: <code>MeineLV.OnEvent("ItemFocus", "MeineFunktion")</code>. <em>MeineFunktion</em> würde nur bei dem ItemFocus-Ereignis aufgerufen werden. Es ist nicht erforderlich, <code>AltSubmit</code> anzuwenden, um zusätzliche Ereignisse zu ermöglichen.</p>
<p>In der Regel können Arrays anstelle einer Zeichenkettenliste (mit dem aktuellen Gui-Trennzeichen via <code>Gui +Delimiter</code>) benutzt werden. Die Zeichenkettenliste wird immer noch unterstützt, aber nie an das Skript zurückgegeben (z. B. würde eine Mehrfachauswahl-ListBox ein <em>Array</em> mit ausgewählten Elementen zurückgeben).</p>
<h3>Gui-Unterbefehle</h3>
<p><strong>Gui New</strong> → GuiCreate(). Eine leere Zeichenkette als Titel führt dazu, dass das Gui nicht den Standardtitel, sondern einen leeren Titel bekommen wird.</p>
<p><strong>Gui Add</strong> → Gui.Add() oder Gui.Add<em>Steuerelement</em>(); z. B. Gui.Add("Edit") oder Gui.AddEdit().</p>
<p><strong>Gui Show</strong> → Gui.Show(), aber ohne Titel-Parameter. Der Titel kann via GuiCreate()-Parameter oder via Gui.Title angegeben werden.</p>
<p><strong>Gui Submit</strong> → Gui.Submit(). Funktioniert wie zuvor, außer dass Submit() ein neues Objekt erstellt und zurückgibt, das alle "zugewiesenen Variablen" enthält.</p>
<p><strong>Gui Destroy</strong> → Gui.Destroy(). Das Objekt existiert weiterhin (bis es vom Skript freigegeben wird), kann aber nicht verwendet werden. Es muss eine neue GUI erstellt werden (falls erforderlich). Das Fenster wird auch zerstört, wenn das Objekt gelöscht wird, aber das Objekt wird "am Leben gehalten", während das Fenster sichtbar ist.</p>
<p><strong>Gui Font</strong> → Gui.SetFont(). Mit GuiCtrl.SetFont() ist es auch möglich, die Schriftart eines Steuerelements direkt zu setzen.</p>
<p><strong>Gui Color</strong> → Gui.BackColor setzt/ermittelt die Hintergrundfarbe. Steuerelementfarbe (der zweite Parameter) wird nicht unterstützt, aber bei allen Steuerelementen, die diesen Parameter zuvor unterstützten, kann der Hintergrund via <code>+Background</code>-Option geändert werden. Im Gegensatz zu "Gui Color" hat Gui.BackColor keinen Einfluss auf Progress-Steuerelemente oder deaktivierte/ schreibgeschützte Edit-, DDL-, ComboBox- oder TreeView-Steuerelemente (mit -Theme).</p>
<p><strong>Gui Margin</strong> → Gui.MarginX- und Gui.MarginY-Eigenschaft.</p>
<p><strong>Gui Menu</strong> → Gui.MenuBar setzt oder gibt ein MenuBar-Objekt, das mit <code>MenuBarCreate()</code> erstellt wurde, zurück.</p>
<p><strong>Gui Cancel/Hide/Minimize/Maximize/Restore</strong> → gleichnamige Gui-Methoden.</p>
<p><strong>Gui Flash</strong> → Gui.Flash(), aber benutze <code>false</code> statt <code>Off</code>.</p>
<p><strong>Gui Tab</strong> → TabSteuerelement.UseTab(). Wie zuvor stimmt es standardmäßig mit einem Präfix des Tabnamens überein. Übergebe True im zweiten Parameter, um eine Übereinstimmung mit dem gesamten Tabnamen zu aktivieren, aber im Gegensatz zum "Exakt"-Modus aus v1 ist sie unabhängig von Groß-/Kleinschreibung.</p>
<h3>Ereignisse</h3>
<p>Das Size-Ereignis übergibt 0,-1 oder 1 (um konsistent mit WinGetMinmax zu sein) statt 0, 1 oder 2.</p>
<p>Das ContextMenu-Ereignis kann für jedes Steuerelement oder für das ganze GUI registriert werden.</p>
<p>Das DropFiles-Ereignis tauscht die Parameter DateiArray und Ctrl, um konsistent mit ContextMenu zu sein.</p>
<p>Die Ereignisse ContextMenu und DropFiles verwenden Clientkoordinaten statt Fensterkoordinaten (Client ist auch die CoordMode-Standardeinstellung in v2).</p>
<p>Die folgenden steuerelement-spezifischen Ereignisse wurden zwar entfernt, aber sie können weiterhin mithilfe von GuiCtrl.OnNotify() und einem geeigneten numerischen Benachrichtigungscode (definiert im Windows SDK) erkannt werden: K, D, d, A, S, s, M, C, E und MonthCal's 1 und 2.</p>
<p>Alle unterstützten Ereignisse haben einen Namen, keine Buchstaben/Zahlen. Weitere Informationen sind in der v2-Dokumentation zu finden.</p>
<p>Steuerelement-spezifische Ereignisse übergeben den Ereignisnamen nicht als Parameter (GUI-Ereignisse taten dies nie).</p>
<p>Custom's N- und Normal-Ereignisse wurden ersetzt mit GuiCtrl.OnNotify() und GuiCtrl.OnCommand(), die bei allen Steuerelementen benutzt werden können.</p>
<p>Link's Click-Ereignis übergibt (Ctrl, ID oder Index, HREF) statt (Ctrl, Index, HREF oder ID), und wird HREF nicht automatisch ausführen, wenn ein Click-Callback registriert ist.</p>
<p>ListView's Click-, DoubleClick- und ContextMenu-Ereignisse (ausgelöst durch Rechtsklick) geben nun das Element zurück, welches angeklickt wurde (oder 0, wenn nicht), anstatt das fokussierte Element.</p>
<p>ListView's I-Ereignis wurde in mehrere benannte Ereignisse aufgeteilt. Das f-Ereignis (Fokus verloren) wurde ausgeschlossen, weil es nun via F (ItemFocus) repräsentiert wird.</p>
<p>ListView's e-Ereignis (ItemEdit) wird ignoriert, wenn der Benutzer das Editieren abbricht.</p>
<p>Slider's Change-Ereignis wird konsistenter ausgelöst als das g-Label von v1; das heißt, dass es standardmäßig keine Änderungen via Mausrad mehr ignoriert. Lies die Dokumentation für Details.</p>
<p>Der BS_NOTIFY-Style wird nun automatisch je nach Bedarf bei Button-, CheckBox- und Radio-Steuerelementen hinzugefügt. Dieser Style wird nicht mehr standardmäßig auf Radio-Steuerelementen angewendet.</p>
<p>Focus (früher F) und LoseFocus (früher f) werden von mehreren (aber nicht von allen) Steuerelementtypen unterstützt.</p>
<p>Wenn man den Text eines Edit-Steuerelements mithilfe von Edit.Value oder Edit.Text setzt, wird das Change-Ereignis des Steuerelements nicht ausgelöst, während GuiControl das g-Label des Steuerelements auslösen würde.</p>
<p>LV/TV.Add/Modify unterdrücken jetzt element-verändernde Ereignisse, so dass solche Ereignisse nur durch Benutzeraktion oder SendMessage ausgelöst werden können.</p>
<h3>Entfernt</h3>
<p>+Hwnd<em>AusgabeVar</em> → Gui.Hwnd oder GuiCtrl.Hwnd<br />

+Label<br />

+LastFoundExist<br />

Gui GuiName: Default</p>
<h3>Steuerelement-Optionen</h3>
<p>+/-Background wird konsistenter interpretiert und unterstützt. Alle Steuerelemente, die <code>Gui Color</code> unterstützt haben, unterstützen jetzt +Background<em>Farbe</em> und +BackgroundDefault (Synonym zu -Background), nicht nur ListView/TreeView/StatusBar/Progress.</p>
<p><code>Gui.Add</code> nutzt standardmäßig <code>y+m</code>/<code>x+m</code> anstatt <code>yp</code>/<code>xp</code>, wenn <code>xp</code>/<code>yp</code> oder <code>xp+0</code>/<code>yp+0</code> verwendet wird. Sprich, das Steuerelement wird unterhalb/auf der rechten Seite des vorherigen Steuerelements platziert, anstatt auf genau derselben Position. Wenn ein Offset ungleich Null verwendet wird, ist das Verhalten das gleiche wie in v1. Um genau dieselbe Position zu nutzen, gibt man gleichzeitig <code>xp yp</code> an.</p>
<p>Nach <code>x+m</code> und <code>y+m</code> kann optional ein zusätzlicher Offset erfolgen, wie z. B. <code>x+m+10</code> (<code>x+m10</code> wäre auch gültig, aber schlechter lesbar).</p>
<h3>GuiControlGet</h3>
<h4>Leerer Unterbefehl</h4>
<p>GuiControlGet's leerer Unterbefehl hatte zwei Modi: Standardmodus, und Textmodus, wo der vierte Parameter das Wort <code>Text</code> war. Wenn ein Steuerelementtyp keinen einzigen "Wert" hatte, gab GuiControlGet standardmäßig das Ergebnis von <a href="https://msdn.microsoft.com/library/ms633520">GetWindowText</a> zurück (das nicht immer sichtbarer Text ist). Einige Steuerelemente hatten keinen sichtbaren Text oder unterstützten dessen Abruf nicht, folglich ignorierten sie den vierten Parameter. Im Gegensatz dazu gibt GuiCtrl.Text den Anzeigetext, versteckten Text (den gleichen Text, der von ControlGetText zurückgegeben wird) oder überhaupt nichts zurück.</p>
<p>Die folgende Tabelle zeigt das nächstmögliche Äquivalent (Eigenschaft oder Funktion) zu jedem Modus von GuiControlGet und den dazugehörigen Steuerelementtyp.</p>
<table class="info">
<tr><th>Steuerelement</th><th>Standard</th><th>Text</th><th>Hinweise</th></tr>
<tr><td>ActiveX</td><td>.Value</td><td>.Text</td><td>Text ist versteckt. Siehe unten.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Text</td><td>ControlGetText()</td><td>Benutze Value anstelle von Text, wenn AltSubmit benutzt wurde (aber Value gibt 0 zurück, wenn Text mit keinem Listenelement übereinstimmt). Text führt eine Korrektur der Groß-/Kleinschreibung durch, während ControlGetText den Inhalt des Eingabefeldes zurückgibt.</td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Text</td><td>Benutze Value anstelle von Text, wenn AltSubmit benutzt wurde.</td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td>.Text</td><td>ControlGetText()</td><td>Benutze Value anstelle von Text, wenn AltSubmit benutzt wurde. Text gibt den Text des ausgewählten Elements zurück, während ControlGetText den versteckten Text zurückgibt. Siehe unten.</td></tr>
<tr><td>ListView</td><td colspan="2">.Text</td><td>Text ist versteckt.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Tab</td><td>.Text</td><td>ControlGetText()</td><td>Benutze Value anstelle von Text, wenn AltSubmit benutzt wurde. Text gibt den Text des ausgewählten Tabs zurück, während ControlGetText den versteckten Text zurückgibt.</td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">.Text</td><td>Text ist versteckt.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td></td></tr>
</table>
<p>ListBox: Bei einer Mehrfachauswahl-ListBox gibt Text und Value ein Array zurück, anstelle einer Liste, deren Elemente mit senkrechten Strichen getrennt sind.</p>
<p>ActiveX: GuiCtrl.Value gibt jedes Mal das gleiche Objekt zurück, während GuiControlGet jedes Mal ein neues Wrapperobjekt erstellt. Demzufolge ist es nicht mehr erforderlich, einen Verweis auf ein ActiveX-Objekt beizubehalten, um eine ComObjConnect-Verbindung aufrecht zu erhalten.</p>
<h4>Andere Unterbefehle</h4>
<p><strong>Pos</strong> → GuiCtrl.Pos; gibt ein assoziatives Array statt Pseudo-Array zurück.</p>
<p><strong>Focus</strong> → Gui.FocusedCtrl; gibt ein GuiControl-Objekt statt ClassNN zurück.</p>
<p><strong>FocusV</strong> → Gui.FocusedCtrl.Name</p>
<p><strong>Hwnd</strong> → GuiCtrl.Hwnd; gibt einen reinen Integer zurück, nicht eine hexadezimale Zeichenkette.</p>
<p><strong>Enabled/Visible/Name</strong> → gleichnamige GuiCtrl-Eigenschaften.</p>
<h3>GuiControl</h3>
<h4>(Leer) und Text-Unterbefehle</h4>
<p>Die folgende Tabelle zeigt das nächstmögliche Äquivalent (Eigenschaft oder Funktion) zu jedem Modus von GuiControl und den dazugehörigen Steuerelementtyp.</p>
<table class="info">
<tr><th>Steuerelement</th><th>(Leer)</th><th>Text</th><th>Hinweise</th></tr>
<tr><td>ActiveX</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Delete/Add/Choose</td><td>.Text</td><td></td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td>.Value</td><td>.SetFormat()</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>ListView</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td>Benutze den <code>+=</code>-Operator anstelle des <code>+</code>-Präfixes.</td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td>Benutze den <code>+=</code>-Operator anstelle des <code>+</code>-Präfixes.</td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text oder SB.SetText()</td><td></td></tr>
<tr><td>Tab</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td>Benutze den <code>+=</code>-Operator anstelle des <code>+</code>-Präfixes.</td></tr>
</table>
<h4>Andere Unterbefehle</h4>
<p><strong>Move</strong> → GuiCtrl.Move(...)</p>
<p><strong>MoveDraw</strong> → GuiCtrl.Move(..., true)</p>
<p><strong>Focus</strong> → GuiCtrl.Focus()</p>
<p><strong>Enable/Disable</strong> → set GuiCtrl.Enabled</p>
<p><strong>Hide/Show</strong> → set GuiCtrl.Visible</p>
<p><strong>Choose</strong> → GuiCtrl.Choose(n), wo n ein reiner Integer ist. Der <code>|n</code>- oder <code>||n</code>-Modus wird nicht unterstützt (benutze stattdessen ControlChoose, wenn nötig).</p>
<p><strong>ChooseString</strong> → GuiCtrl.Choose(s), wo s kein reiner Integer ist. Der <code>|n</code>- oder <code>||n</code>-Modus wird nicht unterstützt Wenn die Zeichenkette mit mehreren Elementen aus einer Mehrfachauswahl-ListBox übereinstimmt, wird Choose() sie alle auswählen, nicht nur das Erste.</p>
<p><strong>Font</strong> → GuiCtrl.SetFont()</p>
<p><strong>+/-Option</strong> → GuiCtrl.Opt("+/-Option")</p>
<h3>Sonstige Änderungen</h3>
<p>Progress-Gui-Steuerelemente haben nicht länger standardmäßig den PBS_SMOOTH-Style aktiv; das heißt, dass sich ihr Style jetzt nach dem Style des Systems richtet (Luna in XP oder Aero in Vista/7).</p>
<p>Die Standardabstände und Steuerelementgrößen (insbesondere bei Button-Steuerelementen) können leicht von v1 abweichen, wenn DPI &gt; 100% ist.</p>
<h2>Fehlerbehandlung</h2>
<h3>Ausdrücke (Expressions)</h3>
<p>Es wird ein Ladezeitfehler bei mehr Fehlern als in v1 ausgelöst, wie z. B.:</p>
<ul>
<li>Leere runde Klammern (außer neben einem Funktionsnamen); z. B. <code>x ()</code></li>
<li>Ein Präfixoperator, der auf der falschen Seite benutzt wird oder dem ein Operand fehlt; z. B. <code>x!</code></li>
<li>Binäroperator mit weniger als zwei Operanden.</li>
<li>Ternäroperator mit weniger als drei Operanden.</li>
<li>Das Ziel einer Zuweisung ist keine beschreibbare Variable, Objekteigeschaft oder Teilausdruck in runden Klammern (wie z. B. <code>(WelcheVar ? x : y)</code>).</li>
</ul>
<p>Eine Ausnahme wird ausgelöst, wenn einer der folgenden Fehler auftritt (anstatt den Fehler zu ignorieren oder eine leere Zeichenkette zu erzeugen):</p>
<ul>
<li>Wenn man versucht, eine Berechnung mit einem nicht-numerischen Wert durchzuführen. (Numerische Zeichenketten sind in Ordnung.)</li>
<li>Division durch Null oder andere ungültig/nicht-unterstützte Eingaben wie z. B. <code>(-1)**1.5</code>. Beachten Sie, dass einige Fälle neuerdings als ungültig erkannt werden, wie z. B.: <code>0**0</code>; <code>a&lt;&lt;b</code> oder <code>a&gt;&gt;b</code>, dessen <code>b</code> außerhalb des Bereichs 0 bis 63 liegt.</li>
<li>Fehler beim Reservieren von Speicher für den Rückgabewert einer internen Funktion, für eine Verkettung oder für das Ergebnis eines Ausdrucks.</li>
<li>Stapelunterlauf (üblicherweise durch einen Syntaxfehler ausgelöst).</li>
<li>Versuchte Zuweisung zu etwas, das keine Variable (oder kein Array-Element) ist.</li>
<li>Versuchte Zuweisung zu einer schreibgeschützten Variable.</li>
<li>Versuchte Doppeldereferenzierung mit einem leeren Namen, wie z. B. <code>fn(%leer%)</code>.</li>
<li>Fehler beim Ausführen eines dynamischen Funktions- oder Methodenaufrufs.</li>
<li><code>x[y,z]</code> schlägt fehl, weil <code>x[y]</code> einen Nicht-Objekt-Wert enthält.</li>
<li>Ein Aufruf schlägt fehl, weil das Ziel kein Objekt ist, oder die Methode/Eigenschaft ist nicht behandelt. Bei assoziativen Arrays kann nur ein Methodenaufruf diesen Fehler verursachen.</li>
<li>Eine Objektzuweisung schlägt fehl, weil ein Fehler bei der Speicherreservierung aufgetreten ist.</li>
<li>Wahrscheinlich unmöglich: Es wurde versucht, Speicher für mehr als 200 temporäre Zeichenketten oder Objektverweise zu reservieren (<em>höchstens</em> eine Speicherreservierung pro Funktionsaufruf, Objektoperator, Verkettung oder Ausdrucksergebnis). Dies gilt nicht für alle Speicherreservierungen. In v1 lag das Limitieren solcher Zeichenketten bei 100 (Objektverweise zählten nicht dazu).</li>
</ul>
<p>Einige der Bedingungen oben werden in v1 erkannt, aber nicht mitten in einem Ausdruck; zum Beispiel wird <code>A_AhkPath := x</code> in v1 erkannt, während <code>y := x, A_AhkPath := x</code> nur in v2 erkannt werden kann.</p>
<p>Die Operatoren <code>+=</code>, <code>-=</code>, <code>--</code> und <code>++</code> behandeln eine leere Variable wie 0 (bei <code>+=</code> und <code>-=</code> gilt das nur für die linke Seite). In v1 traf das nur zu, wenn der Operator alleinstehend war, und nicht, wenn er mitten in einem Ausdruck oder in Verbindung mit dem Mehrfachanweisungskomma benutzt wurde.</p>
<h3>Funktionen</h3>
<p>Funktionen (auch solche, die früher als Befehle bekannt waren) benutzen in der Regel ErrorLevel, um einen Fehler zu melden, und lösen manchmal eine Ausnahme aus (z. B. bei ungültigen Parametern). Dieses Verhalten ist mit v1 vergleichbar, allerdings wurden einige Änderungen durchgeführt. Das Umschließen von Funktionen mit einem Try-Block hat keine Auswirkung mehr auf dieses Verhalten, um so das Verhalten vorhersagbarer zu machen.</p>
<p>Interne Funktionen lösen eine Ausnahme aus, wenn ungültige Parameter erkannt werden (aber nicht alle ungültigen Parameter werden erkannt), oder wenn eine Speicherreservierung fehlschlägt.</p>
<p>DllCall lösen Ausnahmen aus, anstatt ErrorLevel zu setzen.</p>
<p>RegExMatch und RegExReplace setzen nie ErrorLevel, stattdessen lösen sie eine Ausnahme aus, wenn ein Fehler auftritt. Inklusive Syntaxfehler im RegEx-Muster und PCRE-Ausführungsfehler.</p>
<p>Mathematische Funktionen lösen eine Ausnahme aus, wenn einer ihrer Eingabewerte nicht-numerisch ist, oder wenn die Operation ungültig ist (z. B. Division durch Null).</p>
<h2>Sonstiges</h2>
<p>Befehlszeilenparameter werden in ein Array gespeichert, das in der superglobalen Variable <code>A_Args</code> zu finden ist, anstatt in einem Pseudo-Array durchnummerierter globalen Variablen. Wenn keine Parameter an das Skript übergeben wurden, wird <code>A_Args</code> ein leeres Array enthalten. Der Ausdruck <code>A_Args.Length()</code> gibt die Anzahl der Parameter zurück, während <code>A_Args[1]</code> den ersten Parameter zurückgibt.</p>
<p>Mausrad-Hotkeys setzen A_EventInfo auf den gemeldeten Delta-Wert vom Maustreiber, anstatt diesen Wert durch 120 zu teilen. In der Regel ist das ein mit 120 multiplizierter Wert, aber einige Maustreiber können eine Mausraddrehung in höherer Auflösung melden.</p>
<p>In ErrorLevel kann ein Objekt gespeichert werden, ohne befürchten zu müssen, dass es verloren geht, wenn der Thread unterbrochen werden sollte. In v1 wurde das ErrorLevel vom vorherigen Thread als Zeichenkette zwischengespeichert, wenn ein neuer Thread startete, und dann wiederhergestellt, wenn der neue Thread terminiert wurde.</p>
<p>ErrorLevel wird bei jedem neuen Thread auf 0 zurückgesetzt. In v1 wurde der ErrorLevel-Wert vom vorherigen Thread zwischengespeichert, der dann wieder in ErrorLevel gespeichert wurde, wenn der neue Thread fertig war.</p>
<p>Threads beginnen mit einem unterbrechungsfreien Timeout von 17ms statt 15ms. 15 war zu niedrig, da der system-interne Taktzähler in Schritten von mindestens 15 oder 16 aktualisiert wurde; das heißt, wenn der Taktzähler genau zum falschen Zeitpunkt aktualisiert wurde, konnte der Thread unterbrechbar werden, obwohl praktisch keine Zeit vergangen war.</p>
<p>Threads, die unterbrechungsfrei beginnen, bleiben nun so lange bestehen, bis mindestens eine Zeile ausgeführt wurde, auch dann, wenn der unterbrechungsfreie Timeout zuerst abläuft (z. B. wenn das System den Prozess unmittelbar nach dem Start des Threads sperrt, um einem anderen Prozess CPU-Zeit zu geben).</p>
<p>MaxThreads und #MaxThreadsPerHotkey machen keine Ausnahmen mehr für Subroutinen, deren erste Zeile einer der folgenden Befehle ist: ExitApp, Pause, Edit, Reload, KeyHistory, ListLines, ListVars oder ListHotkeys.</p>
<p>RegEx-Zeilenumbruchsübereinstimmung benutzt standardmäßig (*ANYCRLF) und (*BSR_ANYCRLF); `r und `n werden zusammen mit `r`n erkannt. Die `a-Option aktiviert bedingungslos (*BSR_UNICODE).</p>
<p>RegEx-Callout-Funktionen können nun variadisch sein.</p>
<p>Skripte, die von der Standardeingabe (stdin) gelesen werden (z. B. mit <code>AutoHotkey.exe *</code>), fügen nicht mehr das ursprüngliche Arbeitsverzeichnis in <code>A_ScriptFullPath</code> oder in den Titel des Hauptfensters ein, aber es wird als <code>A_ScriptDir</code> und zum Finden des lokalen Lib-Ordners verwendet.</p>
<p>Hotstrings behandeln nun UMSCHALT+RÜCKTASTE wie RÜCKTASTE, anstatt es innerhalb des Hotstring-Zwischenspeichers in <code>`b</code> zu übersetzen.</p>
<p>Hotstrings verwenden nicht das letzte, sondern das erste Doppelpunktpaar (<code>::</code>) als Trennung, wenn mehrere Doppelpunktpaare vorhanden sind. Das heißt, dass Doppelpunkte (wenn sie an einen anderen Doppelpunkt angrenzen) mit einem Escapezeichen versehen werden müssen, um Text in v2 zu triggern, während sie in v1 im Ersatztext mit einem Escapezeichen versehen werden müssen. Beachten Sie, dass bei einer ungeraden Anzahl von aufeinanderfolgenden Doppelpunkten das bisherige Verhalten den letzten Doppelpunkt nicht als Teil eines Paares angesehen hatte. Zum Beispiel bleibt das Verhalten bei <code>::1:::2</code> (<code>1</code> → <code>:2</code>) unverändert, während sich <code>::3::::4</code> wie <code>3</code> → <code>::4</code> statt wie <code>3::</code> → <code>4</code> verhält.</p>
<p>Hotstrings escapen nicht länger Doppelpunktpaare, daher es nun möglich, einen einzelnen Doppelpunkt am Ende des Hotstring-Triggers zu escapen. Zum Beispiel ist <code>::5`:::6</code> nun <code>5:</code> → <code>6</code> statt eines Fehlers, und <code>::7`::::8</code> nun <code>7:</code> → <code>:8</code> statt <code>7::</code> → <code>8</code>. Am besten versieht man in solchen Fällen alle direkt geschriebenen Doppelpunkte mit einem Escapezeichen, um Verwirrung zu vermeiden (aber ein einzelner isolierter Doppelpunkt muss nicht escaped werden).</p>
<p>Hotstrings mit Fortsetzungsbereichen verwenden nun standardmäßig den Text- statt Raw-Modus.</p>
<p>Hotkeys maskieren die Win/Alt-Taste nur noch beim Loslassen, wenn sie logisch unten ist und der Hotkey die Win/Alt-Taste benötigt (mit <code>#</code>/<code>!</code> oder einem benutzerdefinierten Präfix). Das heißt, dass Hotkeys, die die Win/Alt-Taste nicht benötigen, Win/Alt-Up nicht mehr maskieren, wenn die Win/Alt-Taste physisch unten ist. Dadurch können Hotkeys, die <code>{Blind}{LWin up}</code> senden, das Startmenü aktivieren (was bei Verwendung einer neubelegten Taste wie <code>AppsKey::RWin</code> bereits möglich war).</p>
<h3>Persistenz</h3>
<p>Skripte sind "persistent", wenn mindestens eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>Mindestens ein Hotkey oder Hotstring wurde im Skript definiert.</li>
<li>Mindestens eine Nachrichtenüberwachung ist aktiv (von OnMessage gestartet).</li>
<li>Mindestens ein GUI ist sichtbar.</li>
<li>Mindestens ein Timer ist läuft gerade.</li>
<li>Mindestens eine OnClipboardChange-Callback-Funktion wurde gesetzt.</li>
<li>Mindestens ein InputHook ist aktiv.</li>
<li>Das Infobereichssymbol ist sichtbar und sein Menü hat benutzerdefinierte Menüpunkte.</li>
<li>#Persistent wurde genutzt.</li>
</ul>
<p>Wenn eines der folgenden Dinge eintritt und keine der oben genannten Bedingungen zutrifft, wird das Skript terminiert.</p>
<ul>
<li>Der letzte Skript-Thread endet.</li>
<li>Eine GUI wurde geschlossen oder zerstört.</li>
<li>Ein InputHook ohne OnEnd-Callback endet.</li>
</ul>
<p>v1-Skripte sind hingegen "persistent", wenn mindestens eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>Mindestens ein Hotkey oder Hotstring wurde im Skript definiert.</li>
<li>Gui oder OnMessage() kommt irgendwo im Skript vor.</li>
<li>Der Tastatur- oder Maus-Hook ist installiert.</li>
<li>Input wurde aufgerufen.</li>
<li>#Persistent wurde genutzt.</li>
</ul>
<h3>Standardeinstellungen</h3>
<ul>
<li>#NoEnv wurde entfernt; benutze stattdessen EnvGet, wenn eine entsprechende interne Variable nicht verfügbar ist.</li>
<li>SendMode benutzt standardmäßig Input statt Event.</li>
<li>Titelübereinstimmungsmodus benutzt standardmäßig 2 statt 1.</li>
<li>SetBatchLines wurde entfernt, um alle Skripte mit voller Geschwindigkeit ausführen zu lassen (in v1 entspricht das SetBatchLines -1).</li>
<li>Das Arbeitsverzeichnis ist standardmäßig <code>A_ScriptDir</code>. <code>A_InitialWorkingDir</code> enthält das Arbeitsverzeichnis, das vom Prozess, der AutoHotkey gestartet hat, gesetzt wurde.</li>
<li>Standardmäßig gilt bei allen Skripten das #SingleInstance-Nachfrageverhalten; #SingleInstance selbst aktiviert den Force-Modus.</li>
<li>CoordMode benutzt standardmäßig Client statt Window (seit v1.1.05 verfügbar).</li>
</ul>

</body>
</html><!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->

