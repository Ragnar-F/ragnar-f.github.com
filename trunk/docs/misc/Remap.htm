<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Neubelegung von Tasten</title>
<meta name="description" content="Free keyboard remapper that can also remap mouse and joystick buttons. It can also automate repetitive tasks by sending keystrokes & mouse clicks.">
<meta name="keywords" content="keyboard,remapper,remap,remapping,keys,key,keystrokes,clicks,mouse,buttons,button,joystick,hotkeys,hotkey">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="alternate" type="application/rss+xml" title="AutoHotkey Forum RSS" href="../../forum/rss.php">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Neubelegung von Tasten</h1>

<h2>Einf&uuml;hrung</h2>
<p>Diese Funktion unterst&uuml;tzt weder Joysticks noch funktioniert sie auf Windows 95/98/Me. Daf&uuml;r gibt es folgende Alternativmethoden:</p>
<ul>
  <li><a href="#Win9x">Neubelegung in Windows 9x</a></li>
  <li><a href="RemapJoystick.htm">Joystick-Neubelegung</a></li>
</ul>
<p><strong>Einschr&auml;nkung</strong>: Die unten beschriebene Neubelegungsfunktion von AutoHotkey ist in der Regel nicht so unverf&auml;lscht und effektiv wie die direkte Neubelegung in der Registrierung von Windows. F&uuml;r die Vor- und Nachteile der einzelnen Ans&auml;tze, siehe <a href="#registry">Neubelegung mit der Registrierung</a>.</p>
<h2 id="Remap">Tastatur und Maus neu belegen</h2>
<p>Die Syntax f&uuml;r die interne Neubelegungsfunktion lautet <em>Originaltaste::Zieltaste</em>. Zum Beispiel verh&auml;lt sich die Taste "a" wie die Taste "b", wenn sich nur die folgende Zeile in einem <a href="../Scripts.htm">Script</a> befindet:</p>
<pre>a::b</pre>
<p>Das obige Beispiel &auml;ndert nicht die Taste "b" selbst. Die Taste "b" sendet weiterhin ein "b", solange sie nicht wie im folgenden Beispiel neu belegt wird:</p>
<pre>a::b
b::a</pre>
<p>Die obigen Beispiele verwenden Kleinbuchstaben, die f&uuml;r die meisten Zwecke empfohlen sind, weil dadurch auch die dazugeh&ouml;rigen Gro&szlig;buchstaben neu belegt werden (wenn die Feststelltaste aktiv ist oder die Umschalt-Taste gedr&uuml;ckt gehalten wird). Im Gegensatz dazu wird mit einem Gro&szlig;buchstaben auf der rechten Seite die Gro&szlig;schreibung erzwungen. Zum Beispiel erzeugt die folgende Zeile ein gro&szlig;geschriebenes B, wenn "a" oder "A" eingegeben wird (solange die Feststelltaste deaktiviert ist):</p>
<pre>a::B</pre>
<p>&nbsp;</p>
<p><strong><a name="RemapMouse"></a>Neubelegung der Maus</strong>: Um die Maus anstelle der Tastatur neu zu belegen, verwendet die gleiche Methode. Zum Beispiel:</p>
<table class="info">
  <tr>
    <td>MButton::Shift</td>
    <td>Die mittlere Maustaste verh&auml;lt sich wie die Umschalttaste.</td>
  </tr>
  <tr>
    <td>XButton1::LButton</td>
    <td>Die vierte Maustaste verh&auml;lt sich wie die linke Maustaste.</td>
  </tr>
  <tr>
    <td>RAlt::RButton</td>
    <td>Die rechte Alt-Taste verh&auml;lt sich wie die rechte Maustaste.</td>
  </tr>
</table>
<p>&nbsp;</p>
<p><strong>Weitere n&uuml;tzliche Neubelegungen:</strong></p>
<table class="info">
  <tr>
    <td>Capslock::Ctrl</td>
    <td>Feststelltaste verh&auml;lt sich wie die Strg-Taste. Um die Umschaltf&auml;higkeit der Feststelltaste zu erhalten, f&uuml;gt au&szlig;erdem die Neubelegung <em>+Capslock::Capslock</em> hinzu (damit wird die Feststelltaste aktiviert oder deaktiviert, wenn der Benutzer die Umschalttaste gedr&uuml;ckt h&auml;lt und die Feststelltaste dr&uuml;ckt).</td>
  </tr>
  <tr>
    <td>XButton2::^LButton</td>
    <td>Die f&uuml;nfte Maustaste (XButton2) erzeugt Steuerung+Linksklick.</td>
  </tr>
  <tr>
    <td>RAlt::AppsKey</td>
    <td>Die rechte Alt-Taste verh&auml;lt sich wie die Men&uuml;-Taste (die das Kontextmen&uuml; &ouml;ffnet).</td>
  </tr>
  <tr>
    <td>RCtrl::RWin</td>
    <td>Die rechte Strg-Taste verh&auml;lt sich wie die rechte Win-Taste.</td>
  </tr>
  <tr>
    <td>Ctrl::Alt</td>
    <td>Beide Strg-Tasten verhalten sich wie eine Alt-Taste. Siehe jedoch <a href="#AltTab">Alt-Tab-Probleme</a>.</td>
  </tr>
  <tr>
    <td>^x::^c</td>
    <td>Steuerung+X erzeugt Steuerung+C. F&uuml;hrt auch dazu, dass Steuerung+Alt+X die Tastenkombination Steuerung+Alt+C erzeugt, usw.</td>
  </tr>
  <tr>
    <td>RWin::Return</td>
    <td>Deaktiviert die rechte Win-Taste, indem sie einfach <a href="../commands/Return.htm">zur&uuml;ckgegeben</a> wird.</td>
  </tr>
</table>
<p>Die oben genannten Beispiele k&ouml;nnen ausprobiert werden, indem sie in einer neuen Textdatei z. B. namens "Remap.ahk" kopiert werden und die Datei danach ausgef&uuml;hrt wird.</p>
<p>In der <a href="../KeyList.htm">Tastenliste</a> k&ouml;nnen alle Tastennamen der Tastatur und Maus gefunden werden.</p>
<h2>Bemerkungen</h2>
<p>Mit den Anweisungen <a href="../commands/_IfWinActive.htm">#IfWinActive/Exist</a> k&ouml;nnen die Neubelegungen nur f&uuml;r bestimmte Fenster g&uuml;ltig gemacht werden. Zum Beispiel:</p>
<pre>#IfWinActive ahk_class Notepad
a::b  <em>; Im Editor verh&auml;lt sich die Taste "a" wie die Taste "b".</em>
#IfWinActive  <em>; Alle nachfolgenden Neubelegungen und Hotkeys gelten f&uuml;r alle Fenster.</em></pre>
<p>Die Neubelegung einer Taste ist bei folgenden Ma&szlig;nahmen "vollst&auml;ndig":</p>
<ul>
  <li>Wenn ein Modifikator wie Strg oder Umschalt gedr&uuml;ckt gehalten wird, w&auml;hrend die originale Taste eingegeben wird, dann wird dieser Modifikator f&uuml;r die Zieltaste wirksam. Zum Beispiel erzeugt b::a die Tastenkombination Steuerung+A, wenn Steuerung+B gedr&uuml;ckt wird.</li>
  <li>Generell beeinflusst die Feststelltaste neu belegte Tasten auf die gleiche Weise wie normale Tasten.</li>
  <li>Die Zieltaste wird gedr&uuml;ckt gehalten, solange die originale Taste gedr&uuml;ckt gehalten wird. Allerdings unterst&uuml;tzen einige Spiele keine Neubelegung. In solchen F&auml;llen verh&auml;lt sich die Tastatur und Maus so, als w&auml;ren sie nicht neu belegt.</li>
  <li>Neu belegte Tasten werden automatisch wiederholt, w&auml;hrend sie gedr&uuml;ckt gehalten werden (au&szlig;er Tasten, die mit Maustasten neu belegt wurden).</li>
</ul>
<p><a name="HookHotkeys"></a>Obwohl eine neu belegte Taste normale Hotkeys ausl&ouml;sen kann, kann sie keine Maus- oder <a href="../commands/_UseHook.htm">Hook-Hotkeys</a> ausl&ouml;sen (mit <a href="../commands/ListHotkeys.htm">ListHotkeys</a> k&ouml;nnen Hook-Hotkeys entdeckt werden). Wenn zum Beispiel die Neubelebung a::b aktiv ist, dann l&ouml;st das Dr&uuml;cken von Strg+Alt+A den Hotkey ^!b aus, wenn ^!b kein Hook-Hotkey ist. Wenn ^!b ein Hook-Hotkey ist, dann kann ^!a als ein Hotkey definiert werden, damit Strg+Alt+A die gleiche Aktion wie Strg+Alt+B ausf&uuml;hrt. Zum Beispiel:</p>
<pre>a::b
^!a::
^!b::
ToolTip %A_ThisHotkey% wurde gedr&uuml;ckt.
Return</pre>
<p><a name="SendPlay"></a>Wenn <a href="../commands/SendMode.htm">SendMode</a> im automatischen Ausf&uuml;hrungsbereich verwendet wird (oberste Teil des Scripts), dann werden alle Neubelegungen davon beeinflusst. Da die Neubelegung <a href="../commands/Send.htm#blind">Send {Blind}</a> verwendet, dass vom <a href="../commands/SendMode.htm">SendPlay-Modus</a> nicht vollst&auml;ndig unterst&uuml;tzt wird, funktionieren m&ouml;glicherweise einige Neubelegungen nicht richtig im SendPlay-Modus (besonders STRG, UMSCHALT, ALT und WIN). Als &Uuml;bergangsl&ouml;sung sollte SendPlay im automatischen Ausf&uuml;hrungsbereich weggelassen werden, wenn Neubelegungen vorhanden sind, und verwendet dann den <a href="../commands/Send.htm#SendPlay">SendPlay</a>-Befehl anstelle von Send. Alternativ k&ouml;nnen die Neubelegungen auch in Hotkeys umgewandelt werden (wie unten beschrieben), die SendEvent anstelle von Send direkt aufrufen.</p>
<p>Wenn ein Script gestartet wird, dann wird jede Neubelegung in zwei <a href="../Hotkeys.htm">Hotkeys</a> umgewandelt. Zum Beispiel enth&auml;lt ein Script mit <em>a::b</em> stattdessen die folgenden zwei Hotkeys:</p>
<pre>*<strong>a</strong>::
SetKeyDelay -1   <em>; Wenn die Zieltaste eine Maustaste ist, dann verwendet stattdessen SetMouseDelay.</em>
Send <a href="../commands/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownTemp}  <em>; DownTemp ist wie Down, nur dass andere Send-Befehle im Script nicht davon ausgehen, dass "b" w&auml;hrend des Sendens unten bleiben soll.</em>
Return

*<strong>a up</strong>::
SetKeyDelay -1  <em>; Siehe den unteren Hinweis, warum die Druckdauer nicht mit einem der beiden SetKeyDelays angegeben wird.</em>
Send {Blind}{<strong>b</strong> Up}
Return</pre>
<p>Allerdings unterscheiden sich die oberen Hotkeys unter folgenden Umst&auml;nden:</p>
<ol>
  <li>Wenn die Quelltaste die LCtrl-Taste ist und die Zieltaste eine Alt-Taste ist, dann wird die Zeile <em>Send {Blind}{LAlt DownTemp}</em> mit <em>Send {Blind}<strong>{LCtrl Up}</strong>{LAlt DownTemp}</em> ersetzt. Das Gleiche gilt, wenn die Quelle die RCtrl-Taste ist, nur wird <em>{RCtrl up}</em> nicht verwendet.</li>
  <li>Wenn eine Tastatur-Taste mit einer Maustaste (z. B. RCtrl::RButton) neu belegt ist, dann verwenden die oben genannten Hotkeys SetMouseDelay anstelle von SetKeyDelay. Dar&uuml;ber hinaus wird der erste oben genannte Hotkey mit Folgendem ersetzt, um die automatische Wiederholung von Maustasten zu verhindern:
    <pre>*RCtrl::
SetMouseDelay -1
If not GetKeyState("RButton")  <em>; d. h. die rechte Maustaste wurde noch nicht gedr&uuml;ckt.</em>
    Send {Blind}{RButton DownTemp}
Return</pre>
  </li>
</ol>
<p>Beachtet, dass der zweite Parameter (<a href="../commands/SetKeyDelay.htm#dur">Druckdauer</a>) von SetKeyDelay f&uuml;r die oben genannten Hotkeys entf&auml;llt. Denn die Druckdauer gilt nicht f&uuml;r Nur-Down- und Nur-Up-Ereignisse, wie z. B. {b down} und {b up}. Allerdings gilt die Druckdauer f&uuml;r Status&auml;nderungen von Umschalt-/Strg-/Alt-/Win-Tasten, wobei Neubelegungen wie a::B oder a::^b beeinflusst werden. Folglich gilt jede Druckdauer, die im <a href="../Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> aktiviert ist, f&uuml;r alle Neubelegungen.</p>
<p>Obwohl ein Tastenpaar nicht direkt mit einer Taste neu belegt werden kann (z. B. ist <em>a & c::b</em> ung&uuml;ltig), kann dieser Effekt dennoch erreicht werden, wenn die Up- und Down-Hotkeys von weiter oben direkt hinzugef&uuml;gt werden: ersetzt <em>*a::</em> einfach mit <em>a & c::</em>, und ersetzt <em>*a up::</em> mit <em>a & c up::</em></p>
<p>Da Neubelegungen wie oben beschrieben in Hotkeys umgewandelt werden, werden sie vom <a href="../commands/Suspend.htm">Suspend</a>-Befehl beeinflusst. Ebenso kann mit dem <a href="../commands/Hotkey.htm">Hotkey</a>-Befehl eine Neubelegung deaktiviert oder bearbeitet werden. Zum Beispiel deaktivieren die zwei folgenden Befehle die Neubelegung <em>a::b</em>.</p>
<pre>Hotkey, *a, off
Hotkey, *a up, off</pre>
<p><a name="AltTab"></a>Alt-Tab-Probleme: Wenn eine Taste oder Maustaste mit einer Alt-Taste neubelegt wird, dann ist diese Taste wahrscheinlich nicht in der Lage, ein Alt-Tab-Ereignis richtig auszuf&uuml;hren. Als m&ouml;gliche &Uuml;bergangsl&ouml;sung kann der Hotkey <em>*Tab::Send {Blind}{Tab}</em> hinzugef&uuml;gt werden, der aber die Benutzung der realen Alt-Taste f&uuml;r Alt-Tab wahrscheinlich st&ouml;rt. Daher sollte der Hotkey nur verwendet werden, wenn das Alt-Tab ausschlie&szlig;lich mithilfe neu belegter Tasten und/oder <a href="../Hotkeys.htm#alttab">Alt-Tab-Hotkeys</a> ausgef&uuml;hrt wird.</p>
<p>Zus&auml;tzlich zu den Tasten und Maustasten in der <a href="../KeyList.htm">Tastenliste</a> kann die Quelltaste auch eine virtuelle Taste (VKnn) oder ein Scan-Code (SCnnn) sein (siehe <a href="../KeyList.htm#SpecialKeys">Sondertasten</a>). Das Gleiche gilt f&uuml;r die Zieltasten, au&szlig;er dass nach der virtuellen Taste optional ein Scan-Code angegeben werden kann. Zum Beispiel ist <em>sc01e::vk42sc030</em> bei den meisten Tastaturbelegungen gleichbedeutend mit <em>a::b</em>.</p>
<p>Um eine Taste zu deaktivieren, anstatt neu zu belegen, erstellt ein Hotkey nur mit <a href="../commands/Return.htm">Return</a>. Zum Beispiel deaktiviert <em>F1::Return</em> die F1-Taste.</p>
<p>Die folgenden Tasten werden nicht von der internen Neubelegungsmethode unterst&uuml;tzt:</p>
<ul>
  <li>Das Mausrad (WheelUp/Down/Left/Right).</li>
  <li>Pause und Break als Zieltasten (da sie den Befehlen entsprechen).</li>
  <li>Geschweifte Klammern {} als Zieltasten. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>, z. B. <em>x::+sc01A</em> und <em>y::+sc01B</em>.</li>
  <li>Ein Prozentzeichen (%) als Zieltaste. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>.</li>
  <li>"Return" als Zieltaste. Verwendet stattdessen "Enter".</li>
</ul>
<h2>Den Mauszeiger mit der Tastatur bewegen</h2>
<p>Die Tastatur kann dazu verwendet werden, den Mauszeiger wie im <a href="../scripts/NumpadMouse.htm">Tastatur-zu-Maus-Script</a> zu bewegen. Da das Script eine reibungslose Bewegung, Beschleunigung und andere Funktionen f&uuml;r den Zeiger erm&ouml;glicht, dann ist es die empfohlene Vorgehensweise, um die Tastatur als Maus zu verwenden. Im Gegensatz dazu ist das folgende Beispiel eine einfachere Demonstration:</p>
<pre>*#up::MouseMove, 0, -10, 0, R  <em>; Win + Pfeil oben => Zeiger nach oben bewegen</em>
*#Down::MouseMove, 0, 10, 0, R  <em>; Win + Pfeil unten => Zeiger nach unten bewegen</em>
*#Left::MouseMove, -10, 0, 0, R  <em>; Win + Pfeil links => Zeiger nach links bewegen</em>
*#Right::MouseMove, 10, 0, 0, R  <em>; Win + Pfeil rechts => Zeiger nach rechts bewegen</em>

*&lt;#RCtrl::  <em>; WinLinks + SteuerungRechts => Linksklick (Steuerung/Umschalt f&uuml;r Steuerung+Klick oder Umschalt+Klick gedr&uuml;ckt halten).</em>
SendEvent {Blind}{LButton down}
KeyWait RCtrl  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{LButton up}
Return

*&lt;#AppsKey::  <em>; Win links + Men&uuml;-Taste => Rechtsklick</em>
SendEvent {Blind}{RButton down}
KeyWait AppsKey  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{RButton up}
Return</pre>
<h2 id="registry">Neubelegung mittels "Scancode Map" von der Registrierung</h2>
<p><strong>Vorteile:</strong></p>
<ul>
  <li>Neubelegung in der Registrierung ist in der Regel eher unverf&auml;lscht und effektiv als die <a href="#Remap">Neubelegung von AutoHotkey</a>. Zum Beispiel funktioniert es f&uuml;r einen breiteren Bereich von Spielen, hat keine bekannten <a href="#AltTab">Alt-Tab-Probleme </a>und ist in der Lage, Hook-Hotkeys von AutoHotkey auszuf&uuml;hren (w&auml;hrend die Neubelegung von AutoHotkey eine <a href="#HookHotkeys">&Uuml;bergangsl&ouml;sung</a> ben&ouml;tigt).</li>
  <li>Wenn der Wunsch besteht, die Registrierungseintr&auml;ge manuell zu bearbeiten (siehe unten), dann ist absolut keine externe Software notwendig, um die Tastatur neu zu belegen. Selbst wenn <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> f&uuml;r die Registrierungseintr&auml;ge verwenden wird, muss dieses Programm nicht die ganze Zeit laufen (im Gegensatz zu AutoHotkey).</li>
</ul>
<p><strong>Nachteile:</strong></p>
<ul>
  <li>Die Neubelegung in der Registrierung ist relativ permanent: ein Neustart wird ben&ouml;tigt, um die &Auml;nderungen r&uuml;ckg&auml;ngig oder wirksam zumachen.</li>
  <li>Die Auswirkung ist global: es k&ouml;nnen keine Neubelegungen f&uuml;r bestimmte Benutzer, Anwendungen oder Gebietsschemen erstellt werden.</li>
  <li>Es k&ouml;nnen keine Tastatureingaben gesendet werden, die durch Umschalt, Strg, Alt oder AltGr modifiziert sind. Zum Beispiel kann ein Kleinbuchstabe nicht mit einem Gro&szlig;buchstaben neu belegt werden.</li>
  <li>Es wird nicht von Windows 95/98/Me unterst&uuml;tzt (AutoHotkey erm&ouml;glicht eine <a href="#Win9x">begrenzte Neubelegung in Win9x</a>).</li>
  <li>Es wird nur die Tastatur unterst&uuml;tzt (AutoHotkey erm&ouml;glicht eine <a href="#RemapMouse">Neubelegung der Maus</a> und einige <a href="RemapJoystick.htm">begrenzte Joystick-Neubelegungen</a>).</li>
</ul>
<p><strong>Wie &Auml;nderungen an der Registrierung vorgenommen werden k&ouml;nnen:</strong> Es gibt mindestens zwei Methoden, um Tasten mittels der Registrierung neu zu belegen:</p>
<ol>
  <li>Verwendet ein Programm wie <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> (Freeware), um Tasten visuell neu zu belegen. Damit wird die Registrierung ge&auml;ndert. </li>
  <li>Tasten k&ouml;nnen manuell neu belegt werden, wenn eine .reg-Datei (Klartext) erstellt und in die Registrierung geladen wird. Das wird auf <a href="http://www.autohotkey.com/forum/post-56216.html#56216">www.autohotkey.com/forum/post-56216.html#56216</a> demonstriert.</li>
</ol>
<h2 id="alt"><a name="Win9x"></a>Neubelegungsmethode f&uuml;r Windows 95/98/Me</h2>
<p>Nichts anderes als die Verwendung von <a href="../commands/Send.htm">Send</a> und <a href="../commands/KeyWait.htm">KeyWait</a>. Zum Beispiel erm&ouml;glicht der folgende Hotkey, dass die Taste "A" sich wie die linke Pfeiltaste verh&auml;lt:</p>
<pre>a::
Send {Left down}  <em>; H&auml;lt die linke Pfeiltaste gedr&uuml;ckt.</em>
KeyWait a  <em>; Wartet, bis die Taste losgelassen wird.</em>
Send {Left up}  <em>; L&auml;sst die linke Pfeiltaste los.</em>
Return</pre>
<h2>Verwandte Befehle</h2>
<p><a href="../KeyList.htm#Joystick">Tastenliste</a><br> <a href="../commands/GetKeyState.htm">GetKeyState</a><br> <a href="RemapJoystick.htm">Neubelegung eines Joysticks</a></p>
</body>
</html>