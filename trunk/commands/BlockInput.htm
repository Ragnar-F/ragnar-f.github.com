<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>BlockInput</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>BlockInput</h1>

<p>Deaktiviert oder aktiviert die Fähigkeit des Benutzers, mit dem Computer mittels Tastatur und Maus zu interagieren. </p>

<pre class="Syntax">BlockInput, Modus </pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Modus</td>
    <td width="85%"><p><strong><u>Modus 1</u></strong>: Eins der folgenden Wörter:</p>
      <p>On: Der Benutzer wird davon abgehalten, mit dem Computer zu interagieren (Maus- und Tastaturaktionen haben keine Wirkung). </p>
      <p><strong>Off</strong>: Eingaben sind wieder möglich.</p>
      <p><u><strong>Modus 2</strong></u> (hat keine Wirkung in Windows 9x): Dieser Modus läuft unabhängig von den Anderen. Zum Beispiel wird <em>BlockInput On</em> solange die Eingaben weiter blockieren, bis <em>BlockInput Off</em> eingeleitet wird, selbst wenn ein nachfolgender Befehl aktiv ist.</p>
      <p><strong>Send</strong>: Die Tastatur- und Mausaktionen des Benutzers werden ignoriert, während <a href="Send.htm">Send</a> oder <a href="Send.htm">SendRaw</a> aktiv sind (nur der traditionelle <a href="SendMode.htm">SendEvent Mode</a>). Somit werden die künstlichen Tastatureingaben nicht von den Tastatureingaben des Benutzers unterbrochen. Wenn der Send-Befehl beendet wird, dann ist eine Eingabe wieder möglich (es sei denn, es wird noch durch <em>BlockInput On</em> geblockt).</p>
      <p><strong>Mouse</strong>: Die Tastatur- und Mausaktionen des Benutzers werden ignoriert, während <a href="Click.htm">Click</a>, <a href="MouseMove.htm">MouseMove</a>, <a href="MouseClick.htm">MouseClick</a> oder <a href="MouseClickDrag.htm">MouseClickDrag</a> aktiv sind (nur der traditionelle <a href="SendMode.htm">SendEvent Mode</a>). Somit werden die simulierten Mausaktionen nicht von den Mausaktionen des Benutzers unterbrochen. Wenn der Maus-Befehl beendet wird, dann ist eine Eingabe wieder möglich (es sei denn, es wird noch durch <em>BlockInput On</em> geblockt).</p>
      <p><strong>SendAndMouse</strong>: Eine Kombination von <I>Send</I><B><B><B> </B></B></B>und <I>Mouse</I>.</p>
      <p><strong>Default</strong>: Sowohl der <em>Send</em>- als auch der <em>Mouse</em>-Modus werden deaktiviert, der aktuelle Blockierungszustand der Eingabe bleibt jedoch unverändert. Wenn zum Beispiel <em>BlockInput On</em> noch aktiv ist, dann hat <em>BlockInput Default</em> keinen Effekt.</p>
      <p><u><strong><a name="MouseMove"></a></strong></u><strong><u>Modus 3</u></strong><U> (funktioniert nicht in Windows 9x; benötigt v1.0.43.11+):</U> Dieser Modus läuft unabhängig von den Anderen. Zum Beispiel werden Mausbewegungen solange weiter geblockt, bis <em>BlockInput On</em> und <em>BlockInput MouseMove</em> deaktiviert werden.</p>
      <p><strong>MouseMove</strong>: Der Mauszeiger reagiert nicht auf die physische Mausbewegung des Benutzers (DirectInput-Anwendungen sind eine mögliche Ausnahme). Sobald ein Script diesen Befehl verwendet, wird der <a href="_InstallMouseHook.htm">Maus-Hook</a> installiert (wenn es nicht bereits geschehen ist). Zusätzlich wird das Script <a href="_Persistent.htm">persistent</a>, d. h. <a href="ExitApp.htm">ExitApp</a> sollte zum Beenden des Scripts verwendet werden. Der Maus-Hook bleibt solange installiert, bis die Befehle <a href="Suspend.htm">Suspend</a> oder <a href="Hotkey.htm">Hotkey</a> verwendet werden. In diesem Fall wird der Hook entfernt, wenn er nicht explizit von Hotkeys oder Hotstrings benötigt wird (siehe <a href="_Hotstring.htm">#Hotstring NoMouse</a>).</p>
      <p><strong>MouseMoveOff</strong>: Erlaubt dem Benutzer, den Mauszeiger zu bewegen.</p></td>
  </tr>
</table>

<h3>Bemerkungen</h3>
<p>Bei Verwendung von BlockInput sollte oft <a href="SendMode.htm"><em>SendMode Input</em></a> oder <em><a href="SendMode.htm">SendMode Play</a></em> in Betracht gezogen werden, damit die Tastatureingaben und Mausklicks nicht unterbrochen werden können. Denn im Gegensatz zum BlockInput verwerfen solche Modi nicht die Eingabe des Benutzers während des Send-Befehls. Solche Tastatureingaben werden stattdessen zwischengespeichert und danach gesendet. Durch das Vermeiden von BlockInput wird auch verhindert, dass festgeklemmte Tasten umgangen werden müssen, wie im nächsten Abschnitt beschrieben.</p>
<p>Wenn BlockInput aktiviert wird, während der Benutzer Tasten gedrückt hält, dann bleiben diese Tasten dauerhaft gedrückt. Das kann verhindert werden, wenn auf das Loslassen von Tasten gewartet wird, bevor BlockInput aktiviert wird. Zum Beispiel:</p>
<pre>^!p::
KeyWait Control  <em>; Warten, bis die Taste losgelassen wird.  KeyWait für jede Modifikator-Taste verwenden.</em>
KeyWait Alt
BlockInput On
<em>; ... Tastatureingaben und Mausklicks senden ...</em>
BlockInput Off
Return</pre>
<p>Das Blocken der Eingabe wird automatisch und sofort deaktiviert, sobald die ALT-Taste gesendet wird (wird danach wieder aktiviert).</p>
<p>Die Tabelle unten zeigt, wie sich BlockInput bei verschiedenen Windows-Versionen verhält. Nur Strg+Alt+Entf hebt durch eine API-Funktion von Windows das Blocken wieder auf.</p>
<table class="info">
  <tr>
    <th width="37%"><strong><em>Betriebssystem </em></strong></th>
    <th width="63%"><strong><em>Ergebnis von BlockInput </em></strong></th>
  </tr>
  <tr>
    <td>Windows 95 </td>
    <td>Keinen Effekt. </td>
  </tr>
  <tr>
    <td>Windows 98/Me</td>
    <td>Benutzereingabe wird blockiert und AutoHotkey ist <strong>nicht fähig</strong>, Eingaben zu simulieren. </td>
  </tr>
  <tr>
    <td>Windows NT 4 (<em>ohne</em> Service-Pack 6) </td>
    <td>Keinen Effekt. </td>
  </tr>
  <tr>
    <td>Windows NT 4 (<em><em>m</em>it </em>Service-Pack 6) </td>
    <td>Benutzereingabe wird blockiert, aber AutoHotkey kann weiterhin Tastatureingaben und Mausklicks simulieren. </td>
  </tr>
  <tr>
    <td>Windows 2000/XP</td>
    <td>Benutzereingabe wird blockiert, aber AutoHotkey kann weiterhin Tastatureingaben und Mausklicks simulieren. </td>
  </tr>
</table>
<p><br> Windows 98/Me: Obwohl Scripts nicht in der Lage sind, Tastatureingaben und Mausklicks während BlockInput zu senden, funktionieren Befehle wie <a href="WinMove.htm">WinMove</a> nach wie vor. <a href="ControlSend.htm">ControlSend</a> könnte auch funktionieren. </p>
<p>Verschiedene Arten von <a href="_UseHook.htm">Hook-Hotkeys</a> können immer noch ausgelöst werden, wenn BlockInput aktiv ist. Beispielsweise "MButton" (Maus-Hook) und "LWin & Space" (Tastatur-Hook mit eindeutigem Präfix anstelle von Modifikatoren "$#").</p>
<p> Eingabe wird automatisch wieder ermöglicht, wenn das Script beendet wird.</p>
<h3>Verwandte Befehle</h3>
<p><a href="SendMode.htm">SendMode</a>, <a href="Send.htm">Send</a>, <a href="Click.htm">Click</a>, <a href="MouseMove.htm">MouseMove</a>, <a href="MouseClick.htm">MouseClick</a>, <a href="MouseClickDrag.htm">MouseClickDrag</a></p>
<h3>Beispiel</h3>
<pre class="NoIndent">If A_OSType <> WIN32_WINDOWS <em>; z. B. nicht Windows 9x.</em>
    BlockInput, on
Run, notepad
WinWaitActive, Unbenannt- Editor
Send, {F5} <em>; Zeit und Datum hinzufügen</em>
BlockInput, off</pre>

</body>
</html>
