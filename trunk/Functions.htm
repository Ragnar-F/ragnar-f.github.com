<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="css/default.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einf&uuml;hrung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion </a></li>
  <li><a href="#ShortCircuit">Boolesche Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Subroutinen innerhalb einer Funktion verwenden</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</a></li>
  <li><a href="#lib">Funktionsbibliotheken: Standard-Bibliothek und Benutzer-Bibliothek</a></li>
  <li><a href="#BuiltIn">Interne Funktionen</a></li>
</ul>
<h2><a name="intro" id="intro"></a>Einf&uuml;hrung und einfache Beispiele</h2>
<p><a name="define"></a>Eine Funktion ist mit einer Subroutine (<a href="commands/Gosub.htm">GoSub</a>) vergleichbar, nur dass sie auch Parameter (Eingabevariablen) von ihrem Aufrufer akzeptiert. Dar&uuml;ber hinaus kann eine Funktion optional einen Wert f&uuml;r ihren Aufrufer zur&uuml;ckgeben. Zieht die folgende einfache Funktion in Betracht, die 2 Zahlen akzeptiert und deren Summe zur&uuml;ckgibt:</p>
<pre>Addieren(x, y)
{
    Return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
<p>Das obere Beispiel wird als <em>Funktionsdefinition</em> bezeichnet, da es eine Funktion namens "Addieren" (nicht von der Gro&szlig;- und Kleinschreibung abh&auml;ngig) erstellt und festlegt, der genau zwei Parameter (x und y) bereitgestellt werden m&uuml;ssen. Um die Funktion aufzurufen, speichert mithilfe des <a href="commands/SetExpression.htm"><strong>:=</strong></a><a href="commands/SetExpression.htm"> Operators</a> ihr Ergebnis in eine Variable. Zum Beispiel:</p>
<pre>Variable := Addieren(2, 3)  <em>; Die Zahl 5 wird in die Variable gespeichert.</em></pre>
<p>Au&szlig;erdem kann eine Funktion auch aufgerufen werden, ohne ihren R&uuml;ckgabewert zu speichern:</p>
<pre>Addieren(2, 3)</pre>
<p> In diesem Fall aber wird der R&uuml;ckgabewert der Funktion verworfen; d. h. der Aufruf hat keinen Zweck, es sei denn, die Funktion erzeugt irgendetwas anderes als den R&uuml;ckgabewert.</p>
<p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten alle Variablennamen in der Parameterliste nicht von Prozentzeichen umschlossen werden. Im Gegensatz dazu sollten direkt vorhandene Strings von Anf&uuml;hrungszeichen umschlossen werden. Zum Beispiel:</p>
<pre>If <a href="#InStr">InStr</a>(EigeneVar, "fox")
    MsgBox Die Variable EigeneVar enth&auml;lt das Wort fox.</pre>
<p>Schlie&szlig;lich k&ouml;nnen Funktionen in Befehlsparametern aufgerufen werden (au&szlig;er in Parametern f&uuml;r Eingabe- und Ausgabevariablen, wie die von <a href="commands/StringLen.htm">StringLen</a>). Allerdings m&uuml;ssen Parameter, die keine <a href="Variables.htm#Expressions">Ausdr&uuml;cke</a> unterst&uuml;tzen, den "%"-Pr&auml;fix wie in diesem Beispiel verwenden:</p>
<pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
<p>Das "%"-Pr&auml;fix ist auch in Parametern zul&auml;ssig, die schon von sich aus Ausdr&uuml;cke unterst&uuml;tzen, in diesem Fall wird das Prozentzeichen einfach ignoriert.</p>
<h2><a name="param" id="param"></a>Parameter</h2>
<p>Wenn eine Funktion definiert wird, dann werden ihre Parameter neben den Funktionsnamen in Klammern aufgelistet (es d&uuml;rfen sich keine Leerzeichen zwischen den Namen und der &ouml;ffnenden Klammer befinden). Wenn eine Funktion keine Parameter akzeptieren soll, lasst den Inhalt zwischen Klammern einfach leer; zum Beispiel: GetCurrentTimestamp().</p>
<p><a name="ByRef"></a><strong>ByRef-Parameter</strong>: Aus Sicht der Funktion sind Parameter grunds&auml;tzlich das Gleiche wie <a href="#Locals">lokale Variablen</a>, es sei denn, sie werden als <em>ByRef</em>-Parameter wie im folgenden Beispiel definiert:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Im oberen Beispiel bewirkt das Verwenden von <em>ByRef</em>, dass jeder Parameter ein Pseudonym f&uuml;r die Variable wird, die vom Aufrufer &uuml;bergeben wurde. Mit anderen Worten bezieht sich der Parameter und die aufgerufene Variable auf demselben Inhalt im Arbeitsspeicher. Dadurch kann die Tauschen-Funktion die aufgerufenen Variablen &auml;ndern, indem der Inhalt von <em>Links</em> nach <em>Rechts</em> verschoben wird und umgekehrt.</p>
<p>Wenn im Gegensatz dazu <em>ByRef</em> nicht im oberen Beispiel verwendet wird, dann sind <em>Links</em> und <em>Rechts</em> jeweils Kopien der aufgerufenen Variablen, folglich hat die Tauschen-Funktion keine externe Auswirkung.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert f&uuml;r den Funktionsaufrufer zur&uuml;ckgibt, kann <em>ByRef</em> dazu verwendet werden, zus&auml;tzliche Ergebnisse zur&uuml;ckzugeben. Das kann mit der &Uuml;bergabe einer Variable (f&uuml;r gew&ouml;hnlich leer) erreicht werden, in der die Funktion einen Wert speichert.</p>
<p>Bei der &Uuml;bergabe von langen Strings an die Funktion wird mithilfe von <em>ByRef</em> die Performance verbessert und Speicherplatz gespart, da eine Kopie des Strings nicht gemacht werden muss. Wenn mit <em>ByRef</em> au&szlig;erdem ein langer String f&uuml;r den Aufrufer zur&uuml;ckgegeben wird, dann ist die Performance meist besser als <code>Return LangerString</code>.</p>
<p><span class="ver">[AHK_L 60+]:</span> Wenn etwas anderes als eine ver&auml;nderbare Variable an einem ByRef-Parameter &uuml;bergeben wird, dann ignoriert die Funktion das Schl&uuml;sselwort "ByRef". Zum Beispiel speichert <code>Tauschen(A_Index, i)</code> den Wert von <i>A_Index</i> in <i>i</i>, aber der zugewiesene Wert in <i>Links</i> wird verworfen, sobald die <i>Tauschen</i>-Funktion einen Wert zur&uuml;ckgibt.</p>
<p><span class="ver">[v1.1.01+]:</span> Mit der <a href="#IsByRef">IsByRef()</a>-Funktion kann festgestellt werden, ob der Aufrufer eine Variable f&uuml;r einen ByRef-Parameter &uuml;bergeben hat.</p>
<p>Bekannte Einschr&auml;nkungen:</p>
<ul>
  <li>Es ist nicht m&ouml;glich, die <a href="misc/Clipboard.htm">Zwischenablage</a>, <a href="Variables.htm#BuiltIn">interne Variablen</a> oder <a href="Variables.htm#env">Umgebungsvariablen</a> an den <em>ByRef</em>-Parameter der Funktion zu &uuml;bergeben, selbst wenn <a href="commands/_NoEnv.htm">#NoEnv</a> nicht im Script vorhanden ist.</li>
  <li><a name="recurse"></a>Auch wenn eine Funktion sich selbst rekursiv aufrufen kann, sobald sie ihre eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter an <em>ByRef</em> selbst &uuml;bergibt, wird sich der <em>ByRef </em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit diesem Namen beziehen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter &uuml;bergibt.</li>
  <li>Wenn bei einem Funktionsaufruf ein Parameter in eine Variable aufgel&ouml;st ist (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var*=2</code>), dann k&ouml;nnen die Parameter auf der linken und rechten Seite diese Variable noch &auml;ndern, bevor sie an die Funktion &uuml;bergeben wird. Zum Beispiel wird <code>Funktion(Variable, Variable++)</code> unerwartet eine 0 und 1 &uuml;bergeben, wenn die <em>Variable</em> anfangs eine 0 ist, selbst wenn der erste Parameter der Funktion kein <em>ByRef</em> ist. Da dieses Verhalten nicht intuitiv ist, wird es m&ouml;glicherweise in einer zuk&uuml;nftigen Version ge&auml;ndert.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Beim Definieren einer Funktion k&ouml;nnen beliebig viele Parameter als optional gekennzeichnet werden. Dazu wird ein Gleichheitszeichen gefolgt von einem Standardwert angef&uuml;gt. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Addieren(X, Y, Z=0) {
    Return X + Y + Z
}</pre>
<p>Wenn der Aufrufer <strong>drei</strong> Parameter an die obere Funktion &uuml;bergibt, dann wird der Standardwert von Z ignoriert. Wenn der Aufrufer allerdings nur <strong>zwei</strong> Parameter &uuml;bergibt, dann wird f&uuml;r Z automatisch der Wert 0 verwendet.</p>
<p>Es ist nicht m&ouml;glich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Mit anderen Worten m&uuml;ssen alle Parameter, die sich rechts vom ersten optionalen Parameter befinden, auch als optional gekennzeichnet werden. <span class="ver">[AHK_L 31+]:</span> Optionale Parameter k&ouml;nnen beim Funktionsaufruf in der Mitte der Parameterliste weggelassen werden, solange der Funktionsaufruf nicht dynamisch ist:</p>
<pre>Funktion(1,, 3)
Funktion(X, Y=2, Z=0) {  <em>; Beachtet, dass Z in diesem Fall immer noch optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p><a name="OptionalByRef"></a>Seit v1.0.46.13 unterst&uuml;tzen <a href="#ByRef">ByRef-Parameter</a> auch Standardwerte; z. B.: <code>Funktion(ByRef p1 = "")</code>. Sobald der Aufrufer einen solchen Parameter wegl&auml;sst, erstellt die Funktion eine lokale Variable mit dem Standardwert; mit anderen Worten ignoriert sie das Schl&uuml;sselwort "ByRef".</p>
<p>F&uuml;r den Standardwert eines Parameters sind folgende Werte erlaubt: true, false, ein direkt vorhandener Integer, eine direkt vorhandene Flie&szlig;kommazahl oder ein direkt vorhandener String wie "fox" oder "" (aber vor v1.0.46.13 unterst&uuml;tzen Strings nur "").</p>
<h2 id="Variadic">Variadische Funktionen <span class="ver">[AHK_L 60+]</span></h2>
<p>Beim Definieren einer Funktion kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, wodurch sie eine beliebige Anzahl an Parametern akzeptiert:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    Return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Wenn eine variadische Funktion aufgerufen wird, dann sind &uuml;bersch&uuml;ssige Parameter mithilfe eines Objekts zug&auml;nglich, das im letzten Parameter der Funktion gespeichert ist. Der erste &uuml;bersch&uuml;ssige Parameter ist <code><i>params</i>[1]</code>, der Zweite ist <code><i>params</i>[2]</code> und so weiter. Wie mit jedem Standardobjekt kann <code><i>params</i>.MaxIndex()</code> verwendet werden, um den h&ouml;chsten numerischen Index zu ermitteln (in diesem Fall die Anzahl an Parametern). Wenn allerdings keine Parameter vorhanden sind, dann gibt MaxIndex einen leeren String zur&uuml;ck.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann nur am Ende der formalen Parameterliste stehen.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> k&ouml;nnen nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> &uuml;bergeben &uuml;bersch&uuml;ssige Parameter <a href="commands/RegisterCallback.htm#Indirect">mittels deren Adresse</a> anstelle eines Arrays.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>W&auml;hrend variadische Funktionen eine beliebige Anzahl an Parametern <i>akzeptieren</i> k&ouml;nnen, kann ein Array von Parametern an <i>jeder</i> Funktion &uuml;bergeben werden, wenn der gleiche Syntax beim Funktionsaufruf angewendet wird:</p>
<pre>substrings := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">substrings*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Die Nummerierung der Parameter beginnt innerhalb des Quell-Arrays bei 1.</li>
  <li>Optionale Parameter k&ouml;nnen im Array ganz weggelassen werden.</li>
  <li>Das Array von Parametern kann benannte Elemente beim direkten Aufrufen einer benutzerdefinierten Funktion enthalten.</li>
  <li>Die Zielfunktion kann auch variadisch sein, wodurch benannte Elemente kopiert werden, auch wenn sie keinen entsprechenden formalen Parameter haben.</li>
  <li>Diese Syntax kann auch f&uuml;r den Aufruf einer Methode oder f&uuml;r das Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>.</li>
</ul>
<p>Bekannte Einschr&auml;nkungen:</p>
<ul>
  <li>Nur der letzte physische Parameter kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterst&uuml;tzt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Diese Syntax kann nicht f&uuml;r das Setzen von Objekteigenschaften verwendet werden, da der letzte physische Parameter tats&auml;chlich der zugewiesene Wert ist.</li>
  <li>Es d&uuml;rfen sich keine sichtbaren Zeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste befinden.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen </h2>
<h3>Lokale Variablen</h3>
<p>Alle Variablen innerhalb einer Funktion sind standardm&auml;&szlig;ig <em>lokal</em> (au&szlig;er interne Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">Errorlevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Der Inhalt jeder lokalen Variable ist nur f&uuml;r Zeilen sichtbar, die sich innerhalb der Funktion befinden. Daher k&ouml;nnte eine lokale Variable den gleichen Namen einer globalen Variable haben, aber mit unterschiedlichem Inhalt. Letztendlich sind alle lokalen Variablen bei jedem Funktionsaufruf zu Beginn leer.</p>
<h3 id="Global">Globale Variablen</h3>
<p>Damit eine Variable sich auf eine vorhandene globale Variable au&szlig;erhalb einer Funktion bezieht (oder eine neue Variable erstellt wird), deklariert sie vorher als global. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    global LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert au&szlig;erhalb dieser Funktion zugewiesen.</em>
    FileAppend, %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="AssumeGlobal"></a><strong>Modus f&uuml;r die globale Ansicht</strong>: Wenn eine Funktion auf eine gro&szlig;e Anzahl an globalen Variablen zugreifen oder sie erstellen muss, dann k&ouml;nnen alle Variablen global gemacht werden (au&szlig;er ihren Parametern), indem die erste Zeile entweder das Wort "global" oder die Deklaration einer lokalen Variable enth&auml;lt. Zum Beispiel:</p>
<pre>StandardwerteSetzen()
{
    global  <em>; Dieses Wort kann weggelassen werden, wenn in der ersten Zeile so etwas wie "local EigeneVar" steht.</em>
    EigeneGlobal := 33  <em>; Speichert 33 in eine globale Variable und erstellt sie zuerst je nach Bedarf.</em>
    local x, y:=0, z  <em>; Lokale Variablen m&uuml;ssen in diesem Modus deklariert werden, ansonsten werden sie auch als global angesehen.</em>
}</pre>
<p>Dieser Modus f&uuml;r die globale Ansicht kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Array</a> zu erstellen, wie bei einer Schleife, die Werte mittels <code>Array%A_Index%</code> zuweist.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind immer indirekt lokal, die sich jedoch von lokalen Variablen unterscheiden, da ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl = 0
    Zeilenanzahl += 1  <em>; Z&auml;hlervariable lokal verwalten (ihr Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend, %Zeilenanzahl%: %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="InitStatic"></a><strong>Statische Initialisierungen</strong>: Vor v1.0.46 waren alle statischen Variablen zu Beginn leer; daher konnten sie nur ermittelt werden, wenn sie zuerst &uuml;berpr&uuml;ft wurden, ob sie leer waren. Seit v1.0.46 k&ouml;nnen statische Variablen mit etwas anderem als <code>""</code> initialisiert werden, wenn <code>:=</code> oder <code>=</code> gefolgt von einem folgenden Wert angef&uuml;gt wird: true, false, ein direkt vorhandener Integer, eine direkt vorhandene Flie&szlig;kommazahl oder ein direkt vorhandener String wie <code>"fox"</code>. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Jede statische Variable wird nur einmal initialisiert (bevor das Script ausgef&uuml;hrt wird).</p>
<p><span class="ver">[AHK_L 58+]:</span> <code>Static Variable := Ausdruck</code> wird unterst&uuml;tzt. Solche Ausdr&uuml;cke werden nach der jetzigen Reihenfolge unmittelbar vor dem automatischen Ausf&uuml;hrungsbereich des Scripts ausgewertet.</p>
<p><a name="AssumeStatic"></a><strong>Modus f&uuml;r statische Ansicht</strong> <span class="ver">[v1.0.48+]:</span> Eine Funktion kann so definiert werden, dass all ihre Variablen statisch angesehen werden (au&szlig;er ihren Parametern), indem die erste Zeile das Wort "static" enth&auml;lt. Zum Beispiel:</p>
<pre>StatischesArrayAbrufen(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird immer noch nur einmal ausgef&uuml;hrt (beim Start).</em>
    If ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    Return StatischesArray%Elementnummer%
}</pre>
<p>Im Modus f&uuml;r die statische Ansicht muss jede Variable, die nicht statisch sein soll, als lokale oder globale Variable deklariert werden.</p>
<h3>Mehr &uuml;ber lokale und globale Variablen</h3>
<p>Es k&ouml;nnen mehrere Variablen in einer Zeile deklariert werden, indem sie durch Kommas getrennt werden, zum Beispiel:</p>
<pre>global LogDateiname, MaxWiederholungen := 5
static GesamtVersuche = 0, VorherErgebnis</pre>
<p><a name="DeclareInit"></a>Seit v1.0.46 kann eine lokale oder globale Variable auf der gleichen Zeile als Deklaration initialisiert werden, wenn ein <code>:=</code> oder <code>=</code> gefolgt von einem <a href="Variables.htm#Expressions">Ausdruck</a> angef&uuml;gt wird (der "<code>=</code>"-Operator verh&auml;lt sich in Deklarationen wie <code>:=</code>). Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgef&uuml;hrt, aber nur wenn die Ablaufsteuerung sie erreicht. Mit anderen Worten hat eine Zeile wie <code>local x = 0</code> den gleichen Effekt wie das Schreiben von zwei Zeilen: <code>local x</code>, gefolgt von <code>x = 0</code>.</p>
<p>Da die W&ouml;rter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Start des Scripts verarbeitet werden, kann eine Variable nicht mittels einer <a href="commands/IfExpression.htm">IF-Anweisung</a> bedingt deklariert werden. Mit anderen Worten, eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> wird f&uuml;r alle Zeilen zwischen der Deklaration und der schlie&szlig;enden Funktionsklammer bedingungslos wirksam. Beachtet zudem, dass es zurzeit nicht m&ouml;glich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>
<p>Bei Befehlen, die <a href="misc/Arrays.htm">Arrays</a> erstellen (z. B. <a href="commands/StringSplit.htm">StringSplit</a>), ist das resultierende Array lokal, wenn der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> nicht aktiv ist oder wenn das erste Array-Element als lokale Variable deklariert wurde (das gilt auch bei der &Uuml;bergabe eines Funktionsparameters, selbst wenn dieser Parameter ein <a href="#ByRef">ByRef</a> ist, da Parameter mit lokalen Variablen vergleichbar sind). Im Gegensatz dazu wird ein globales Array erstellt, wenn das erste Element <a href="#Global">global deklariert</a> wurde. Allerdings gilt die unten genannte <i>h&auml;ufigste Ursache f&uuml;r Verwirrung</i> auch in solchen F&auml;llen. Das erste Element von <a href="commands/StringSplit.htm">StringSplit</a> ist ArrayName0. Bei anderen Befehlen mit Arrays als Ausgabe wie <a href="commands/WinGet.htm">WinGet List</a> ist das erste Element ArrayName (also ohne die Nummer).</p>
<p><a name="DynVar"></a><a name="Dynamic" id="Dynamic"></a>Innerhalb einer Funktion wird jede dynamische Variablenreferenz wie <code>Array%i%</code> immer in eine lokale Variable aufgel&ouml;st, es sei denn, es gibt keine Variable mit diesem Namen, in diesem Fall wird eine globale Variable verwendet, falls sie vorhanden ist. Wenn sie weder existiert noch der Bedarf besteht, die Variable zu erstellen, dann wird sie als eine lokale Variable erstellt, solange der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> nicht aktiv ist. Daher kann eine Funktion ein globales <a href="misc/Arrays.htm">Array</a> nur manuell erstellen (z. B. mithilfe von <code>Array%i% := A_Index</code>), wenn die Funktion mit dem <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> definiert wurde.</p>
<p><strong>H&auml;ufigste Ursache f&uuml;r Verwirrung</strong>: Jede <em>nicht</em>-dynamische Referenz auf eine Variable erstellt diese Variable zum Zeitpunkt des Starts. Zum Beispiel: Au&szlig;erhalb einer Funktion erstellt <code>MsgBox %Array1%</code> die Variable Array1 als globale Variable zum Zeitpunkt des Starts. Innerhalb einer Funktion erstellt <code>MsgBox %Array1%</code> die Variable Array1 als lokale Funktionsvariable beim Start des Scripts (solange der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> nicht aktiv ist), selbst wenn Array und Array0 global deklariert sind.</p>
<h2 id="DynCall"><a name="dynamic"></a>Dynamisches Aufrufen einer Funktion </h2>
<p>Seit v1.0.47.06 kann eine Funktion (auch eine <a href="#BuiltIn">interne Funktion</a>) mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel ruft <code>%Variable%(x, "fox")</code> die Funktion auf, deren Name sich in der <em>Variable</em> befindet. Ebenso wird <code>Funktion%A_Index%()</code> Func1() oder Func2() usw. je nach aktuellem Wert von A_Index aufrufen.</p>
<p>Wenn die Funktion aufgrund einer folgenden Tatsache nicht aufgerufen werden kann, dann stoppt die Auswertung des Ausdrucks mit dem Aufruf still und fr&uuml;hzeitig, dass zu widerspr&uuml;chlichen Ergebnissen f&uuml;hrt:</p>
<ul>
  <li>Aufruf einer nicht vorhandenen Funktion, dass mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Abgesehen von <a href="#BuiltIn">internen Funktionen</a> muss die <a href="#define">Definition</a> der aufgerufenen Funktion z. B. mithilfe von <a href="commands/_Include.htm">#Include</a> oder mittels einem nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a> direkt im Script vorhanden sein.</li>
  <li>&Uuml;bergabe von zu wenigen Parametern, dass mittels &Uuml;berpr&uuml;fung des R&uuml;ckgabewertes von <a href="#IsFunc">IsFunc()</a> verhindert werden kann (dass ist die Anzahl an vorgeschriebenen Parametern plus 1). Hinweis: Seit v1.0.48 wird die &Uuml;bergabe von zu vielen Parametern toleriert; jeder zus&auml;tzliche Parameter wird vollst&auml;ndig ausgewertet (einschlie&szlig;lich aller Funktionsaufrufe) und dann verworfen.</li>
  <li>&Uuml;bergabe eines ungeeigneten Wertes an einen <a href="#ByRef">ByRef</a>-Parameter.</li>
</ul>
<p>Letztendlich ist ein dynamischer Funktionsaufruf etwas langsamer als ein normaler Aufruf, weil normale Aufrufe beim Start aufgel&ouml;st (nachgeschlagen) werden.</p>
<h2 id="ShortCircuit">Boolesche Kurzschlussauswertung</h2>
<p>Wenn <em>AND, OR</em> und der <a href="Variables.htm#ternary">tern&auml;re Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, dann werden sie kurzgeschlossen, um die Performance zu steigern (unabh&auml;ngig davon, ob Funktionsaufrufe vorhanden sind). Beim Kurzschlie&szlig;en werden nur Bereiche des Ausdrucks ausgewertet, die das Endergebnis mit Sicherheit beeinflussen. Zur Illustrierung des Konzepts wird dieses Beispiel in Betracht gezogen:</p>
<pre>If (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
<p>Im oberen Beispiel wird die FindeFarbe-Funktion niemals aufgerufen, wenn die <em>FarbeName</em>-Variable leer ist. Denn die linke Seite von <em>AND</em> wird als <em>falsch</em> gewertet, daher ist es f&uuml;r die rechte Seite unm&ouml;glich, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Aus diesem Grund ist die Erkenntnis wichtig, dass jeder erzeugte Nebeneffekt von einer Funktion (wie das &Auml;ndern des Inhalts einer globalen Variable) m&ouml;glicherweise niemals stattfindet, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Au&szlig;erdem sollte beachtet werden, dass die Kurzschlussauswertung stufenweise durch verschachtelte <em>AND</em>s und <em>OR</em>s schaltet. Im folgenden Beispiel wird nur der Vergleich ganz links durchgef&uuml;hrt, sobald <em>FarbName</em> leer ist. Denn die linke Seite reicht vollkommen aus, um das Endergebnis mit Sicherheit zu bestimmen:</p>
<pre>If (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder &Uuml;bereinstimmung gefunden.</em></pre>
<p>Wie aus dem oberen Beispiel ersichtlich wird, sollten aufwendige Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erh&ouml;hen. Diese Technik kann auch dazu genutzt werden, einen Funktionsaufruf zu verhindern, wenn einem Parameter ein ungeeigneter Wert &uuml;bergeben wird, wie z. B. ein leerer String.</p>
<p>Seit v1.0.46 wird der <a href="Variables.htm#ternary">tern&auml;re Bedingungsoperator (?:)</a> auch kurzgeschlossen, indem die verlierende Abzweigung nicht ausgewertet wird.</p>
<h2 id="gosub">Subroutinen innerhalb einer Funktion verwenden</h2>
<p>Obwohl eine Funktion keine <a href="#define">Definitionen</a> von anderen Funktionen enthalten kann, kann sie immer noch Subroutinen enthalten. Wie bei anderen Subroutinen kann sie mittels <a href="commands/Gosub.htm">GoSub</a> aufgerufen und mit <a href="commands/Return.htm">Return</a> beendet werden (in diesem Fall gilt das Return f&uuml;r das GoSub und nicht f&uuml;r die Funktion).</p>
<p>Bekannte Einschr&auml;nkung: Momentan darf der Name jeder Subroutine (Label) nur einmal im ganzen Script vorkommen. Das Programm benachrichtigt den Benutzer, sobald doppelte Labels vorhanden sind.</p>
<p><a name="GosubPublic"></a>Wenn eine Funktion den <a href="commands/Gosub.htm">GoSub</a>-Befehl verwendet, um eine &ouml;ffentliche Subroutine aufzurufen (au&szlig;erhalb der Funktionsklammern), dann sind alle &auml;u&szlig;eren Variablen global und die eigenen <a href="#Locals">lokalen Variablen</a> der Funktion nicht zug&auml;nglich, bis die Subroutine ausgef&uuml;hrt wurde. Allerdings wird A_ThisFunc immer noch den Namen der Funktion enthalten.</p>
<p>Obwohl ein <a href="commands/Goto.htm">Goto</a>-Befehl ignoriert wird, dessen Ziel au&szlig;erhalb der Funktion ist, kann eine Funktion mithilfe von <a href="commands/Gosub.htm">GoSub</a> zu einer externen/&ouml;ffentlichen Subroutine springen und von dort aus mithilfe von Goto weiterspringen.</p>
<p>Auch wenn vom <a href="commands/Goto.htm">Goto</a>-Befehl generell abgeraten wird, kann er innerhalb einer Funktion zu einer anderen Position in der gleichen Funktion springen. Das kann hilfreich sein, um komplexe Funktionen mit mehreren R&uuml;ckgabepunkten zu vereinfachen, die einige S&auml;uberungsaktionen machen m&uuml;ssen, bevor sie zur&uuml;ckgegeben werden.</p>
<p>Eine Funktion kann extern aufrufende Subroutinen enthalten, wie z. B. <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Men&uuml;punkte</a>. Das wird normalerweise gemacht, um sie in eine separate Datei zu hinterlegen, damit sie mit <a href="commands/_Include.htm">#Include</a> verwendet werden k&ouml;nnen, ohne dabei den <a href="Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> zu beeintr&auml;chtigen. Allerdings gelten folgende Einschr&auml;nkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), immer wenn deren Funktionen normal aufgerufen werden. Denn der Thread einer Subroutine, der den <a href="misc/Threads.htm">Thread</a> eines Funktionsaufrufs unterbricht (oder umgekehrt), w&auml;re in der Lage, den Wert von lokalen Variablen zu &auml;ndern, die f&uuml;r den unterbrochenen Thread sichtbar sind. Sobald des Weiteren eine Funktion dem Aufrufer zur&uuml;ckgeben wird, werden all ihre lokalen Variablen leer gemacht und ihr Speicher freigegeben.</li>
  <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) f&uuml;r <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
  <li>Wenn der <a href="misc/Threads.htm">Thread</a> einer Subroutine die Funktion betritt, dann werden jegliche Thread-Referenzen zu den <a href="misc/Arrays.htm">dynamischen Variablen</a> als <a href="#Global">globale Variablen</a> behandelt (schlie&szlig;t Befehle mit ein, die Arrays erstellen).</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Wenn der Ausf&uuml;hrungsablauf die schlie&szlig;ende Klammer in einer Funktion vor einem <a href="commands/Return.htm">Return</a> erreicht, dann endet die Funktion und gibt ihren Aufrufer einen leeren Wert (String) zur&uuml;ck. Ein leerer Wert wird auch zur&uuml;ckgegeben, sobald die Funktion den Parameter von <a href="commands/Return.htm">Return</a> direkt wegl&auml;sst.</p>
<p>Wenn eine Funktion den <a href="commands/Exit.htm">Exit</a>-Befehl verwendet, um den <a href="misc/Threads.htm">aktuellen Thread</a> zu beenden, dann erh&auml;lt der Aufrufer &uuml;berhaupt keinen R&uuml;ckgabewert. Zum Beispiel l&auml;sst die Anweisung <code>Variable := Addieren(2, 3)</code> die <em>Variable</em> unver&auml;ndert, wenn <em>Addieren()</em> vorhanden ist. Das Gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausf&uuml;hren</a> einer nicht vorhandenen Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">Errorlevel</a> &auml;ndern, um einen zus&auml;tzlichen Wert zur&uuml;ckzugeben, der sich leicht merken l&auml;sst.</p>
<p>Um eine Funktion mit beliebig vielen leeren Werten (Strings) aufzurufen, verwendet zwei Anf&uuml;hrungszeichen wie in diesem Beispiel: <code>FindeFarbe(FarbName, "")</code></p>
<p>Da ein Funktionsaufruf keinen neuen <a href="misc/Threads.htm">Thread</a> startet, werden jegliche &Auml;nderungen an Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> durch die Funktion auch f&uuml;r ihren Aufrufer wirksam.</p>
<p>Der Aufrufer einer Funktion kann ihr eine nicht vorhandene Variable oder ein nicht vorhandenes <a href="misc/Arrays.htm">Array</a>-Element &uuml;bergeben, dass bei einer Funktion n&uuml;tzlich ist, die den entsprechenden Parameter als <a href="#ByRef">ByRef</a> erwartet. Zum Beispiel wird beim Aufruf von <code>GetNextLine(BlankArray%i%)</code> die Variable <code>BlankArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellt (abh&auml;ngig davon, ob der Aufrufer sich in einer Funktion befindet und ob sie im <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> ist).</p>
<p>Wenn <a href="commands/ListVars.htm">ListVars</a> in einer Funktion verwendet wird, dann werden die <a href="#Locals">lokalen Variablen</a> der Funktion mit deren Inhalten angezeigt. Das kann helfen, ein Script zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Durch eindeutige Pr&auml;fixe f&uuml;r Variablen werden komplexe Funktionen m&ouml;glicherweise besser lesbar und pflegeleichter. Zum Beispiel bewirkt die Angabe von "p" oder "p_" im Namen eines Parameters, dass seine besondere Art sofort erkennbar ist, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso k&ouml;nnen die Pr&auml;fixe "r" oder "r_" f&uuml;r <a href="#ByRef">ByRef-Parameter</a> verwendet werden, und "s" oder "s_" f&uuml;r <a href="#static">statische Variablen</a>.</p>
<p>Der <a href="commands/Block.htm#otb">One True Brace (OTB)-Stil</a> kann gegebenenfalls verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    Return x + y
<strong>}</strong></pre>
<h2 id="include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Anweisung kann verwendet werden (<em>auch am Anfang des Scripts</em>), um Funktionen von einer externen Datei zu laden.</p>
<p>Erkl&auml;rung: Wenn der Ausf&uuml;hrungsablauf des Scripts auf eine Funktionsdefinition trifft, dann wird sie &uuml;bersprungen (mithilfe einer sofortigen Methode) und die Ausf&uuml;hrung bei der Zeile nach der schlie&szlig;enden Klammer fortgesetzt. Folglich kann die Ausf&uuml;hrung nie in einer oben genannten Funktion geraten, noch beeinflusst die Existenz von beliebig vielen Funktionen am Anfang des Scripts den <a href="Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a>.</p>
<h2><a name="lib" id="lib"></a>Funktionsbibliotheken: Standard-Bibliothek und Benutzer-Bibliothek <span class="ver">[v1.0.47+]</span> </h2>
<p>Ein Script kann eine Funktion in einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> zu verwenden. Damit das funktioniert, muss eine Datei mit demselben Namen der Funktion in einem folgenden Bibliotheksverzeichnis vorhanden sein:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Lokale Bibliothek - ben&ouml;tigt AHK_L 42+.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; Benutzer-Bibliothek.</em>
Pfad-der-laufenden-AutoHotkey.exe\Lib\  <em>; Standard-Bibliothek.</em></pre>
<p>Wenn zum Beispiel ein Script eine nicht vorhandene Funktion <em>EigeneFunktion()</em> aufruft, dann sucht das Programm nach einer Datei namens <em>EigeneFunktion.ahk</em> in der Benutzer-Bibliothek. Wenn sie dort nicht gefunden wurde, dann wird sie in der Standard-Bibliothek gesucht. Wenn sie immer noch nicht gefunden wurde und der Funktionsname ein Unterstrich enth&auml;lt (z. B. <em>EigenerPr&auml;fix_EigeneFunktion</em>), dann durchsucht das Programm beide Bibliotheken nach einer Datei namens <em>EigenerPr&auml;fix.ahk</em> und l&auml;dt sie, falls sie existiert. Dadurch kann <em>EigenerPr&auml;fix.ahk</em> sowohl die Funktion <em>EigenerPr&auml;fix_EigeneFunktion</em> als auch andere verwandte Funktionen enthalten, deren Namen mit <em>EigenerPr&auml;fix_</em> beginnen.</p>
<p><span class="ver">[AHK_L 42+]:</span> Die lokale Bibliothek wird unterst&uuml;tzt und vor der Benutzer- und Standard-Bibliothek durchsucht.</p>
<p>Obwohl eine Bibliotheksdatei generell nur eine Funktion mit demselben Namen hat, kann sie auch private Funktionen und Subroutinen enthalten, die nur durch diese Datei aufgerufen werden. Allerdings sollten solche Funktionen eindeutig benannt werden, da sie immer noch im globalen Namensraum sind; das hei&szlig;t, dass sie von &uuml;berall aufrufbar sind.</p>
<p>Wenn eine Bibliotheksdatei <a href="commands/_Include.htm">#Include</a> verwendet, dann ist das Arbeitsverzeichnis f&uuml;r #Include das Verzeichnis der Bibliotheksdatei. Damit kann eine Umleitung zu einer gr&ouml;&szlig;eren Bibliotheksdatei erzeugt werden, die diese Funktion sowie Verwandtes enth&auml;lt.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Script-Compiler (ahk2exe)</a> unterst&uuml;tzt auch Bibliotheksfunktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Wenn AutoHotkey.exe nicht vorhanden ist, dann funktioniert der Compiler immer noch, nur die Bibliotheksfunktionen werden nicht automatisch eingef&uuml;gt.</p>
<p>Eingef&uuml;gte Funktionen von einer Bibliothek funktionieren genauso gut wie andere Funktionen, da sie geladen werden, bevor das Script ausgef&uuml;hrt wird.</p>
<h2 id="BuiltIn">Interne Funktionen</h2>
<p>Jeder optionale Parameter am Ende der Parameterliste einer internen Funktion kann vollst&auml;ndig weggelassen werden. Zum Beispiel ist <code>WinExist("Unbenannt - Editor")</code> g&uuml;ltig, weil die anderen drei Parameter als leer angesehen werden.</p>
<p>Eine interne Funktion wird &uuml;berschrieben, wenn das Script eine Funktion mit selben Namen definiert. Zum Beispiel kann ein Script eine eigene WinExist()-Funktion haben, die anstelle der Standardfunktion aufgerufen wird. Allerdings ist es dem Script dann nicht mehr m&ouml;glich, die originale Funktion aufzurufen.</p>
<p>Externe Funktionen von DLL-Dateien k&ouml;nnen mittels <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
<h3>H&auml;ufig verwendete Funktionen</h3>
<p><strong><a name="FileExist"></a>FileExist(Dateimuster)</strong>: Gibt einen leeren Wert (String) zur&uuml;ck, wenn das <em>Dateimuster</em> nicht existiert (das <em>Dateimuster</em> befindet sich im <a href="Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist). Ansonsten wird ein <a href="commands/FileGetAttrib.htm#attrib">String mit Attributen</a> (eine Teilmenge von "RASHNDOCT") der ersten gefundenen Datei oder des ersten gefundenen Ordners zur&uuml;ckgegeben. Wenn die Datei keine Attribute besitzt (sehr selten), dann wird "X" zur&uuml;ckgegeben. Das <em>Dateimuster</em> kann der exakte Name einer Datei oder eines Ordners sein oder Platzhalter (* oder ?) enthalten. Da ein leerer String als "falsch" angesehen wird, kann der R&uuml;ckgabewert der Funktion immer als Boolscher Scheinwert verwendet werden. Zum Beispiel wird die Anweisung <code>If FileExist("C:\Eigene Datei.txt")</code> als wahr angesehen, wenn die Datei vorhanden ist, ansonsten als falsch. Ebenso wird die Anweisung <code>If InStr(FileExist("C:\Eigene Ordner"), "D")</code> nur als wahr angesehen, wenn die Datei <em>und</em> das Verzeichnis existiert. Dazugeh&ouml;rige Befehle: <a href="commands/IfExist.htm">IfExist</a> und <a href="commands/FileGetAttrib.htm">FileGetAttrib</a>.</p>
<p><strong><a name="GetKeyState"></a>GetKeyState(<a href="KeyList.htm">Tastenname</a> [, "P"</strong> oder <strong>"T"])</strong>: Im Gegensatz zum <a href="commands/GetKeyState.htm">GetKeyState-Befehl</a> (D f&uuml;r unten und U f&uuml;r oben) gibt diese Funktion wahr (1) f&uuml;r eine gedr&uuml;ckte Taste und falsch (0) f&uuml;r eine losgelassene Taste zur&uuml;ck. Wenn der <em><a href="KeyList.htm">Tastenname</a></em> ung&uuml;ltig ist, dann wird ein leerer String zur&uuml;ckgegeben. Siehe <a href="commands/GetKeyState.htm">GetKeyState</a> f&uuml;r weitere R&uuml;ckgabewerte und zus&auml;tzliche Informationen zur Verwendung.</p>
<p><strong><a name="InStr"></a>InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</strong>: Gibt die Position der <em>Nadel</em> im <em>Heuhaufen</em> zur&uuml;ck. Im Gegensatz zum <a href="commands/StringGetPos.htm">StringGetPos</a>-Befehl ist Position 1 das erste Zeichen, weil 0 das Synonym f&uuml;r "falsch" ist, also "nicht gefunden". Wenn der <em>Zeichengenauigkeit</em>-Parameter nicht vorhanden oder "falsch" ist, dann ist die Suche nicht von der Gro&szlig;- und Kleinschreibung abh&auml;ngig (die Abh&auml;ngigkeit h&auml;ngt vom <a href="commands/StringCaseSense.htm">StringCaseSense</a>-Befehl ab), ansonsten muss die Gro&szlig;- und Kleinschreibung exakt &uuml;bereinstimmen. Wenn die <em>Startposition</em> weggelassen wird, dann wird standardm&auml;&szlig;ig 1 verwendet (der Anfang des <em>Heuhaufens</em>). Ansonsten beginnt mit 2 die Suche im <em>Heuhaufen</em> beim zweiten Zeichen, mit 3 beim dritten Zeichen und so weiter. Wenn die <em>Startposition</em> die L&auml;nge des <em>Heuhaufens</em> &uuml;berschreitet, dann wird eine 0 zur&uuml;ckgegeben. Wenn die <em>Startposition</em> 0 oder negativ ist, dann erfolgt die Suche von rechts nach links, beginnend beim Offset am Ende. Unabh&auml;ngig von der <em>Startposition</em> bezieht sich der R&uuml;ckgabewert immer auf das erste Zeichen des <em>Heuhaufens</em>. Zum Beispiel ist die Position von "abc" in "123abc789" immer 4. Mit einer 2 im <i>Vorkommen</i> wird die Position der zweiten &Uuml;bereinstimmung zur&uuml;ckgegeben, 3 f&uuml;r die dritte &Uuml;bereinstimmung und so weiter. Verwandte Elemente: <a href="commands/RegExMatch.htm">RegExMatch()</a>, <a href="commands/IfInString.htm">IfInString</a> und <a href="commands/StringGetPos.htm">StringGetPos</a>.</p>
<p><span class="CommandSyntax"><strong>RegExMatch(Heuhaufen, NadelRegEx [, NichtZitierteAusgabevariable = "", Startposition = 1])</strong>: Siehe <a href="commands/RegExMatch.htm">RegExMatch</a></span><a href="commands/RegExMatch.htm">()</a>.</p>
<p><span class="CommandSyntax"><strong>RegExReplace(Heuhaufen, NadelRegEx [, Ersatz = "", AusgabevariableAnzahl = "", Limit = -1, Startposition = 1])</strong></span>: Siehe <span class="CommandSyntax"><a href="commands/RegExReplace.htm">RegExReplace</a></span><a href="commands/RegExReplace.htm">()</a>.</p>
<p><strong><a name="SubStr"></a>SubStr(String, Startposition [, L&auml;nge])</strong> <span class="ver">[v1.0.46+]:</span> Kopiert einen Teilstring vom <em>String</em>, beginnend bei der <em>Startposition</em> und nach rechts fortsetzend, bis die angegebene <em>L&auml;nge</em> erreicht wurde (wenn die <em>L&auml;nge</em> weggelassen wird, dann standardm&auml;&szlig;ig "alle Zeichen"). F&uuml;r die <em>Startposition</em> kann eine 1 f&uuml;r das erste Zeichen, 2 f&uuml;r das zweite Zeichen und so weiter angegeben werden (wenn die <em>Startposition</em> die L&auml;nge des <em>Strings</em> &uuml;berschreitet, dann wird ein leerer String zur&uuml;ckgegeben). Wenn die <em>Startposition</em> kleiner als 1 ist, dann wird sie als Offset vom Ende des Strings betrachtet. Zum Beispiel wird mit einer 0 das letzte Zeichen und mit -1 die letzten zwei Zeichen extrahiert (aber wenn die <em>Startposition</em> das linke Ende des Strings &uuml;berschreitet, dann beginnt das Extrahieren beim ersten Zeichen). Die <em>L&auml;nge</em> ist die maximale Anzahl an Zeichen, die extrahiert werden sollen (es werden weniger Zeichen abgerufen, sobald der verbleibende Teil des Strings zu kurz ist). Mit einer negativen <em>L&auml;nge</em> wird die Anzahl an Zeichen bestimmt, die vom Ende des zur&uuml;ckgegebenen Strings weggelassen werden (es wird ein leerer String zur&uuml;ckgegeben, wenn alle oder zu viele Zeichen weggelassen wurden sind). Verwandte Elemente: <a href="commands/RegExMatch.htm">RegExMatch()</a>, <a href="commands/StringMid.htm">StringMid</a>, <a href="commands/StringLeft.htm">StringLeft/Right</a>, <a href="commands/StringTrimLeft.htm">StringTrimLeft/Right</a>.</p>
<p><strong><a name="StrLen"></a>StrLen(String)</strong>: Gibt die L&auml;nge des <em>Strings</em> zur&uuml;ck. Wenn <em>String</em> eine Variable ist, der vorher <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a> zugewiesen wurden ist, dann wird deren Gesamtgr&ouml;&szlig;e zur&uuml;ckgegeben. Dazugeh&ouml;riger Befehl: <a href="commands/StringLen.htm">StringLen</a>.</p>
<p><strong><a name="WinActive"></a>WinActive([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des aktiven Fensters zur&uuml;ck, wenn die &Uuml;bereinstimmung die angegebenen Kriterien erf&uuml;llt. Ansonsten gibt die Funktion eine 0 zur&uuml;ck. Da alle Zahlen au&szlig;er 0 als "Wahr" angesehen werden, ist die Anweisung <code>If WinActive("Fenstertitel")</code> immer wahr, sobald der <em>Fenstertitel</em> aktiv ist. Der <em>Fenstertitel</em>-Parameter unterst&uuml;tzt ahk_id, ahk_class und andere spezielle Strings. Siehe <a href="commands/IfWinActive.htm">IfWinActive</a> f&uuml;r Details &uuml;ber diese und andere Aspekte der Fensteraktivierung. Hinweis: Die eindeutige ID des aktiven Fensters kann auch einfach mit <code>ActiveHwnd := WinExist("A")</code> abgerufen werden.</p>
<p><strong><a name="WinExist"></a>WinExist([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des ersten &uuml;bereinstimmenden Fensters als hexadezimalen Integer zur&uuml;ck (0 f&uuml;r keine). Da alle Zahlen au&szlig;er 0 als "Wahr" angesehen werden, ist die Anweisung <code>If WinExist("Fenstertitel")</code> immer wahr, sobald der <em>Fenstertitel</em> vorhanden ist. Der <em>Fenstertitel</em>-Parameter unterst&uuml;tzt ahk_id, ahk_class und andere spezielle Strings. Siehe <a href="commands/IfWinExist.htm">IfWinExist</a> f&uuml;r Details &uuml;ber diese und andere Aspekte der Fenstersuche.</p>
<h3>Verschiedene Funktionen</h3>
<p><strong><a name="Asc"></a>Asc(String)</strong>: Ermittelt den Zeichencode (eine Zahl zwischen 1 und 255 (in ANSI-Versionen) oder 65535 (in Unicode-Versionen)) f&uuml;r das erste Zeichen im <em>String</em>. Wenn der <em>String</em> leer ist, dann wird 0 zur&uuml;ckgegeben.</p>
<p><strong><a name="Chr"></a>Chr(Zahl)</strong>: Gibt ein Zeichen zur&uuml;ck, dass sich auf dem Zeichencode der <em>Zahl</em> bezieht. Wenn die <em>Zahl</em> nicht im g&uuml;ltigen Bereich des Zeichencodes ist, dann wird ein leerer String zur&uuml;ckgegeben. H&auml;ufig verwendete Zeichencodes sind 9 (Tabulator), 10 (LF), 13 (CR), 32 (Leerzeichen), 48-57 (die Zahlen von 0 bis 9), 65-90 (Gro&szlig;buchstaben von A bis Z) und 97-122 (Kleinbuchstaben von a bis z).</p>
<p><strong>DllCall()</strong>: Siehe <a href="commands/DllCall.htm">DllCall()</a>. </p>
<p><strong>FileOpen()</strong>: Erm&ouml;glicht eine objektorientierte Dateibearbeitung. Siehe <a href="commands/FileOpen.htm">FileOpen()</a> f&uuml;r mehr Details.
<p><strong><a name="Func"></a>Func(Funktionsname)</strong> <span class="ver">[v1.1.00+]:</span> Wenn der <em>Funktionsname</em> nicht direkt im Script vorhanden ist (z. B. mittels <a href="commands/_Include.htm">#Include</a> oder eines nicht-dynamischen Aufrufs einer <a href="#lib">Bibliotheksfunktion</a>), dann gibt Func() eine 0 zur&uuml;ck. Ansonsten gibt sie eine <a href="Objects.htm#Function_References">Referenz auf die Funktion</a> zur&uuml;ck. Damit kann die Funktion aufgerufen oder <a href="objects/Func.htm">Informationen</a> abgerufen werden, wie die minimale und maximale Anzahl an Parametern.</p>
<p><strong><a name="GetKeyName"></a>GetKeyName(Taste), GetKeyVK(Taste), GetKeySC(Taste)</strong> <span class="ver">[v1.1.01+]:</span> Ermittelt den Namen bzw. Text, virtuellen Tastencode oder Scancode einer Taste. Die <em>Taste</em> kann ein VK oder SC-Code sein, wie z. B. "vkA2" oder "sc01D", eine Kombination von beiden oder ein Tastenname. Zum Beispiel werden <code>GetKeyName("vk1B")</code> sowie auch <code>GetKeyName("Esc")</code> "Escape" zur&uuml;ckgeben, w&auml;hrend <code>GetKeyVK("Esc")</code> eine 27 zur&uuml;ckgibt.</p>
<p><strong><a name="IsByRef"></a>IsByRef(Variable)</strong> <span class="ver">[v1.1.01+]:</span> Gibt eine 1 zur&uuml;ck, falls die <em>Variable</em> ein ByRef-Parameter ist und der Aufrufer eine Variable &uuml;bergibt; oder 0, falls die <em>Variable</em> ein anderer Variablentyp ist.</p>
<p><strong><a name="IsFunc"></a>IsFunc(Funktionsname)</strong> <span class="ver">[v1.0.48+]:</span> Wenn der <em>Funktionsname</em> nicht direkt im Script vorhanden ist (z. B. mittels <a href="commands/_Include.htm">#Include</a> oder eines nicht-dynamischen Aufrufs einer <a href="#lib">Bibliotheksfunktion</a>), dann gibt IsFunc() eine 0 zur&uuml;ck. Ansonsten gibt sie 1 + die minimale Anzahl an Parametern zur&uuml;ck (z. B. eine 1 f&uuml;r eine Funktion ohne Parameter, eine 2 f&uuml;r eine Funktion mit einem Parameter und so weiter). Zum Beispiel werden die Anweisungen <code>If IsFunc("EigeneFunktion")</code> und <code>If IsFunc(VariableMitFunktionsnamen)</code> als wahr angesehen, wenn die Funktion vorhanden ist, ansonsten als falsch. Seit v1.1.00 kann der <i>Funktionsname</i> auch eine Funktionsreferenz anstelle eines Namens sein. Siehe auch:  <a href="#DynCall">Dynamischer Funktionsaufruf</a>, <a href="Variables.htm#ThisFunc">A_ThisFunc</a></p>
<p><strong><a name="IsLabel"></a>IsLabel(Labelname)</strong>: Gibt eine Zahl ungleich 0 zur&uuml;ck, wenn der <em>Labelname</em> im Script als <a href="commands/Gosub.htm">Subroutine</a>, <a href="Hotkeys.htm">Hotkey</a> oder <a href="Hotstrings.htm">Hotstring</a> existiert (ohne nachfolgende Doppelpunkte im <em>Labelnamen</em>). Zum Beispiel wird die Anweisung <code>If IsLabel(VariableMitLabelnamen)</code> als wahr angesehen, wenn das Label vorhanden ist, ansonsten als falsch. Dadurch k&ouml;nnen auch Laufzeitfehler unterdr&uuml;ckt werden, wenn ein dynamisches Label in Befehlen wie <a href="commands/Gosub.htm">Gosub</a>, <a href="commands/Hotkey.htm">Hotkey</a>, <a href="commands/Menu.htm">Menu</a> und <a href="commands/Gui.htm">Gui</a> angegeben wird. Siehe auch: <a href="Variables.htm#ThisLabel">A_ThisLabel</a> </p>
<p><strong><a name="IsObject"></a>IsObject()</strong> <span class="ver">[AHK_L 31+]:</span> Erkennt, ob ein Wert ein Objekt ist. Siehe auch: <a href="Objects.htm">Objekte</a>.</p>
<p><strong>ListView- und </strong><strong>TreeView-Funktionen</strong>: Siehe <a href="commands/ListView.htm">ListView</a>- und <a href="commands/TreeView.htm">TreeView</a>-Seite f&uuml;r Details.</p>
<p><strong><a name="NumGet"></a>NumGet(VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong> <span class="ver">[v1.0.47+]:</span> Gibt die bin&auml;re Zahl auf Adresse+Offset zur&uuml;ck. Die &Uuml;bergabe von <code>EigeneVar</code> in <em>VarOderAdresse</em> entspricht der &Uuml;bergabe von <code>&amp;EigeneVar</code>. Allerdings f&uuml;hrt das Weglassen von "&amp;" zu besseren Ergebnissen und stellt sicher, dass die Zieladresse <a href="commands/VarSetCapacity.htm">g&uuml;ltig</a> ist (ung&uuml;ltige Adressen geben "" zur&uuml;ck). Im Gegensatz dazu wird jeder &uuml;bergebene Wert an <em>VarOderAdresse</em>, au&szlig;er eine blo&szlig;e Variable, als eine unbearbeitete Adresse behandelt. Folglich f&uuml;hrt die Angabe von <code>EigeneVar+0</code> dazu, dass die Zahl in EigeneVar verwendet wird, anstatt die Adresse von EigeneVar selbst. F&uuml;r den <em>Typ</em> kann UInt, Int, Int64, Short, UShort, Char, UChar, Double, Float oder Ptr verwendet werden (die jedoch im Gegensatz zu DllCall von Anf&uuml;hrungszeichen umschlossen werden m&uuml;ssen, wenn sie direkt als Strings verwendet werden); siehe <a href="commands/DllCall.htm#types">DllCall-Typen</a> f&uuml;r Details. <span class="ver">[AHK_L 57+]:</span> Der <i>Offset</i> kann ganz weggelassen werden; z. B. ist <code>NumGet(Variable, "int")</code> g&uuml;ltig.</p>
<p><strong><a name="NumPut"></a>NumPut(Zahl, VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong> <span class="ver">[v1.0.47+]:</span> Speichert eine <em>Zahl</em> an die angegebene Adresse+Offset im bin&auml;ren Format und gibt die Adresse in der rechten Seite des geschriebenen Elements zur&uuml;ck. Die &Uuml;bergabe von <code>EigeneVar</code> in <em>VarOderAdresse</em> entspricht der &Uuml;bergabe von <code>&amp;EigeneVar</code>. Allerdings f&uuml;hrt das Weglassen von "&amp;" zu besseren Ergebnissen und stellt sicher, dass die Zieladresse <a href="commands/VarSetCapacity.htm">g&uuml;ltig</a> ist (ung&uuml;ltige Adressen geben "" zur&uuml;ck). Im Gegensatz dazu wird jeder &uuml;bergebene Wert an <em>VarOderAdresse</em>, au&szlig;er eine blo&szlig;e Variable, als eine unbearbeitete Adresse behandelt. Folglich f&uuml;hrt die Angabe von <code>EigeneVar+0</code> dazu, dass die Zahl in EigeneVar verwendet wird, anstatt die Adresse von EigeneVar selbst. F&uuml;r den <em>Typ</em> kann UInt, Int, Int64, Short, UShort, Char, UChar, Double, Float oder Ptr verwendet werden (die jedoch im Gegensatz zu DllCall von Anf&uuml;hrungszeichen umschlossen werden m&uuml;ssen, wenn sie direkt als Strings verwendet werden) (UInt64 wird seit v1.0.48 unterst&uuml;tzt); siehe <a href="commands/DllCall.htm#types">DllCall-Typen</a> f&uuml;r Details. Wenn eine Integer nicht in den angegebenen <em>Typ</em> passt, dann werden ihre h&ouml;chstwertigen Bytes ignoriert; z. B. wird mit <code>NumPut(257, Variable, 0, "Char")</code> die Zahl 1 gespeichert. <span class="ver">[AHK_L 57+]:</span> Der <i>Offset</i> kann ganz weggelassen werden; z. B. ist <code>NumPut(x, Variable, "int")</code> g&uuml;ltig.</p>
<p><strong>OnMessage(Nachrichtennummer [, "Funktionsname"])</strong>: &Uuml;berwacht eine Nachricht/ein Ereignis. Siehe <a href="commands/OnMessage.htm">OnMessage()</a> f&uuml;r weitere Details.</p>
<p><strong>StrGet(Adresse [, L&auml;nge] [, Kodierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert einen String von einer Speicheradresse und wandelt ihn optional in verschiedene Zeichens&auml;tze um. Siehe <a href="commands/StrPutGet.htm">StrGet()</a> f&uuml;r weitere Details.</p>
<p><strong>StrPut(String, Adresse [, L&auml;nge] [, Kodierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert einen String zu einer Speicheradresse und wandelt ihn optional in verschiedene Zeichens&auml;tze um. Siehe <a href="commands/StrPutGet.htm">StrPut()</a> f&uuml;r weitere Details.</p>
<p><strong>RegisterCallback()</strong>: Siehe <a href="commands/RegisterCallback.htm">RegisterCallback()</a>.</p>
<p><strong>Trim()</strong> <span class="ver">[AHK_L 31+]:</span> Siehe <a href="commands/Trim.htm">Trim()</a>.</p>
<p><strong>VarSetCapacity(Variablenname [, Ben&ouml;tigteKapazit&auml;t, F&uuml;llbyte])</strong>: Vergr&ouml;&szlig;ert die Aufnahmekapazit&auml;t einer Variable oder gibt deren Speicher frei. Siehe <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> f&uuml;r Details.</p>
<h3 id="Math">Allgemeine Mathematik </h3>
<p>Hinweis: Mathematische Funktionen geben generell einen leeren Wert (String) zur&uuml;ck, wenn ein beliebiger eingehender Parameter nicht numerisch ist.</p>
<p><strong><a name="Abs"></a>Abs(Zahl)</strong>: Gibt den absoluten Wert von der <em>Zahl</em> zur&uuml;ck. Der R&uuml;ckgabewert ist der selbe Typ wie die <em>Zahl</em> (Integer oder Flie&szlig;kommazahl).</p>
<p><strong><a name="Ceil"></a>Ceil</strong><strong>(Zahl)</strong>: Gibt eine <em>Zahl</em> zur&uuml;ck, welche auf den n&auml;chsten Integer aufgerundet ist (ohne .00-Suffix). Zum Beispiel ergibt <code>Ceil(1.2)</code> eine 2 und <code>Ceil(-1.2)</code> eine -1.</p>
<p><strong><a name="Exp"></a>Exp(N)</strong>: Gibt <em>e</em> zur&uuml;ck (ungef&auml;hr 2.71828182845905), potenziert mit <em>N</em>. <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Um andere Zahlen als <em>e</em> zu potenzieren, verwendet den <a href="Variables.htm#pow">**-Operator</a>.</p>
<p><strong><a name="Floor"></a>Floor(Zahl)</strong>: Gibt eine <em>Zahl</em> zur&uuml;ck, welche auf den n&auml;chsten Integer abgerundet ist (ohne .00-Suffix). Zum Beispiel ergibt <code>Floor(1.2)</code> eine 1 und <code>Floor(-1.2)</code> eine -2.</p>
<p><strong><a name="Log"></a>Log(Zahl)</strong>: Gibt den Logarithmus (Basis 10) von der <em>Zahl</em> zur&uuml;ck. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Flie&szlig;kommazahl</a>. Wenn die <em>Zahl</em> negativ ist, dann wird ein leerer String zur&uuml;ckgegeben.</p>
<p><strong><a name="Ln"></a>Ln(Zahl)</strong>: Ermittelt den Logarithmus (Basis e) von der <em>Zahl</em>.  Das Ergebnis ist eine <a href="commands/SetFormat.htm">Flie&szlig;kommazahl</a>. Wenn die <em>Zahl</em> negativ ist, dann wird ein leerer String zur&uuml;ckgegeben.</p>
<p><strong><a name="Mod"></a>Mod(Dividend, Divisor)</strong>: Modulo. Gibt den Rest zur&uuml;ck, wenn der <em>Dividend</em> durch den <em>Divisor</em> geteilt wird. Das Vorzeichen des Ergebnisses entspricht dem Vorzeichen des ersten Parameters. Zum Beispiel ergibt sowohl <code>mod(5, 3)</code> als auch <code>mod(5, -3)</code> eine 2, aber <code>mod(-5, 3)</code> und <code>mod(-5, -3)</code> eine -2. Wenn einer der beiden Parameter eine Flie&szlig;kommazahl ist, dann ist das Ergebnis ebenfalls eine Flie&szlig;kommazahl. Zum Beispiel ergibt <code>mod(5.0, 3)</code> eine 2.0 und <code>mod(5, 3.5)</code> eine 1.5. Wenn der zweite Parameter eine 0 ist, dann gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
<p><strong><a name="Round"></a>Round(Zahl [, N])</strong>: Wenn <em>N</em> nicht vorhanden oder eine 0 ist, dann wird die <em>Zahl</em> auf den n&auml;chsten Integer gerundet. Wenn <em>N</em> eine positive Zahl ist, dann wird die <em>Zahl</em> auf <em>N</em> Dezimalstellen gerundet. Wenn <em>N</em> negativ ist, dann wird die <em>Zahl auf N</em> Stellen nach links gerundet. Zum Beispiel ergibt <code>Round(345, -1)</code> eine 350 und Round(345, -2) eine 300. Im Gegensatz zu <a href="commands/Transform.htm">Transform Round</a> hat das Ergebnis keinen .000-Suffix, sobald <em>N</em> nicht vorhanden oder kleiner als 1 ist. Seit v1.0.44.01 werden bei einem <em>N</em>-Wert gr&ouml;&szlig;er 0 genau <em>N</em> Dezimalstellen angezeigt, anstatt <a href="commands/SetFormat.htm">SetFormat</a> zu beachten. Um das zu verhindern, wendet eine weitere mathematische Operation auf dem R&uuml;ckgabewert von Round() an; zum Beispiel: <code>Round(3.333, 1)<strong>+0</strong></code>.</p>
<p><strong><a name="Sqrt"></a>Sqrt(Zahl)</strong>: Gibt die Quadratwurzel von der <em>Zahl</em> zur&uuml;ck.  Das Ergebnis ist eine <a href="commands/SetFormat.htm">Flie&szlig;kommazahl</a>. Wenn die <em>Zahl</em> negativ ist, dann gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
<h3>Trigonometrie</h3>
<p><strong><a name="Sin"></a><a name="Cos"></a><a name="Tan"></a>Sin(Zahl)</strong> | <strong>Cos(Zahl)</strong> | <strong>Tan(Zahl) </strong>: Gibt den trigonometrischen Sinus|Kosinus|Tangens von der <em>Zahl</em> zur&uuml;ck. Die <em>Zahl</em> muss als Bogenma&szlig; angegeben werden.</p>
<p><strong><a name="ASin"></a>ASin(Zahl)</strong>: Gibt den Arkussinus (die Zahl, deren Sinus die <em>Zahl</em> ist) als Bogenma&szlig; zur&uuml;ck. Wenn die <em>Zahl</em> kleiner als -1 oder gr&ouml;&szlig;er als 1 ist, dann gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
<p><strong><a name="ACos"></a>ACos(Zahl)</strong>: Gibt den Arkuskosinus (die Zahl, deren Kosinus die <em>Zahl</em> ist) als Bogenma&szlig; zur&uuml;ck. Wenn die <em>Zahl</em> kleiner als -1 oder gr&ouml;&szlig;er als 1 ist, dann gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
<p><strong><a name="ATan"></a>ATan</strong><strong>(Zahl)</strong>: Gibt den Arkustangens (die Zahl, deren Tangens die <em>Zahl</em> ist) als Bogenma&szlig; zur&uuml;ck.</p>
<p><strong>Hinweis:</strong> Um Bogenma&szlig; in Grad umzuwandeln, multipliziert es mit 180/pi (ungef&auml;hr 57.29578). Um Grad in Bogenma&szlig; umzuwandeln, multipliziert es mit pi/180 (ungef&auml;hr 0.01745329252). Der Wert von pi (ungef&auml;hr 3,141592653589793) ist viermal der Arcustangens von 1.</p>
<h3>Weitere Funktionen</h3>
<p><a href="http://file.autohotkey.net/Titan/functions.html">Befehlsfunktionen von Titan</a>: Erm&ouml;glicht eine aufrufbare Funktion f&uuml;r jeden AutoHotkey-Befehl mit einer Ausgabevariable. Diese Bibliothek kann mithilfe von <a href="commands/_Include.htm">#Include</a> in jedem Script eingef&uuml;gt werden.</p>
</body>
</html>