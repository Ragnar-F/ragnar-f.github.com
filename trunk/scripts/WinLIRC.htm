<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>WinLIRC-Client</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="alternate" type="application/rss+xml" title="AutoHotkey Forum RSS" href="/forum/rss.php">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<meta name="description" content="This open-source WinLIRC client can perform keystrokes, mouse clicks, and other actions in response to buttons you press on your remote control.">
</head>
<body>

<h1>WinLIRC-Client</h1>

<p> Dieses Script empf&auml;ngt Nachrichten von <a href="http://winlirc.sourceforge.net">WinLIRC</a>, sobald eine Taste der Fernbedienung gedr&uuml;ckt wird. Au&szlig;erdem kann damit Winamp, Windows Media Player und so weiter automatisiert werden. Es ist einfach zu konfigurieren. Wenn zum Beispiel WinLIRC eine Schaltfl&auml;che namens "VolUp" auf der Fernbedienung erkennt, dann wird ein Label namens VolUp erstellt und der Befehl "SoundSet +5" darunter verwendet, um die Lautst&auml;rke der Soundkarte um 5 % zu erh&ouml;hen.
</p>
<p><a href="WinLIRC.ahk">Dieses Script herunterladen</a> &nbsp;| &nbsp;<a href="index.htm">Andere Beispiel-Scripts</a> &nbsp;| &nbsp;<a href="http://www.autohotkey.com">Home</a></p>

<pre class="NoIndent"><em>; Hier die Schritte, um dieses Script zu verwenden:
; 1) Konfiguriert WinLIRC, damit die Fernbedienung und deren Tasten erkannt werden.
;    WinLIRC kann auf <a href="http://winlirc.sourceforge.net">http://winlirc.sourceforge.net</a> gefunden werden
; 2) Bearbeitet den WinLIRC-Pfad, die Adresse und den Port im unteren Konfigurationsbereich.
; 3) Startet das Script. Es wird je nach Bedarf der WinLIRC-Server gestartet.
; 4) Dr&uuml;ckt einige Tasten auf der Fernbedienung. Ein kleines Fenster wird
;    angezeigt, mit dem Namen jeder gedr&uuml;ckten Taste.
; 5) Konfiguriert die Tasten, damit sie Tastatureingaben und Mausklicks an
;    Fenstern wie Winamp, Media Player und so weiter senden. Siehe untere Beispiele.</em>

<em>; Dieses Script ben&ouml;tigt AutoHotkey 1.0.38.04 oder h&ouml;her.
; &Auml;NDERUNGEN
; 2. M&auml;rz 2007:
; - Zuverl&auml;ssigkeit mithilfe von "Critical" in ReceiveData() verbessert.
; 5. Oktober 2005:
; - Winsock-Warnmeldung "10054" beim Herunterfahren/Abmelden des Systems beseitigt.
; - Option "DelayBetweenButtonRepeats" hinzugef&uuml;gt, um die Wiederholungsgeschwindigkeit zu drosseln.</em>

<em>; -------------------------------------------------
; KONFIGURATIONSBEREICH: Hier die Einstellungen vornehmen.
; -------------------------------------------------
; Einige Fernbedienungen wiederholen schnell das Signal, w&auml;hrend
; eine Taste gedr&uuml;ckt gehalten wird. Das macht es schwierig, die Fernbedienung dazu zu bringen,
; nur ein Signal zu senden. Die folgende Einstellung l&ouml;st dieses Problem, indem wiederholende Signale
; ignoriert werden, bis die angegebene Zeit erreicht ist. 200 ist meistens gut genug.  Setzt sie
; auf 0, um diese Funktion zu deaktivieren.</em>
DelayBetweenButtonRepeats = 200

<em>; Gebt den Pfad zu WinLIRC an, wie z. B. C:\WinLIRC\winlirc.exe</em>
WinLIRC_Path = %A_ProgramFiles%\WinLIRC\winlirc.exe

<em>; Bestimmt die Adresse und den Port von WinLIRC. H&auml;ufig wird 127.0.0.1 (localhost) und 8765 verwendet.</em>
WinLIRC_Address = 127.0.0.1
WinLIRC_Port = 8765

<em>; &Auml;ndert nicht die folgenden zwei Zeilen. &Uuml;berspringt sie einfach.</em>
Gosub WinLIRC_Init
return

<em>; --------------------------------------------
; AKTIONEN F&Uuml;R DIE FERNBEDIENUNGSTASTEN ZUWEISEN
; --------------------------------------------
; Konfiguriert die unten genannten Tasten der Fernbedienung. Verwendet die Tastennamen
; von WinLIRC, die in der WinLIRC-Konfigurationsdatei (.cf file) gefunden
; werden k&ouml;nnen -- oder dr&uuml;ckt eine beliebige Taste auf der Fernbedienung,
; um die Tastennamen in einem kleinen Fenster kurz anzuzeigen.
;
; Hier dazu einige Beispiele. Sie k&ouml;nnen je nach Belieben &uuml;berarbeitet und
; gel&ouml;scht werden.</em>

VolUp:
SoundSet +5  <em>; Gesamtlautst&auml;rke um 5 % erh&ouml;hen. In Vista oder h&ouml;her sollte diese Zeile ersetzt werden mit: Send {Volume_Up}</em>
return

VolDown:
SoundSet -5  <em>; Gesamtlautst&auml;rke um 5 % verringern. In Vista oder h&ouml;her sollte diese Zeile ersetzt werden mit: Send {Volume_Down}</em>
return

ChUp:
WinGetClass, ActiveClass, A
if ActiveClass in Winamp v1.x,Winamp PE  <em>; Winamp ist aktiv.</em>
    Send {right}  <em>; Die rechte Pfeiltaste senden.</em>
else  <em>; Irgendein anderes Fenster ist aktiv.</em>
    Send {WheelUp}  <em>; Das Mausrad eine Rasterung nach oben drehen.</em>
return

ChDown:
WinGetClass, ActiveClass, A
if ActiveClass in Winamp v1.x,Winamp PE  <em>; Winamp ist aktiv.</em>
    Send {left}  <em>; Die linke Pfeiltaste senden.</em>
else  <em>; Irgendein anderes Fenster ist aktiv.</em>
    Send {WheelDown}  <em>; Das Mausrad eine Rasterung nach unten drehen.</em>
return

Menu:
IfWinExist, Unbenannt - Editor
{
    WinActivate
}
else
{
    Run, Notepad
    WinWait, Unbenannt - Editor
    WinActivate
}
Send Hier einige gesendete Tastatureingaben im Editor.{Enter}
return

<em>; Die oben genannten Beispiele geben einen Eindruck davon, wie h&auml;ufige Aufgaben durchgef&uuml;hrt werden.
; Um die Grundlagen von AutoHotkey zu lernen, siehe Schnellstart-Tutorial
; auf <a href="http://www.autohotkey.com/docs/Tutorial.htm">http://www.autohotkey.com/docs/Tutorial.htm</a></em>

<em>; ----------------------------
; ENDE DES KONFIGURATIONSBEREICHS
; ----------------------------
; Hier danach keine &Auml;nderungen durchf&uuml;hren, es sei denn,
; die allgemeine Funktionalit&auml;t des Scripts soll ge&auml;ndert werden.</em>

WinLIRC_Init:
OnExit, ExitSub  <em>; Um die Verbindung zu beenden.</em>

<em>; WinLIRC starten, falls noch nicht getan:</em>
Process, Exist, winlirc.exe
if not ErrorLevel  <em>; Keine PID f&uuml;r WinLIRC gefunden.</em>
{
    IfNotExist, %WinLIRC_Path%
    {
        MsgBox Die Datei "%WinLIRC_Path%" ist nicht vorhanden. Bitte diesen Script bearbeiten, um den Standort festzulegen.
        ExitApp
    }
    Run %WinLIRC_Path%
    Sleep 200  <em>; Gibt WinLIRC Zeit, zu starten (wahrscheinlich nie notwendig, nur zur Sicherheit).</em>
}

<em>; Mit WinLIRC verbinden (oder beliebiger Server-Typ f&uuml;r diese Angelegenheit):</em>
socket := ConnectToAddress(WinLIRC_Address, WinLIRC_Port)
if socket = -1  <em>; Verbindung fehlgeschlagen (der Grund wird bereits angezeigt).</em>
    ExitApp

<em>; Das Hauptfenster vom Script finden:</em>
Process, Exist  <em>; Dadurch enth&auml;lt ErrorLevel die PID des Scripts (wird auf diese Weise durchgef&uuml;hrt, um kompilierte Scripts zu unterst&uuml;tzen).</em>
DetectHiddenWindows On
ScriptMainWindowId := WinExist("ahk_class AutoHotkey ahk_pid " . ErrorLevel)
DetectHiddenWindows Off

<em>; Sobald das Betriebssystem dem Script meldet, dass eingehende Daten darauf warten,
; empfangen zu werden, wird eine Funktion ausgef&uuml;hrt, um die Daten zu lesen:</em>
NotificationMsg = 0x5555  <em>; Eine beliebige Nachrichtenzahl, aber gr&ouml;&szlig;er als 0x1000.</em>
OnMessage(NotificationMsg, "ReceiveData")

<em>; Die Verbindung einstellen, um den Script zu benachrichtigen, sobald neue Daten eingetroffen sind.
; Dadurch wird verhindert, dass die Verbindung abgefragt werden muss, daher verringert sich der Ressourcenverbrauch.</em>
FD_READ = 1     <em>; Wird empfangen, falls lesbare Daten verf&uuml;gbar sind.</em>
FD_CLOSE = 32   <em>; Wird empfangen, falls die Verbindung unterbrochen wurde.</em>
if DllCall("Ws2_32\WSAAsyncSelect", "UInt", socket, "UInt", ScriptMainWindowId, "UInt", NotificationMsg, "Int", FD_READ|FD_CLOSE)
{
    MsgBox % "WSAAsyncSelect() indicated Winsock error " . DllCall("Ws2_32\WSAGetLastError")
    ExitApp
}
return



ConnectToAddress(IPAddress, Port)
<em>; Damit k&ouml;nnen die meisten TCP-Server angesteuert werden, nicht nur WinLIRC.
; Gibt bei Misserfolg eine -1 (INVALID_SOCKET) und bei Erfolg die Sockel-ID zur&uuml;ck.</em>
{
    VarSetCapacity(wsaData, 400)
    result := DllCall("Ws2_32\WSAStartup", "UShort", 0x0002, "UInt", &wsaData) <em>; Winsock 2.0 (0x0002) anfordern</em>
    <em>; Da WSAStartup() wahrscheinlich die erste aufgerufene Winsock-Funktion des Scripts ist,</em>
    <em>; wird ErrorLevel &uuml;berpr&uuml;ft, ob Winsock 2.0 verf&uuml;gbar ist:</em>
    if ErrorLevel
    {
        MsgBox WSAStartup() konnte aufgrund des Fehlers %ErrorLevel% nicht aufgerufen werden. Es wird Winsock 2.0 oder h&ouml;her ben&ouml;tigt.
        return -1
    }
    if result  <em>; Ungleich 0, das hei&szlig;t Misserfolg (die meisten Winsock-Funktionen geben bei Erfolg eine 0 zur&uuml;ck).</em>
    {
        MsgBox % "WSAStartup() kennzeichnet Winsock-Fehler " . DllCall("Ws2_32\WSAGetLastError")
        return -1
    }

    AF_INET = 2
    SOCK_STREAM = 1
    IPPROTO_TCP = 6
    socket := DllCall("Ws2_32\socket", "Int", AF_INET, "Int", SOCK_STREAM, "Int", IPPROTO_TCP)
    if socket = -1
    {
        MsgBox % "socket() kennzeichnet Winsock-Fehler " . DllCall("Ws2_32\WSAGetLastError")
        return -1
    }

    <em>; F&uuml;r die Verbindung vorbereiten:</em>
    SizeOfSocketAddress = 16
    VarSetCapacity(SocketAddress, SizeOfSocketAddress)
    InsertInteger(2, SocketAddress, 0, AF_INET)   <em>; sin_family</em>
    InsertInteger(DllCall("Ws2_32\htons", "UShort", Port), SocketAddress, 2, 2)   <em>; sin_port</em>
    InsertInteger(DllCall("Ws2_32\inet_addr", "AStr", IPAddress), SocketAddress, 4, 4)   <em>; sin_addr.s_addr</em>

    <em>; Verbindungsversuch:</em>
    if DllCall("Ws2_32\connect", "UInt", socket, "UInt", &SocketAddress, "Int", SizeOfSocketAddress)
    {
        MsgBox % "connect() kennzeichnet Winsock-Fehler " . DllCall("Ws2_32\WSAGetLastError") . ". Wird WinLIRC ausgef&uuml;hrt?"
        return -1
    }
    return socket  <em>; Kennzeichnet Erfolg, indem eine g&uuml;ltige Sockel-ID anstelle von -1 zur&uuml;ckgegeben wird.</em>
}



ReceiveData(wParam, lParam)
<em>; Durch OnMessage() wird diese Funktion automatisch aufgerufen, sobald neue Daten
; bei der Verbindung eingetroffen sind.  Sie lie&szlig;t die Daten von WinLIRC und f&uuml;hrt entsprechende Aktionen abh&auml;ngig
; vom Inhalt durch.</em>
{
    Critical  <em>; Verhindert, dass die Nachricht von einer anderen Nachricht verworfen wird, da der Thread bereits ausgef&uuml;hrt wird.</em>
    socket := wParam
    ReceivedDataSize = 4096  <em>; Hoher Wert, falls viele Daten zwischengespeichert werden, weil eine Verz&ouml;gerung beim Verarbeiten der vorherigen Daten auftreten kann.</em>

    VarSetCapacity(ReceivedData, ReceivedDataSize, 0)  <em>; Mit einer 0 im letzten Parameter wird der String terminiert, damit er f&uuml;r recv() verwendet werden kann.</em>
    ReceivedDataLength := DllCall("Ws2_32\recv", "UInt", socket, "Str", ReceivedData, "Int", ReceivedDataSize, "Int", 0)
    if ReceivedDataLength = 0  <em>; Die Verbindung wurde ordnungsgem&auml;&szlig; unterbrochen, vielleicht weil WinLIRC beendet wurde.</em>
        ExitApp  <em>; Die OnExit-Subroutine wird f&uuml;r uns WSACleanup() aufrufen.</em>
    if ReceivedDataLength = -1
    {
        WinsockError := DllCall("Ws2_32\WSAGetLastError")
        if WinsockError = 10035  <em>; WSAEWOULDBLOCK, das hei&szlig;t "keine zu lesenden Daten mehr".</em>
            return 1
        if WinsockError &lt;&gt; 10054 <em>; WSAECONNRESET, dass passieren kann, wenn WinLIRC durch das Herunterfahren/Abmelden des Systems geschlossen wird.</em>
            <em>; Da das ein unerwarteter Fehler ist, muss er gemeldet werden.  Au&szlig;erdem beenden, um eine Endlosschleife zu verhindern.</em>
            MsgBox % "recv() kennzeichnet Winsock-Fehler " . WinsockError
        ExitApp  <em>; Die OnExit-Subroutine wird f&uuml;r uns WSACleanup() aufrufen.</em>
    }
    <em>; Ansonsten die empfangenen Daten bearbeiten. Tests zeigen, dass es m&ouml;glich ist, mehr als eine Zeile gleichzeitig zu erhalten</em>
    <em>; (selbst beim direkten Senden eines IR-Signals), wodurch die folgende Mehthode richtig behandelt wird.</em>
    <em>; Empfangene Daten von WinLIRC sehen z. B. wie folgt aus (siehe Dokumentation zu WinLIRC f&uuml;r Details):</em>
    <em>; 0000000000eab154 00 Tastenname Fernbedienungsname</em>
    Loop, parse, ReceivedData, `n, `r
    {
        if A_LoopField in ,BEGIN,SIGHUP,END  <em>; Leere Zeilen und Startnachricht von WinLIRC ignorieren.</em>
            continue
        ButtonName =  <em>; Leer machen, falls weniger als 3 Felder unten gefunden werden.</em>
        Loop, parse, A_LoopField, %A_Space%  <em>; Tastenname extrahieren, der sich im dritten Feld befindet.</em>
            if A_Index = 3
                ButtonName := A_LoopField
        global DelayBetweenButtonRepeats  <em>; Globale Variablen deklarieren, damit sie f&uuml;r diese Funktion verf&uuml;gbar sind.</em>
        static PrevButtonName, PrevButtonTime, RepeatCount  <em>; Diese Variablen merken sich ihre Werte zwischen den Aufrufen.</em>
        if (ButtonName != PrevButtonName || A_TickCount - PrevButtonTime > DelayBetweenButtonRepeats)
        {
            if IsLabel(ButtonName)  <em>; Es ist eine Subroutine vorhanden, die sich auf diese Taste bezieht.</em>
                Gosub %ButtonName%  <em>; Die Subroutine starten.</em>
            else <em>; Falls keine entsprechende Subroutine vorhanden ist, kurz anzeigen, welche Taste gedr&uuml;ckt wurde.</em>
            {
                if (ButtonName == PrevButtonName)
                    RepeatCount += 1
                else
                    RepeatCount = 1
                SplashTextOn, 150, 20, Taste von WinLIRC, %ButtonName% (%RepeatCount%)
                SetTimer, SplashOff, 3000  <em>; Dadurch k&ouml;nnen mehr Signale beim Anzeigen des Fensters verarbeitet werden.</em>
            }
            PrevButtonName := ButtonName
            PrevButtonTime := A_TickCount
        }
    }
    return 1  <em>; Dem Programm melden, dass die Nachricht nicht weiter verarbeitet werden muss.</em>
}



SplashOff:
SplashTextOff
SetTimer, SplashOff, Off
return



InsertInteger(pInteger, ByRef pDest, pOffset = 0, pSize = 4)
<em>; Der Aufrufer muss sicherstellen, das pDest ausreichend Kapazit&auml;t hat.  Um vorhandene Inhalte in pDest zu erhalten,
; wird nur die Anzahl an Bytes in pSize beginnend bei pOffset ge&auml;ndert.</em>
{
    Loop %pSize%  <em>; Jeden Byte im Integer als unbearbeitete Bin&auml;rdaten in die Struktur kopieren.</em>
        DllCall("RtlFillMemory", "UInt", &pDest + pOffset + A_Index-1, "UInt", 1, "UChar", pInteger >> 8*(A_Index-1) & 0xFF)
}



ExitSub:  <em>; Diese Subroutine wird automatisch aufgerufen, falls das Script aus irgendeinem Grund beendet wird.
; MSDN: "Jeder offene Sockel wird mit WSACleanup zur&uuml;ckgesetzt und automatisch
; freigegeben, als wurde closesocket aufgerufen."</em>
DllCall("Ws2_32\WSACleanup")
ExitApp

</pre>
</body>
</html>