<!DOCTYPE HTML>
<html>
<head>
<title>Objekte</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/jquery.js" type="text/javascript"></script>
<script src="static/tree.jquery.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/content.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> ist in AutoHotkey ein abstrakter Datentyp, das drei Grundfunktionen bereitstellt:</p>
<ul>
  <li>GET - Abrufen eines Wertes.</li>
  <li>SET - Setzen eines Wertes.</li>
  <li>CALL - Aufrufen einer Methode (eine Funktion, die das Zielobjekt beeinflusst).</li>
</ul>
<p>Ein Objekt<i>verweis</i> ist ein Pointer oder Handle, der auf ein bestimmtes Objekt verweist. Objektverweise können, wie Strings und Zahlen auch, in Variablen gespeichert werden, an Funktionen übergeben oder von Funktionen zurückgegeben werden und in Objekten gespeichert werden. Hat man einen Verweis von einer Variable in einer anderen gespeichert (z. B. mit <code>x := y</code>), würden beide Variablen auf das gleiche Objekt verweisen.</p>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Es gibt folgende Objekttypen:</p>
<ul>
  <li><a href="objects/Object.htm"><b>Object</b></a> - scriptfähiges assoziatives Array.</li>
  <li><a href="objects/File.htm">File</a> - stellt eine Schnittstelle für die Dateibearbeitung bereit.</li>
  <li><a href="objects/Func.htm">Func</a> - eine Funktion.</li>
  <li><a href="commands/ComObjCreate.htm">ComObject</a> - Wrappt eine IDispatch-Schnittstelle (ein COM oder "Automatisierungsobjekt").</li>
</ul>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlagen</a> - <a href="#Usage_Simple_Arrays">Einfache Arrays</a>, <a href="#Usage_Associative_Arrays">Assoziative Arrays</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a>, <a href="#Usage_Remarks">Bemerkungen</a></li>
  <li><a href="#Extended_Usage">Erweiterte Grundlagen</a> - <a href="#Function_References">Funktionsverweise</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>, <a href="#Usage_Arrays_of_Functions">Arrays mit Funktionen</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#Custom_Prototypes">Prototypen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Meta-Funktionen</a></li>
  <li><a href="#Default_Base_Object">Standard-base-Objekt</a> - <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#Implementation_Pointers">Pointer auf Objekte</a></li>
</ul>

<a name="Syntax"></a><h2 id="Usage">Grundlagen</h2>

<h3 id="Usage_Simple_Arrays">Einfache Arrays</h3>
<p>Erstellen eines Arrays:</p>
<pre>Array := [Element1, Element2, ..., ElementN]
Array := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Index]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Index] := Wert</pre>
<p>Anfügen eines Elements:</p>
<pre>Array.<a href="objects/Object.htm#Insert">Insert</a>(Wert)</pre>
<p>Einfügen beliebig vieler Elemente ab einem bestimmten Index:</p>
<pre>Array.<a href="objects/Object.htm#Insert">Insert</a>(Index, Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Remove">Remove</a>(Index)</pre>
<p>Sofern Array nicht leer ist, können <a href="objects/Object.htm#MinMaxIndex">MinIndex</a> und <a href="objects/Object.htm#MinMaxIndex">MaxIndex</a> den niedrigsten und höchsten Index vom Array zurückgeben. Während der niedrigste Index fast immer 1 ist, wird MaxIndex üblicherweise die Anzahl der Elemente zurückgeben. Um die Inhalte des Arrays zu durchlaufen, benutzt man entweder den Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>array := ["eins", "zwei", "drei"]

<em>; Iteriert von 1 bis Anzahl der Elemente:</em>
<a href="commands/Loop.htm">Loop</a> % array.MaxIndex()
    MsgBox % array[A_Index]

<em>; Enumeriert die Inhalte des Arrays:</em>
<a href="commands/For.htm">For</a> index, wert in array
    MsgBox % "Element " index " ist '" wert "'"
</pre>

<a name="Arrays"></a><h3 id="Usage_Associative_Arrays">Assoziative Arrays</h3>
<p>Ein assoziatives Array ist ein Objekt, das mehrere eindeutige Keys (Schlüssel) und mehrere Values (Werte) enthält, die jeweils miteinander verbunden sind. Keys können Strings, Integer oder Objekte sein. Values beliebige Typen. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>Array := {KeyA: ValueA, KeyB: ValueB, ..., KeyZ: WertZ}
Array := Object("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Wenn man die <code>{Key:Value}</code>-Schreibweise verwendet, können die Anführungszeichen beim Key weggelassen werden, sofern dieser nur aus Wortzeichen besteht. Jeder Ausdruck kann als Key verwendet werden. Um eine Variable als Key zu benutzen, muss es mit runden Klammern umschlossen werden. Zum Beispiel wäre sowohl <code>{(KeyVar): Value}</code> als auch <code>{GetKey(): Value}</code> eine gültige Angabe.</p>
<p>Abrufen eines Elements:</p>
<pre>Value := Array[Key]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Key] := Value</pre>
<p>Entfernen eines Elements:</p>
<pre>RemovedValue := Array.<a href="objects/Object.htm#Remove">Remove</a>(Key)</pre>
<p>Enumerieren von Elementen:</p>
<pre>array := {zehn: 10, zwanzig: 20, dreißig: 30}
<a href="commands/For.htm">For</a> key, value in array
    MsgBox %key% = %value%</pre>
<p>Assoziative Arrays können klein gehalten werden - zum Beispiel enthält <code>{1: "a", 1000: "b"}</code> nur zwei Key-Value-Paare, nicht 1000.</p>
<p id="same_thing">Inzwischen ist dir vielleicht schon aufgefallen, dass sich die Syntaxen von assoziativen Arrays und von einfachen Arrays sehr ähneln. In der Tat sind sie beide dasselbe in v1.x. Das Behandeln von <code>[]</code> als einfaches lineares Array stellt sicher, dass dessen Rolle eindeutig zugeordnet werden kann, und erhöht die Chance, dass dein Script auch mit einer zukünftigen Version von AutoHotkey noch funktionieren wird, bei der die Implementierung geändert wurde.</p>

<h3 id="Usage_Objects">Objekte</h3>
<p>Abrufen einer Eigenschaft:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<p>Setzen einer Eigenschaft:</p>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Aufrufen einer Methode:</p>
<pre>Rückgabewert := Objekt.Methode(Parameter)</pre>
<p>Aufrufen einer Methode mit einem errechneten Methodennamen:</p>
<pre>Rückgabewert := Object[Methodenname](Parameter)</pre>
<p>Einige Eigenschaften von COM-Objekten und benutzerdefinierten Objekten können Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Parameter]
Objekt.Eigenschaft[Parameter] := Wert</pre>
<p><strong>Siehe auch</strong>: <a href="objects/Object.htm">Objekt</a>, <a href="objects/File.htm">File-Objekt</a>, <a href="objects/Func.htm">Func-Objekt</a>, <a href="commands/ComObjCreate.htm">COM-Objekt</a></p>
<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Zurzeit wird <code><span class="dull">x</span>.y[z]<span class="dull">()</span></code> als <code><span class="dull">x</span>["y", z]<span class="dull">()</span></code> behandelt, was aber nicht unterstützt wird. Als Übergangslösung kann man <code><span class="red">(</span><span class="dull">x.y</span><span class="red">)</span>[z]()</code> benutzen, das <code>x.y</code>  zuerst auswerten und dann das Ergebnis als Ziel des Methodenaufrufs verwenden würde. Beachte, dass bei <code>x.y[z].()</code> diese Einschränkung nicht zutrifft, weil es wie <code>(x.y[z]).()</code> ausgewertet werden würde.</li></ul>

<h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
<p>Scripts geben Objekte nicht explizit frei. Sobald der letzte Verweis auf ein Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Ein Verweis, der in einer Variable gespeichert ist, wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt den letzten Verweis frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>In diesem Zusammenhang wird ein Verweis, der in einem Feld eines anderen Objekts gespeichert ist, freigegeben, wenn dieses Feld irgendeinen anderen Wert zugewiesen bekommt oder vom Objekt entfernt wird. Dies gilt auch für Arrays, weil sie eigentlich Objekte sind.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.Remove(1)  <em>; Entfernt und gibt das zweite Objekt frei.</em></pre>
<p id="Circular_References">Da alle Verweise auf ein Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn beispielsweise <code>x.child</code> auf <code>y</code> verweist und <code>y.parent</code> auf <code>x</code> verweist, würde es nicht genügen, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch einen Verweis auf das Child-Objekt enthält, und umgekehrt. Um diese Situation in den Griff zu bekommen, muss der Zirkelbezug entfernt werden.</p>
<pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Ohne die obige Zeile würde dies hier die Objekte nicht freigeben.</em>
</pre>
<p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h3 id="Usage_Remarks">Bemerkungen</h3>

<h4>Syntax</h4>
<p>Alle Objektarten unterstützen sowohl die Array-Syntax (eckige Klammern) als auch die Objekt-Syntax (Punkte).</p>
<p>Darüber hinaus können Objektverweise auch in Ausdrücken verwendet werden:</p>
<ul>
  <li>Vergleicht man ein Objektverweis mit irgendeinem anderen Wert per <code>= == != &lt;&gt;</code>, werden sie nur als gleich angesehen, wenn beide Werte auf dasselbe Objekt verweisen.</li>
  <li>Objekte werden immer als <i>True</i> angesehen, falls ein logischer Wert erforderlich ist, wie z. B. in <code>if obj</code>, <code>!obj</code> oder <code>obj ? x : y</code>.</li>
  <li>Eine Objektadresse kann mithilfe des <code>&amp;</code>-Operators abgerufen werden. Dies identifiziert eindeutig das Objekt vom Punkt seiner Erstellung bis zu dem Moment, wo sein letzter Verweis <a href="#Refs">freigegeben</a> wird.</li>
</ul>
<p>Dort, wo ein Objekt nicht erwartet wird, wird das Objekt als leerer String angesehen. Zum Beispiel würde <code>MsgBox %objekt%</code> eine leere MsgBox anzeigen und <code>objekt + 1</code> einen leeren String zurückgeben. Verlasse dich nicht auf dieses Verhalten, weil es noch geändert werden könnte.</p>
<p>Ein Zuweisungsoperator unmittelbar nach einem Methodenaufruf ist das gleiche wie, als würde man eine Eigenschaft mit Parametern setzen. Zum Beispiel bewirken beide Zeilen dasselbe:</p>
<pre>obj.item(x) := y
obj.item[x] := y</pre>
<p id="cassign">Verbundzuweisungen wie <code>x.y += 1</code> und <code>--arr[1]</code> werden unterstützt.</p>

<h4>Keys</h4>
<p>Es gibt einige Einschränkungen, welche Werte als Keys innerhalb von Objekten, die mit <code>[]</code>, <code>{}</code> oder dem <code>new</code>-Operator erstellt wurden, verwendet werden können:</p>
<ul>
  <li>Integer-Keys werden unter Verwendung des nativen vorzeichenbehafteten Integer-Typs gespeichert. AutoHotkey 32-Bit unterstützt Integer-Keys im Bereich von -2147483648 bis 2147483647. AutoHotkey unterstützt 64-Bit-Integer. Allerdings ist nur AutoHotkey 64-Bit in der Lage, den vollständigen Zahlenbereich des 64-Bit-Integers als Key in einem Objekt zu nutzen.</li>
  <li>Als Folge des oben genannten Punktes wird der String-Format von Integer-Werten nicht beibehalten. Zum Beispiel wären <code>x[0x10]</code>, <code>x[16]</code> und <code>x[00016]</code> dasselbe. Dies gilt auch für numerische Strings ohne Dezimalpunkt.</li>
  <li>Literale Strings in Anführungszeichen werden in v1.x als rein nicht-numerisch angesehen. Zum Beispiel wären <code>x[1]</code> und <code>x["1"]</code> <i>nicht</i> dasselbe. Wenn darüber hinaus ein literaler String in Anführungszeichen mit einem anderen Wert verkettet wird (wie in <code>"0x" x</code>), wird das Ergebnis als rein nicht-numerisch angesehen. Allerdings gilt das nicht für Variablen - beispielsweise wären <code>x[1]</code> und <code>x[y:="1"]</code> dasselbe. Dieses Problem wird in v2 behoben. Deshalb sollte man verhindern, numerische Literale in Anführungszeichen als Keys zu verwenden.</li>
  <li>Fließkommazahlen werden nicht als Keys unterstützt - stattdessen werden sie in Strings umgewandelt. In v1.x behalten literale Fließkommazahlen ihr ursprüngliches Format, während reine Fließkommazahlen (wie z. B. das Ergebnis von <code>0+1.0</code> oder <code>Sqrt(y)</code>) das aktuelle <a href="commands/SetFormat.htm">Float-Format</a> erzwingen. Um Widersprüche zu vermeiden und die Verständlichkeit zu verbessern, sollte man verhindern, literale Fließkommazahlen als Keys zu verwenden.</li>
  <li>Der String-Key <a href="#Custom_Objects">"base"</a> hat eine besondere Bedeutung, außer in Verbindung mit <a href="objects/Object.htm#Insert">Insert</a>.</li>
</ul>

<h2 id="Extended_Usage">Erweiterte Grundlagen</h2>
<h3 id="Function_References">Funktionsverweise <span class="ver">[v1.1.00+]</span></h3>
<p>Enthält die Variable <i>funk</i> einen Funktionsnamen, kann die Funktion über mehrere Wege aufgerufen werden: <code>%funk%()</code> oder <code>funk.()</code>. Allerdings muss dabei die Funktion jedes Mal neu aufgelöst werden. Sobald die Funktion mehr als einmal aufgerufen wird, würde die Effizienz darunter leiden. Zur Verbesserung der Performance speichert man den Funktionsverweis in eine Variable, um sie später wiederzuverwenden:</p>
<pre>Funk := Func("MeineFunk")</pre>
<p>Um eine Funktion per Verweis aufzurufen, muss die folgende Syntax verwendet werden:</p>
<pre>Rückgabewert := Funk.(<i>Parameter</i>)</pre>
<p>Um mehr über zusätzliche Eigenschaften von Funktionsverweisen zu erfahren, siehe <a href="objects/Func.htm">Func-Objekt</a>.</p>
<p><a name="ExitLimitation"></a><b>Bekannte Einschränkung:</b></p>
<ul><li>Behoben seit v1.1.07.00: Wenn die Funktion, sowie eine von ihr aufgerufene Subroutine oder Funktion, <a href="commands/Exit.htm">Exit</a> verwendet, verhält sie sich so, als hätte der Funktionsaufruf einen neuen Thread erstellt. Das heißt, dass die Funktion sofort zu ihrem Aufrufer zurückkehrt, anstatt den aktuellen Thread zu terminieren. Allerdings kann Exit auch die Ursache dafür sein, dass das Script komplett beendet wird, wenn es nicht <a href="commands/_Persistent.htm">persistent</a> sein sollte.</li></ul>

<h3 id="Usage_Arrays_of_Arrays"><a name="JaggedArrays"></a>Mehrdimensionale Arrays</h3>
<p>AutoHotkey unterstützt "mehrdimensionale" Arrays - das sind Arrays innerhalb von anderen Arrays. Eine Tabelle beispielsweise könnte man als Array mit Reihen ansehen, bei dem jede Reihe ein Array mit Spalten ist. In diesem Fall kann der Inhalt der Spalte <code>y</code> von der Reihe <code>x</code> mit einer der folgenden Methoden gesetzt werden:</p>
<pre>Tabelle[x][y] := Inhalt  <em>; A</em>
Tabelle[x, y] := Inhalt  <em>; B</em></pre>
<p>Wenn <code>Tabelle[x]</code> nicht vorhanden ist, unterscheiden sich <span class="Code"><em>A</em></span> und <span class="Code"><em>B</em></span> wie folgt:</p>
<ul>
  <li><span class="Code"><em>A</em></span> schlägt fehl, während <span class="Code"><em>B</em></span> automatisch ein Objekt erstellt und es in <code>Tabelle[x]</code> speichert.</li>
  <li>Wenn  <code>Tabelle</code>'s <a href="#Custom_Objects">base</a> <a href="#Meta_Functions">Meta-Funktionen</a> bereitstellt, werden sie wie folgt aufgerufen:
  <pre>Tabelle.base.__Get(Tabelle, x)<span class="dull">[y] := Inhalt</span>   <em>; A</em>
Tabelle.base.__Set(Tabelle, x, y, Inhalt)     <em>; B</em></pre>
  Folglich kann durch <span class="Code"><em>B</em></span> das Objekt ein benutzerdefiniertes Verhalten für die gesamte Zuweisung definieren.</li>
</ul>
<p>Mehrdimensionale Zuweisungen wie <code>Tabelle[a, b, c, d] := Wert</code> werden wie folgt behandelt:</p>
<ul>
  <li>Bleibt nur ein Key übrig, führe die Zuweisung durch und gebe sie zurück. Ansonsten:</li>
  <li>Suche im Objekt den ersten Key in der Liste.</li>
  <li>Wenn ein Nicht-Objekt gefunden wird, schlage fehl.</li>
  <li>Wenn kein Objekt gefunden wird, erstelle eines und speichere es.</li>
  <li>Rufe das Unterobjekt rekursiv auf und übergebe die restlichen Keys und Values - beginne wieder von oben.</li>
</ul>
<p>Dieses Verhalten gilt nur für script-erstellte Objekte, nicht für spezielle Objekttypen wie COM-Objekte oder COM-Arrays.</p>

<h3 id="Usage_Arrays_of_Functions"><a name="FuncArrays"></a>Arrays mit Funktionen</h3>
<p>Ein Array mit Funktionen ist im Prinzip ein Array, das Funktionsnamen oder Verweise enthält. Zum Beispiel:</p>
<pre>array := [Func("ErsteFunk"), Func("ZweiteFunk")]

<em>; Ruft jede Funktion auf und übergibt "foo" als Parameter:</em>
Loop 2
    array[A_Index].("foo")

<em>; Ruft jede Funktion auf und übergibt indirekt das Array selbst als Parameter:</em>
Loop 2
    array[A_Index]()

ErsteFunk(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}
ZweiteFunk(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}</pre>
<p>Für die Abwärtskompatibilität wird die zweite Form <i>array</i> nicht als Parameter übergeben, wenn <code>array[A_Index]</code> einen Funktionsnamen statt einen Funktionsverweis enthält. Wenn aber <code>array[A_Index]</code> von <code>array.base[A_Index]</code> <a href="#Custom_Objects">geerbt</a> wurde, wird <i>array</i> als Parameter übergeben.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Objekte, die vom Script erstellt wurden, müssen nicht zwingend eine vordefinierte Struktur haben. Stattdessen kann jedes Objekt Eigenschaften und Methoden von seinem <code>base</code>-Objekt (auch bekannt als "Prototyp" oder "Klasse") erben. Bei einem Objekt kann man jederzeit Eigenschaften und Methoden hinzufügen oder entfernen. Solche Änderungen haben auch Auswirkung auf alle abgeleiteten Objekte. Bei komplexeren oder spezielleren Situationen kann das base-Objekt das Standardverhalten überschreiben, indem es <a href="#Meta_Functions"><i>Meta-Funktionen</i></a> definiert.</p>
<p><em>Base</em>-Objekte sind ganz normale Objekte, die mit den folgenden zwei Möglichkeiten erstellt werden können:</p>
<pre>class baseObject {
    static foo := "bar"
}
<em>; OR</em>
baseObject := {foo: "bar"}</pre>
<p>Um ein Objekt zu erstellen, das von einem anderen Objekt abgeleitet wurde, können Scripts die <code>base</code>-Eigenschaft zuweisen oder das <a href="#Custom_NewDelete"><code>new</code>-Schlüsselwort</a> verwenden:</p>
<pre>obj1 := Object(), obj1.base := baseObject
obj2 := {base: baseObjekt}
obj3 := new baseObjekt
MsgBox % obj1.foo " " obj2.foo " " obj3.foo</pre>
<p>Es ist jederzeit möglich, einem Objekt ein neues <code>base</code> zuzuweisen, das alle Eigenschaften und Methoden ersetzen würde, die das Objekt geerbt hat.</p>

<h3 id="Custom_Prototypes">Prototypen</h3>
<p>Prototypen oder <code>base</code>-Objekte können konstruiert und manipuliert werden, wie jedes andere Objekt auch. Zum Beispiel könnte ein gewöhnliches Objekt mit einer Eigenschaft und einer Methode wie folgt konstruiert werden:</p>
<pre><em>; Erstellt ein Objekt.</em>
obj := {}
<em>; Speichert einen Wert.</em>
obj.foo := "bar"
<em>; Erstellt eine Methode durch Speichern eines Funktionsverweises.</em>
obj.test := Func("obj_test")
<em>; Ruft die Methode auf.</em>
obj.test()

obj_test(this) {
   MsgBox % this.foo
}</pre>
<p>Ruft man <code>obj.test()</code> auf, wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Für die Abwärtskompatibilität wird das aber nicht passieren, wenn eine Funktion direkt per Name (statt per Verweis) in das Objekt gespeichert wird (statt von einem base-Objekt geerbt zu werden). Üblicherweise benennt man die Funktion nach dem Objekttypen und dem Methodennamen.</p>
<p>Ein Objekt ist ein <i>Prototyp</i> oder <i>base</i>, wenn ein anderes Objekt davon abgeleitet wurde:</p>
<pre>obj2 := {}
obj2.base := obj
obj2.test()</pre>
<p>In diesem Fall würde <i>obj2</i> das <i>foo</i> und <i>test</i> von <i>obj</i> erben. Diese Vererbung ist dynamisch - würde man <code>obj.foo</code> ändern, wäre die Änderung auch bei <code>obj2.foo</code> bemerkbar. Wenn das Script <code>obj2.foo</code> einen Wert zuweist, wird dieser Wert in <i>obj2</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Einfluss auf <code>obj2.foo</code>. Ruft man <code>obj2.test()</code> auf, würde dessen <i>this</i>-Parameter einen Verweis auf <i>obj2</i> statt auf <i>obj</i> enthalten.
</p>

<h3 id="Custom_Classes">Klassen <span class="ver">[v1.1.00+]</span></h3>
<p>Aufgrund der einfachen Nutzung und seines Bekanntheitsgrades kann das "class"-Schlüsselwort verwendet werden, um ein base-Objekt konstruieren zu können. Eine einfache Klassendefinition könnte wie folgt aussehen:</p>
<pre>class Klassenname extends BaseKlassenname
{
    InstanzVar := Ausdruck
    static KlassenVar := Ausdruck

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }

    Eigenschaft[]
    {
        get {
            return ...
        }
        set {
            return ... := Wert
        }
    }
}
</pre>
<p>Beim Laden des Scripts würde mit diesem Beispiel ein Objekt konstruiert und in die globale (oder seit v1.1.05 in die <a href="Functions.htm#SuperGlobal">superglobale</a>) Variable <i>Klassenname</i> gespeichert werden. Vor v1.1.05 war es notwendig, eine Deklaration wie <code>global Klassenname</code> anzugeben, um diese Klasse innerhalb einer Funktion zu verweisen, sofern die Funktion nicht <a href="Functions.htm#AssumeGlobal">global-behandelnd</a> war. Wenn <code>extends BaseKlassenname</code> vorhanden ist, muss der <i>BaseKlassenname</i> der vollständige Name einer anderen Klasse sein (seit v1.1.11 spielt die Reihenfolge, in der sie definiert werden, keine Rolle mehr). Der vollständige Name jeder Klasse ist in <code><i>objekt</i>.__Class</code> gespeichert.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen <span class="ver">[v1.1.01+]</span></h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse (also jedes abgeleitete Objekt der Klasse) eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert, aber ohne dem Präfix <code>this.</code> (nur direkt innerhalb der Klasse):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit dem <a href="#Custom_NewDelete">new</a>-Schlüsselwort erstellt wird. Der Methodenname <code>__Init</code> ist für diesen Zweck reserviert, und sollte nicht im Script verwendet werden. Die <a href="#Custom_NewDelete">__New()</a>-Methode wird aufgerufen, sobald alle Deklarationen dieser Art (auch solche, die in base-Klassen definiert wurden) ausgewertet worden sind. <em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, aber alle anderen Variablenverweise werden als global angesehen.</p>
<p>Um auf eine Instanzvariable zugreifen zu können, muss immer das Zielobjekt angegeben werden; zum Beispiel <code><b>this</b>.InstanzVar</code>.</p>
<p><span class="ver">[v1.1.08+]:</span> Deklarationen wie <code>x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>x := {}, x.y := 42</code> würde beispielsweise <code>x</code>  deklarieren und außerdem <code>this.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen <span class="ver">[v1.1.00.01+]</span></h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, aber sie können von abgeleiteten Objekten vererbt werden (einschließlich Unterklassen). Sie werden wie Instanzvariablen deklariert, aber unter Verwendung des static-Schlüsselworts:</p>
<pre>static KlassenVar := Ausdruck</pre>
<p>Statische Deklarationen werden nur einmal ausgewertet - bevor der <a href="Scripts.htm#auto">automatische Ausführungsbereich</a> erfolgt, und in der Reihenfolge, wie sie im Script vorkommen. Jede Deklaration speichert einen Wert in das Klassenobjekt. Jeder Variablenverweis im <i>Ausdruck</i> wird als global angesehen.</p>
<p>Um auf eine Klassenvariable zugreifen zu können, muss immer die Klasse oder das abgeleitete Objekt angegeben werden; zum Beispiel <code><b>Klassenname</b>.KlassenVar</code>.</p>
<p><span class="ver">[v1.1.08+]:</span> Deklarationen wie <code>static x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>static x := {}, x.y := 42</code> würde beispielsweise <code>x</code>  deklarieren und außerdem <code><i>Klassenname</i>.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelte Klassendefinitionen ermöglichen Klassenobjekte innerhalb von anderen Klassenobjekten, anstatt eine separate globale Variable verwenden zu müssen. Im obigen Beispiel würde <code>class VerschachtelteKlasse</code> ein Objekt konstruieren und es in <code>Klassenname.VerschachtelteKlasse</code> speichern. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall könnte mit <code>new this.VerschachtelteKlasse</code> eine Instanz unabhängig einer geeigneten Klasse erstellt werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der üblicherweise einen Verweis auf ein Objekt enthält, das von der Klasse abgeleitet wurde. Allerdings könnte er auch einen Verweis auf die Klasse selbst oder auf eine abgeleitete Klasse enthalten, je nachdem, wie die Methode aufgerufen wurde. Methoden werden <a href="#Function_References">per Verweis</a> in das Klassenobjekt gespeichert.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p id="Custom_Classes_base">Neben dem <code>this</code>-Parameter können Methodendefinitionen auch das Pseudo-Schlüsselwort <code>base</code> verwenden, um die base-Klasse der Klasse, die die Methodendefinition enthält, aufrufen zu können. Zum Beispiel wäre <code>base.Methode()</code> in der oberen Methode dasselbe wie <code>BaseKlassenname.Methode.(this)</code>. Beachte, dass sich das von <code>this.base.base.Methode()</code> auf zwei Arten unterscheidet:</p>
<ul>
  <li>Es ruft immer base von der aktuellen Klasse auf, selbst wenn <code>this</code> von einer <i>Unterklasse</i> der aktuellen Klasse abgeleitet wurde.</li>
  <li>Es übergibt <code>this</code> automatisch, aber nicht <code>this.base.base</code>.</li>
  <li>Es bewirkt nicht, dass eine <a href="#Meta_Functions">Meta-Funktion</a> aufgerufen wird.</li>
</ul>
<p><code>base</code> hat nur eine besondere Bedeutung, wenn ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> danach erfolgt. Deshalb wird so etwas wie <code>obj := base, obj.Methode()</code> nicht funktionieren. Scripts können das spezielle Verhalten von <i>base</i> deaktivieren, indem sie base einen nicht-leeren Wert zuweisen; dies wird jedoch nicht empfohlen. Da die Variable <i>base</i> leer sein muss, könnte die Performance reduziert sein, wenn das Script <a href="commands/_NoEnv.htm">#NoEnv</a> weglässt.</p>

<h4 id="Custom_Classes_property">Eigenschaften <span class="ver">[v1.1.16+]</span></h4>
<p>Eigenschaftsdefinitionen erlauben das Ausführen einer Methode, wann immer das Script einen spezifischen Key abruft oder setzt.</p>
<pre>Eigenschaft[]
{
    get {
        return ...
    }
    set {
        return ... := Wert
    }
}</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, mit dem sie aufgerufen werden kann. <code>obj.Eigenschaft</code> würde beispielsweise <em>get</em> aufrufen, und <code>obj.Eigenschaft := Wert</code> würde <em>set</em> aufrufen. Innerhalb von  <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das aufgerufen wird. Innerhalb von <em>set</em> enthält <code>Wert</code> den Wert, der zugewiesen wird.</p>
<p>Parameter können übergeben werden, indem man sie auf der rechten Seite des Eigenschaftsnamens in eckigen Klammern setzt, sowohl beim Definieren als auch beim Aufrufen der Eigenschaft. Abgesehen von der Verwendung eckiger Klammern werden Eigenschaftsparameter genauso wie Methodenparameter definiert - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Der Rückgabewert von <em>get</em> oder <em>set</em> ist das Ergebnis des Unterausdrucks, der die Eigenschaft aufgerufen hat. Zum Beispiel würde <code>Wert := obj.Eigenschaft := 42</code> den Rückgabewert von <em>set</em> in <code>Wert</code> speichern.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie mit <code><a href="#Custom_Classes_base">base.Eigenschaft</a></code> auf die Eigenschaft, die über deren base-Klasse definiert wurde, zugreifen. Wenn <em>get</em> oder <em>set</em> nicht definiert ist, kann es über eine base-Klasse behandelt werden. Wenn <em>set</em> nicht definiert ist und nicht über eine Meta-Funktion oder base-Klasse behandelt wird, wird es beim Zuweisen eines Wertes in das Objekt gespeichert und die Eigenschaft deaktiviert.</p>
<p>Intern sind <em>get</em> und <em>set</em> zwei unterschiedliche Methoden, wodurch sie sich untereinander keine Variablen teilen können (außer sie werden in <code>this</code> gespeichert).</p>
<p><a href="#Meta_Functions">Meta-Funktionen</a> stellen eine breitere Auswahl an Möglichkeiten bereit, um auf Eigenschaften und Methoden eines Objekts zugreifen zu können, aber sie sind komplizierter und fehleranfällig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Immer wenn ein abgeleitetes Objekt mit dem Schlüsselwort <code>new</code> erstellt wird <span class="ver">[benötigt v1.1.00+]</span>, wird die <code>__New</code>-Methode, definiert über das base-Objekt, aufgerufen. Diese Methode kann Parameter akzeptieren, das Objekt initialisieren und das Ergebnis des <code>new</code>-Operators durch Zurückgeben eines Wertes überschreiben. Zerstört man ein Objekt, wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := new GMem(0, 20)
m2 := {base: GMem}.__New(0, 30)

class GMem
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "uint", aFlags, "ptr", aGröße, "ptr")
        if !this.ptr
            return ""
        MsgBox % "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
        return this  <em>; Diese Zeile kann weggelassen werden, wenn der Operator 'new' verwendet wird.</em>
    }

    __Delete()
    {
        MsgBox % "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "ptr", this.ptr)
    }
}</pre>

<h3 id="Meta_Functions">Meta-Funktionen</h3>
<pre class="Syntax">
<strong>Methodensyntax:</strong>
class <i>Klassenname</i> {
    __Get([Key, Key2, ...])
    __Set([Key, Key2, ...], Value)
    __Call(Name [, Parameter...])
}

<strong>Funktionssyntax:</strong>
<i>MeinGet</i>(this [, Key, Key2, ...])
<i>MeinSet</i>(this [, Key, Key2, ...], Value)
<i>MeinCall</i>(this, Name [, Parameter...])

<i>Klassenname</i> := { __Get: Func("<i>MeinGet</i>"), __Set: Func("<i>MeinSet</i>"), __Call: Func("<i>MeinCall</i>") }
</pre>
<p>Meta-Funktionen definieren, was passieren soll, wenn ein Key angefordert, aber nicht im Zielobjekt gefunden wird. Wenn <code>obj.key</code> beispielsweise leer wäre, würde es die <i>__Get</i>-Meta-Funktion aufrufen. Außerdem würde <code>obj.key := value</code> die Meta-Funktion <i>__Set</i> aufrufen und <code>obj.key()</code> die Meta-Funktion <i>__Call</i>. Diese Meta-Funktionen (oder Methoden) müssten in <code>obj.base</code>, <code>obj.base.base</code> oder ähnliches definiert werden.</p>
<p>Wenn das Script einen nicht vorhandenen Key im Zielobjekt abruft (get), setzt (set) oder aufruft (call), wird das base-Objekt wie folgt aufgerufen:</p>
<ul class="list_of_p">
  <li>Definiert dieses base-Objekt die geeignete Meta-Funktion, rufe es auf. Wenn die Meta-Funktion explizit per <code>return</code> zurückgegeben wird, verwende den Rückgabewert als Ergebnis der Operation (was auch immer den Aufruf der Meta-Funktion verursacht hat) und übergebe die Kontrolle wieder an das Script. Ansonsten mache weiter wie unten beschrieben.
    <p><i>Set</i>: Wenn die Meta-Funktion eine Zuweisung behandelt, sollte sie den zugewiesenen Wert zurückgeben. Auf diese Weise können Zuweisungen verkettet werden, wie in <code>a.x := b.y := z</code>. Der Rückgabewert könnte vom ursprünglichen Wert <code>z</code> abweichen (wenn beispielsweise Beschränkungen auferlegt werden, welche Werte zugewiesen werden können).</p></li>
  <li>Suche nach einem passenden Key in den eigenen Feldern des base-Objekts.</li>
  <li><span class="ver">[v1.1.16+]:</span> Wenn ein Key einer Eigenschaft gefunden wurde und <em>get</em> oder <em>set</em> umsetzt (wie vorgesehen), rufe die Eigenschaft auf und kehre zurück. Ist das ein Methodenaufruf, rufe <em>get</em> auf.</li>
  <li>Wenn kein einziger Key gefunden wurde, rufe das eigene base von diesem base-Objekt auf (wende dabei jeden dieser Schritte darauf an, beginnend vom Anfang der Liste). Sind wir noch nicht fertig, durchsuche dieses base-Objekt nochmals nach einen passendem Key, falls ein Key von einer Meta-Funktion hinzugefügt wurde.
    <p>Aufgrund der Abwärtskompatibilität wird dieser Schritt für <em>set</em>-Operationen durchgeführt, selbst wenn ein Key gefunden wurde (es sei denn, es definiert eine Eigenschaft, die <em>set</em> umsetzt).</p></li>
  <li>Wenn mehrere Parameter bei <i>get</i> oder <i>set</i> angegeben wurden und ein Key gefunden wurde, überprüfe seinen Wert. Ist dieser Wert ein Objekt, rufe es auf, um die restlichen Parameter zu behandeln, und tue nichts weiter.</li>
  <li>Wenn ein Key gefunden wurde,<br>
    <i>Get</i>: Gebe den Wert zurück.<br>
    <i>Call</i>: Wenn der Wert ein Funktionsname oder <a href="#Function_References">Verweis</a> ist, rufe es auf und übergebe dabei das Zielobjekt als ersten Parameter (<code>this</code>).</p></li>
</ul>
<p>Wenn eine Meta-Funktion einen passenden Key im Objekt beinhaltet, aber keinen <code>return</code> verwendet, ist das Verhalten das gleiche wie, als wäre der Key bereits zu Beginn im Objekt da gewesen. Um zu erfahren, wie __Set funktioniert, siehe <a href="#Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</a>.</p>
<p>Wenn die Operation immer noch nicht behandelt wurde, überprüfe, ob es eine integrierte Methode oder Eigenschaft ist:</p>
<ul>
  <li><i>Get</i>: Wenn der Key "base" ist, gebe das base des Objekts zurück.</li>
  <li><i>Set</i>: Wenn der Key "base" ist, setze das base des Objekts (oder entferne es, wenn der Wert kein Objekt ist).</li>
  <li><i>Call</i>: Rufe eine <a href="objects/Object.htm">integrierte Methode</a> auf, falls zutreffend.</li>
</ul>
<p>Wenn die Operation immer noch nicht behandelt wurde,</p>
<ul>
  <li><i>Get</i> und <i>Call</i>: Gebe einen leeren String zurück.</li>
  <li><i>Set</i>: Wenn nur ein Key-Parameter angegeben wurde, speichere den Key und Wert in das Zielobjekt und gebe den zugewiesenen Wert zurück. Wenn mehrere Parameter angegeben wurden, erstelle ein neues Objekt und speichere es, und verwende dabei den ersten Parameter als Key; rufe dann das neue Objekt auf, um die restlichen Parameter zu behandeln. (Siehe <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>.)</li>

</ul>
    
<p><b>Bekannte Einschränkungen:</b></p>
<ul><li>Das Verwenden von <code>return</code> ohne Wert ist dasselbe wie <code>return ""</code>. Dies könnte in einer zukünftigen Version geändert werden, so dass man mit <code>return</code> aus einer Meta-Funktion "flüchten" kann, ohne dabei das Standardverhalten überschreiben zu müssen.</li>
<li>Siehe <a href="#ExitLimitation">Exit-Einschränkung</a>.</li></ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Mit <i>__Get</i> und <i>__Set</i> können Eigenschaften implementiert werden, deren Werte auf irgendeiner Weise berechnet oder beschränkt sind. Zum Beispiel können sie verwendet werden, um ein "Farbe"-Objekt mit R, G, B und RGB-Eigenschaften zu implementieren, wo tatsächlich nur der RGB-Wert gespeichert wird:</p>
<pre>rot := new Farbe(0xff0000), rot.R -= 5
cyan := new Farbe(0x00ffff)

MsgBox % "rot: " rot.R "," rot.G "," rot.B " = " rot.RGB
MsgBox % "cyan: " cyan.R "," cyan.G "," cyan.B " = " cyan.RGB

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    __Get(aName)
    {
        if (aName = "R")
            return (this.RGB &gt;&gt; 16) &amp; 255
        if (aName = "G")
            return (this.RGB &gt;&gt; 8) &amp; 255
        if (aName = "B")
            return this.RGB &amp; 255
    }

    __Set(aName, aWert)
    {
        if aName in R,G,B
        {
            aWert &amp;= 255

            if      (aName = "R")
                this.RGB := (aWert &lt;&lt; 16) | (this.RGB &amp; ~0xff0000)
            else if (aName = "G")
                this.RGB := (aWert &lt;&lt; 8)  | (this.RGB &amp; ~0x00ff00)
            else  <em>; (aName = "B")</em>
                this.RGB :=  aWert        | (this.RGB &amp; ~0x0000ff)

            <em>; 'Return' muss verwendet werden, um zu kennzeichnen, dass kein neues Key-Value-Paar erstellt werden sollte.
            ; Dies definiert auch, was in 'x' von 'x := clr[name] := val' gespeichert werden soll:</em>
            return aWert
        }
    }
}</pre>

<h4 id="Objects_as_Functions">Objekte als Funktionen</h4>
<p>Wenn ein Aufruf wie <code>obj.func(param)</code> erfolgt, könnte <i>obj.func</i> einen Funktionsnamen oder ein Objekt enthalten. Enthält <i>obj.func</i> ein Objekt, wird dieses Objekt mit <i>obj</i> aufgerufen, anstatt mit dem Methodennamen wie in <code>(obj.func)[obj]()</code>. Da in den meisten Fällen <code>obj.func[obj]</code> nicht vorhanden ist, wird stattdessen die __Call-<a href="#Meta_Functions">Meta-Funktion</a> von <i>obj.func</i> aufgerufen. Damit könnte man das Verhalten der Funktionsaufrufe auf einer abstrakten Weise ändern, wie es im folgenden Beispiel gezeigt wird:</p>
<pre><em>; Erstellt ein Prototyp für ein Array mit Funktionen.</em>
FuncArrayType := {__Call: "FuncType_Call"}
<em>; Erstellt ein Array mit Funktionen.</em>
funcArray := {1: "Eins", 2: "Zwei", base: FuncArrayType}
<em>; Erstellt ein Objekt, das das Array als Methode verwendet.</em>
obj := {func: funcArray}
<em>; Ruft die Methode auf.</em>
obj.func("foo", "bar")

FuncType_Call(func, obj, params*)
{
    <em>; Ruft eine Liste mit Funktionen auf.</em>
    Loop % ObjMaxIndex(func)
        func[A_Index](params*)
}

Eins(param1, param2) {
    ListVars
    Pause
}
Zwei(param1, param2) {
    ListVars
    Pause
}</pre>
<p>Diese Technik, kombiniert mit Klassendefinitionen, bietet eine bequeme Möglichkeit, dynamische Eigenschaften zu definieren, ähnlich wie im vorherigen Abschnitt:</p>
<pre>blau := new Farbe(0x0000ff)
MsgBox % blau.R "," blau.G "," blau.B

class Eigenschaften
{
    __Call(aTarget, aName, aParams*)
    {
        <em>; Falls dieses Eigenschaftsobjekt eine Definition für diese Halb-Eigenschaft enthält, ruft es auf.
        ; Achtet darauf, nicht this.HasKey(aName) zu verwenden, da das sonst in  __Call rekursiv ausgeführt wird.</em>
        if IsObject(aZiel) &amp;&amp; ObjHasKey(this, aName)
            return this[aName].(aZiel, aParams*)
    }
}

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    class __Get extends Eigenschaften
    {
        R() {
            return (this.RGB &gt;&gt; 16) &amp; 255
        }
        G() {
            return (this.RGB &gt;&gt; 8) &amp; 255
        }
        B() {
            return this.RGB &amp; 255
        }
    }

    <em>;...</em>
}</pre>

<h4 id="Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</h4>
<p>Wenn eine <a href="#Usage_Arrays_of_Arrays">Multiparameter-Zuweisung</a> wie <code>Tabelle[x, y] := Inhalt</code> indirekt bewirken sollte, dass ein neues Objekt erstellt wird, hat das neue Objekt kein base und folglich keine benutzerdefinierten Methoden oder Sonderverhalten. Mit <code>__Set</code> könnten diese Objekte wie folgt initialisiert werden.</p>
<pre>x := {base: {addr: Func("x_Addr"), __Set: Func("x_Setter")}}

<em>; Weist einen Wert zu, und ruft indirekt x_Setter auf, um Unterobjekte zu erstellen.</em>
x[1,2,3] := "..."

<em>; Ermittelt den Wert und ruft die Beispielmethode auf.</em>
MsgBox % x[1,2,3] "`n" x.addr() "`n" x[1].addr() "`n" x[1,2].addr()

x_Setter(x, p1, p2, p3) {
    x[p1] := new x.base
}

x_Addr(x) {
    return &amp;x
}</pre>
<p>Da <code>x_Setter</code> vier Pflichtparameter hat, wird es nur aufgerufen, wenn zwei oder mehr Key-Parameter vorhanden sind. Erfolgt die oben genannte Zuweisung, findet folgendes statt:</p>
<ul>
  <li><code>x[1]</code> existiert nicht, daher wird <code>x_Setter(x,1,2,3)</code> aufgerufen (<code>"..."</code> wird nicht übergeben, da zu wenig Parameter vorhanden sind).
  <ul>
    <li>In <code>x[1]</code> wird ein neues Objekt gespeichert, mit demselben base wie <code>x</code>.</li>
    <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2]</code> existiert nicht, daher wird <code>x_Setter(x[1],2,3,"...")</code> aufgerufen.
  <ul>
    <li>In <code>x[1][2]</code> wird ein neues Objekt gespeichert, mit demselben base wie <code>x[1]</code>.</li>
    <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2][3]</code> existiert nicht, aber weil <code>x_Setter</code> vier Parameter benötigt und nur drei zur Verfügung stehen (<code>x[1][2], 3, "..."</code>), wird es nicht aufgerufen und die Zuweisung normal beendet.</li>
</ul>

<h2 id="Default_Base_Object">Standard-base-Objekt</h2>
<p>Verwendet man ein Nicht-Objekt-Wert in Verbindung mit der Objektsyntax, wird das <i>Standard-base-Objekt</i> aufgerufen. Dies könnte zum einen fürs Debuggen nützlich sein, oder, um ein objektähnliches Verhalten für Strings, Zahlen und/oder Variablen global definieren zu können. Möchte man auf das Standard-base zugreifen, könnte man <code>.base</code> in Verbindung mit einem beliebigen Nicht-Objekt-Wert verwenden; zum Beispiel <code>"".base</code>. Das Standard-base kann nicht wie in <code>"".base := Object()</code> <i>gesetzt</i> werden. Allerdings kann das Standard-base selbst auch ein base haben, wie in <code>"".base.base := Object()</code>.</p>

<h4 id="Automatic_Var_Init">Automatische Variableninitialisierung</h4>
<p>Dient eine leere Variable als Ziel einer <i>Set</i>-Operation, wird sie direkt an die __Set-Meta-Funktion übergeben, so dass sie ein neues Objekt in die Variable einfügen kann. Aus Platzgründen unterstützt dieses Beispiel nicht mehr als ein Parameter; mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> wäre das möglich.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox % empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    if (var = "")
        var := Object(key, value)
}</pre>

<h4 id="Pseudo_Properties">Pseudo-Eigenschaften</h4>
<p>Diese Art von Syntax kann auch auf Strings und Zahlen angewendet werden.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox % A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox % A_AhkPath.length.is("integer")

Default_Get_PseudoProperty(nonobj, key)
{
    if (key = "length")
        return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    if nonobj is %type%
        return true
    return false
}</pre>
<p>Beachte, dass integrierte Funktionen auch möglich sind, aber in diesem Fall können die Klammern nicht weggelassen werden:</p>
<pre>"".base.length := Func("StrLen")
MsgBox % A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h4 id="Default__Warn">Debuggen</h4>
<p>Falls ein Wert nicht als Objekt behandelt werden soll, kann eine Warnmeldung angezeigt werden, wann immer ein Nicht-Objekt-Wert aufgerufen wird:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1="", p2="", p3="", p4="")
{
    ListLines
    MsgBox Ein Nicht-Objekt-Wert wurde unsachgemäß aufgerufen.`n`nSpeziell: %nonobj%
}</pre>

<h2 id="Implementation">Implementierung</h2>
<a name="Refs"></a><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet ein einfaches Referenzzählungsmechanismus, um Ressourcen eines Objekts freizugeben, das nicht länger im Script gebraucht wird. Script-Autoren sollten diesen Mechanismus nur aufrufen, wenn man direkt mit unverwalteten Pointer, die auf Objekte verweisen, arbeiten muss. Für weitere Informationen, siehe <a href="commands/ObjAddRef.htm">ObjAddRef</a>.</p>
<pre><em>; Erhöht die Referenzzählung des Objekts, um "es am Leben zu erhalten":</em>
<a href="commands/ObjAddRef.htm">ObjAddRef</a>(Adresse)
...
<em>; Verringert die Referenzzählung des Objekts, so dass es freigegeben werden kann:</em>
ObjRelease(Adresse)
</pre>
<p>ObjAddRef muss nicht verwendet werden, wenn eine Adresse zunächst per <code><a href="#AddressCast">Object(obj)</a></code> bezogen wird.</p>
<p>Generell sollte jede neue Kopie einer Objektadresse als Objektverweis behandelt werden, außer dass das Script wie vorgesehen für den Aufruf von ObjAddRef und/oder ObjRelease verantwortlich ist. Würde man beispielsweise eine Adresse mit so etwas wie <code>x := Adresse</code> kopieren, sollte ObjAddRef aufgerufen werden, um die Referenzzählung zu erhöhen. Ebenso sollte ObjRelease aufgerufen werden, wenn eine bestimmte Kopie der Objektadresse durchgeführt wurde. Dadurch wird sichergestellt, dass das Objekt freigegeben wird, wenn der letzte Verweis auf dieses Objekt verloren geht - und nicht vorher.</p>
<p>Wenn Code beim Freigeben des letzten Verweises auf ein Objekt ausgeführt werden soll, muss man die <a href="#Custom_NewDelete">__Delete</a>-Meta-Funktion implementieren.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Siehe <a href="#Circular_References">Freigeben von Objekten</a>, um anhand eines Beispiels mehr darüber zu erfahren.</li>
  <li>Verweise in statischen und globalen Variablen werden automatisch freigegeben, sobald das Programm beendet wird. Verweise in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel bleiben bestehen. Solche Verweise werden nur freigegeben, wenn die Funktion oder der Ausdruck normal beendet werden konnte.</li>
</ul>
<p>Das Betriebssystem kann den benutzten Speicher vom Objekt wieder verwenden, sobald das Programm beendet wird. Allerdings wird <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen, wenn alle Verweise auf das Objekt freigegeben worden sind. Das kann wichtig sein, wenn andere Ressourcen freigegeben werden, die nicht automatisch vom Betriebssystem wieder verwendet werden, wie zum Beispiel temporäre Dateien.</p>

<a name="AddressCast"></a><h3 id="Implementation_Pointers">Pointer auf Objekte</h3>
<p>In einigen seltenen Fällen kann es erforderlich sein, ein Objekt per DllCall an einen externen Code zu übergeben oder ein Objekt in eine binäre Datenstruktur zu speichern, um es später abrufen zu können. Eine Objektadresse kann per <code>x := &amp;obj</code> abgerufen werden; wenn die Variable <i>obj</i> allerdings geleert wird, könnte das Objekt vorzeitig freigegeben werden. Mit ObjAddRef, wie oben gezeigt, oder mit der <code>Object()</code>-Funktion, wie unten gezeigt, kann sichergestellt werden, dass so etwas nicht passiert:</p>
<pre>Adresse := Object(Objekt)</pre>
<p>Darüber hinaus kann man mit dieser Funktion die Adresse wieder in ein Verweis umwandeln:</p>
<pre>Objekt := Object(Adresse)</pre>
<p>In jedem Fall wird die <a href="#Refs">Referenzzählung</a> des Objekts automatisch erhöht, um ein vorzeitiges Freigeben des Objekts zu verhindern.</p>
<p>Beachte, dass diese Funktionen ebenso für Objekte gelten, die nicht mit <a href="#Arrays">Object()</a> erstellt wurden, wie <a href="commands/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="objects/File.htm">File-Objekte</a>.</p>

</body>
</html>
