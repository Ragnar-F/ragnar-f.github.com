<!DOCTYPE HTML>
<html>
<head>
<title>Objekte</title>
<meta name="keywords" content="Grundlage, Objekt">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<link href="static/font.css" rel="stylesheet" type="text/css" />
<script src="static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="static/html5.js"></script>
<![endif]-->
<script src="navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(0);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Objekte</h1>
      <p>In AutoHotkey ist ein <i>Objekt</i> eine abstrakte Datenstruktur, die drei grundlegende Funktionen ermöglicht:</p>
      <ul>
        <li>GET - Abrufen eines Wertes.</li>
        <li>SET - Setzen eines Wertes.</li>
        <li>CALL - Aufrufen einer Methode (eine Funktion, die das Zielobjekt beeinflusst).</li>
      </ul>
      <p>Ein Objekt<i>verweis</i> ist ein Pointer oder Handle auf ein bestimmtes Objekt. Objektverweise können wie Strings und Zahlen in Variablen gespeichert werden, an Funktionen übergeben oder von Funktionen zurückgegeben werden und in Objekten gespeichert werden. Falls eine Variable, die einen Verweis enthält, in eine andere Variable kopiert wird (z. B. mit <code>x := y</code>), verweisen beide Variablen auf das gleiche Objekt.</p>
      <p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
      <pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>
      <p>Es sind folgende Objekttypen enthalten:</p>
      <ul>
        <li><a href="objects/Object.htm"><b>Object</b></a> - scriptfähiges assoziatives Array.</li>
        <li><a href="objects/File.htm">File</a> - ermöglicht eine Schnittstelle für die Dateibearbeitung.</li>
        <li><a href="objects/Func.htm">Func</a> - eine Funktion.</li>
        <li><a href="commands/ComObjCreate.htm">ComObject</a> - Verpackt eine IDispatch-Schnittstelle (ein COM oder "Automatisierungsobjekt").</li>
      </ul>
      <h2>Inhaltsverzeichnis</h2>
      <ul>
        <li><a href="#Usage">Grundlagen</a> - <a href="#Usage_Simple_Arrays">Einfache Arrays</a>, <a href="#Usage_Associative_Arrays">Assoziative Arrays</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a>, <a href="#Usage_Remarks">Bemerkungen</a></li>
        <li><a href="#Extended_Usage">Erweiterte Grundlagen</a> - <a href="#Function_References">Funktionsverweise</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>, <a href="#Usage_Arrays_of_Functions">Arrays mit Funktionen</a></li>
        <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#Custom_Prototypes">Prototypen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Meta-Funktionen</a></li>
        <li><a href="#Default_Base_Object">Standard-base-Objekt</a> - <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
        <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#Implementation_Pointers">Pointer auf Objekte</a></li>
      </ul>
      <h2 id="Usage">Grundlagen</h2>
      <h3 id="Usage_Simple_Arrays">Einfache Arrays</h3>
      <p>Erstellen eines Arrays:</p>
      <pre>Array := [Element1, Element2, ..., ElementN]
Array := Array(Element1, Element2, ..., ElementN)</pre>
      <p>Abrufen eines Elements:</p>
      <pre>Wert := Array[Index]</pre>
      <p>Zuweisen eines Elements:</p>
      <pre>Array[Index] := Wert</pre>
      <p>Anfügen eines Elements:</p>
      <pre>Array.<a href="objects/Object.htm#Insert">Insert</a>(Wert)</pre>
      <p>Einfügen beliebig vieler Elemente ab einem bestimmten Index:</p>
      <pre>Array.<a href="objects/Object.htm#Insert">Insert</a>(Index, Wert, Wert2, ...)</pre>
      <p>Entfernen eines Elements:</p>
      <pre>EntfernterWert := Array.<a href="objects/Object.htm#Remove">Remove</a>(Index)</pre>
      <p>Falls das Array nicht leer ist, werden <a href="objects/Object.htm#MinMaxIndex">MinIndex</a> und <a href="objects/Object.htm#MinMaxIndex">MaxIndex</a> jeweils den niedrigsten und höchsten Index zurückgeben, der zurzeit im Array benutzt wird. Da der niedrigste Index fast immer 1 ist, wird MaxIndex für gewöhnlich die Anzahl an Elemente zurückgeben. Der Inhalt des Arrays kann per Index oder mit einer For-Schleife durchlaufen werden. Zum Beispiel:</p>
      <pre>array := ["eins", "zwei", "drei"]

<em>; Iterieren von 1 bis zur Gesamtanzahl der Elemente:</em>
<a href="commands/Loop.htm">Loop</a> % array.MaxIndex()
    MsgBox % array[A_Index]

<em>; Den Inhalt des Arrays enumerieren:</em>
<a href="commands/For.htm">For</a> Index, Wert in array
    MsgBox % "Element " Index " enthält '" Wert "'"

</pre>
      <h3 id="Usage_Associative_Arrays">Assoziative Arrays</h3>
      <p>Ein assoziatives Array ist ein Objekt, das eine Sammlung von eindeutigen Schlüsseln und Werten enthält, wobei jeder Wert einem Schlüssel zugeordnet ist. Schlüssel können Strings, Integer oder Objekte sein, während die Werte beliebige Typen sein können. Ein assoziatives Array kann wie folgt erstellt werden:</p>
      <pre>Array := {SchlüsselA: WertA, SchlüsselB: WertB, ..., SchlüsselZ: WertZ}
Array := Object("SchlüsselA", WertA, "SchlüsselB", WertB, ..., "SchlüsselZ", WertZ)</pre>
      <p>Beim Verwenden der Notation <code>{Schlüssel:Wert}</code> sind Anführungszeichen für Schlüssel optional, solange sie nur aus Wortzeichen bestehen. Jeder Ausdruck kann als Schlüssel verwendet werden; um jedoch eine Variable als Schlüssel zu benutzen, umschließt sie mit Klammern. Zum Beispiel sind <code>{(SchlüsselVar): Wert}</code> und <code>{GetKey(): Wert}</code> gültig.</p>
      <p>Abrufen eines Elements:</p>
      <pre>Wert := Array[Schlüssel]</pre>
      <p>Zuweisen eines Elements:</p>
      <pre>Array[Schlüssel] := Wert</pre>
      <p>Entfernen eines Elements:</p>
      <pre>EntfernterWert := Array.<a href="objects/Object.htm#Remove">Remove</a>(Schlüssel)</pre>
      <p>Enumerieren von Elementen:</p>
      <pre>array := {zehn: 10, zwanzig: 20, dreißig: 30}
<a href="commands/For.htm">For</a> Schlüssel, Wert in array
    MsgBox %Schlüssel% = %Wert%</pre>
      <p>Assoziative Arrays können klein gehalten werden - zum Beispiel enthält <code>{1: "a", 1000: "b"}</code> nur zwei Schlüssel-Wert-Paare, nicht 1000.</p>
      <p id="same_thing">Inzwischen wurde vielleicht schon bemerkt, dass sich die Syntaxen von assoziativen Arrays und von einfachen Arrays sehr ähneln. Tatsächlich sind sie das Gleiche in v1.x. Solange <code>[]</code> als einfaches lineares Array behandelt wird, bleibt dessen Rolle klar und erhöht die Chance, dass das eigene Script mit einer zukünftigen Version von AutoHotkey weiterhin funktioniert, in der die Implementierung möglicherweise geändert wurde.</p>
      <h3 id="Usage_Objects">Objekte</h3>
      <p>Abrufen einer Eigenschaft:</p>
      <pre>Wert := Objekt.Eigenschaft</pre>
      <p>Setzen einer Eigenschaft:</p>
      <pre>Objekt.Eigenschaft := Wert</pre>
      <p>Aufrufen einer Methode:</p>
      <pre>Rückgabewert := Objekt.Methode(Parameter)</pre>
      <p>Aufrufen einer Methode mit einem errechneten Methodennamen:</p>
      <pre>Rückgabewert := Object[Methodenname](Parameter)</pre>
      <p>Einige Eigenschaften von COM-Objekten und benutzerdefinierten Objekten können Parameter akzeptieren:</p>
      <pre>Wert := Objekt.Eigenschaft[Parameter]
Objekt.Eigenschaft[Parameter] := Wert</pre>
      <p><strong>Verwandte Befehle:</strong> <a href="objects/Object.htm">Objekt</a>, <a href="objects/File.htm">File-Objekt</a>, <a href="objects/Func.htm">Func-Objekt</a>, <a href="commands/ComObjCreate.htm">COM-Objekt</a></p>
      <p><b>Bekannte Einschränkung:</b></p>
      <ul>
        <li>Zurzeit wird <code><span class="dull">x</span>.y[z]<span class="dull">()</span></code> als <code><span class="dull">x</span>["y", z]<span class="dull">()</span></code> behandelt, allerdings wird dies nicht unterstÃ¼tzt. Als Übergangslösung wird <code>x.y</code> in <code><span class="red">(</span><span class="dull">x.y</span><span class="red">)</span>[z]()</code> zuerst ausgewertet und danach das Ergebnis als Ziel des Methodenaufrufs verwendet. Beachtet, dass <code>x.y[z].()</code> nicht diese Einschränkung hat, da es wie <code>(x.y[z]).()</code> ausgewertet wird.</li>
      </ul>
      <h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
      <p>Scripts geben Objekte nicht direkt frei. Sobald der letzte Verweis auf ein Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Ein gespeicherter Verweis in einer Variable wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
      <pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt den letzten Verweis frei, wodurch das Objekt freigegeben wird.</em></pre>
      <p>In diesem Zusammenhang wird ein Verweis, der in einem Feld eines anderen Objekts gespeichert ist, freigegeben, wenn dieses Feld irgendeinen anderen Wert zugewiesen bekommt oder vom Objekt entfernt wird. Das gilt auch für Arrays, da sie eigentlich Objekte sind.</p>
      <pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.Remove(1)  <em>; Entfernt und gibt das zweite Objekt frei.</em></pre>
      <p id="Circular_References">Da alle Verweise auf ein Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Zum Beispiel: Verweist <code>x.child</code> auf <code>y</code> und <code>y.parent</code> auf <code>x</code>, genügt es nicht, <code>x</code> und <code>y</code> zu leeren, da das Parent-Objekt weiterhin einen Verweis auf das Child-Objekt enthält und umgekehrt. Um diese Situation in den Griff zu bekommen, muss der Zirkelbezug entfernt werden.</p>
      <pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Ohne die obige Zeile würde dies hier die Objekte nicht freigeben.</em>
</pre>
      <p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>
      <h3 id="Usage_Remarks">Bemerkungen</h3>
      <h4>Syntax</h4>
      <p>Alle Objektarten unterstützen sowohl die Array-Syntax (eckige Klammern) als auch die Objekt-Syntax (Punkte).</p>
      <p>Darüber hinaus können Objektverweise auch in Ausdrücke verwendet werden:</p>
      <ul>
        <li>Wenn ein Objektverweis mit irgendeinem anderen Wert mithilfe von <code>= == != &lt;&gt;</code> verglichen wird, dann werden sie nur als gleich angesehen, wenn beide Werte auf dasselbe Objekt verweisen.</li>
        <li>Objekte werden immer als <i>wahr</i> angesehen, falls ein boolescher Wert erforderlich ist, wie z. B. in <code>If obj</code>, <code>!obj</code> oder <code>obj ? x : y</code>.</li>
        <li>Eine Objektadresse kann mithilfe des <code>&amp;</code>-Operators abgerufen werden. Damit kann das Objekt eindeutig identifiziert werden, sobald sein letzter Verweis <a href="#Reference_Counting">freigegeben</a> wird.</li>
      </ul>
      <p>Sobald ein Objekt in einem Rahmen verwendet wird, in dem ein Objekt nicht erwartet wird, wird es als einen leeren String behandelt. Zum Beispiel zeigt <code>MsgBox %Objekt%</code> eine leere MsgBox an und <code>Objekt + 1</code> ergibt einen leeren String. Man sollte sich nicht auf dieses Verhalten verlassen, da sich das noch ändern kann.</p>
      <p>Falls nach einem Methodenaufruf unmittelbar ein Zuweisungsoperator erfolgt, dann wird eine Eigenschaft mit Parametern gesetzt. Zum Beispiel sind beide Angaben gleichwertig:</p>
      <pre>obj.item(x) := y
obj.item[x] := y</pre>
      <p id="cassign">Verbundzuweisungen wie <code>x.y += 1</code> und <code>--arr[1]</code> werden unterstützt.</p>
      <h4>Schlüssel</h4>
      <p>Einige Einschränkungen gelten beim Zuweisen von Werten an Schlüssel des Objekts, das mit <code>[]</code>, <code>{}</code> oder dem <code>new</code>-Operator erstellt wurde:</p>
      <ul>
        <li>Integer-Schlüssel werden im ursprünglichen signed Integer-Typ gespeichert. AutoHotkey 32-Bit unterstützt Integer-Schlüssel im Bereich von -2147483648 bis 2147483647. AutoHotkey unterstützt 64-Bit-Integer, aber nur AutoHotkey 64-Bit unterstützt den vollen Umfang für Schlüssel in einem Objekt.</li>
        <li>Daher wird das String-Format von Integer-Werten nicht beibehalten. Zum Beispiel sind <code>x[0x10]</code>, <code>x[16]</code> und <code>x[00016]</code> gleichwertig. Das gilt auch für numerische Strings, die keinen Dezimalpunkt enthalten.</li>
        <li>Direkt vorhandene Strings in Anführungszeichen werden in v1.x als rein nicht-numerisch angesehen, daher sind <code>x[1]</code> und <code>x["1"]</code> <i>nicht</i> gleichwertig. Wenn darüber hinaus ein direkt vorhandener String in Anführungszeichen mit anderen Werten verkettet wird (wie in <code>"0x" x</code>), wird das Ergebnis als rein nicht-numerisch behandelt. Allerdings gilt das nicht für Variablen, somit sind <code>x[1]</code> und <code>x[y:="1"]</code> gleichwertig. Dieses Problem wird in v2 gelöst, daher sollten Scripts vermeiden, numerische Literale in Anführungszeichen als Schlüssel zu verwenden.</li>
        <li>Fließkommazahlen werden nicht als Schlüssel unterstützt - stattdessen werden sie in Strings umgewandelt. In v1.x behalten Fließkomma-Literale ihr ursprüngliches Format, während reine Fließkommazahlen (wie z. B. das Ergebnis von <code>0+1.0</code> oder <code>Sqrt(y)</code>) das aktuelle <a href="commands/SetFormat.htm">Float-Format</a> erzwingen. Aus Gründen der Konsistenz und Klarheit sollten Scripts vermeiden, Fließkomma-Literale als Schlüssel zu verwenden.</li>
        <li>Der String-Schlüssel <a href="#Custom_Objects">"base"</a> hat eine besondere Bedeutung, außer es wird mit <a href="objects/Object.htm#Insert">Insert</a> verwendet.
          <p></p>
        </li>
      </ul>
      <h2 id="Extended_Usage">Erweiterte Grundlagen</h2>
      <h3 id="Function_References">Funktionsverweise <span class="ver">[v1.1.00+]</span></h3>
      <p>Wenn die Variable <i>Funktion</i> einen Funktionsnamen enthält, kann die Funktion wie folgt aufgerufen werden: <code>%Funktion%()</code> oder <code>Funktion.()</code>. Allerdings muss die Funktion dabei jedesmal aufgelöst werden, was ineffizient ist, falls die Funktion mehr als einmal aufgerufen wird. Um die Performance zu verbessern, kann das Script einen Verweis auf die Funktion abrufen und sie für später speichern:</p>
      <pre>Funktion := Func("EigeneFunktion")</pre>
      <p>Um eine Funktion mit einem Verweis aufzurufen, muss die folgende Syntax verwendet werden:</p>
      <pre>Rückgabewert := Funktion.(<i>Parameter</i>)</pre>
      <p>Für Details über zusätzliche Eigenschaften von Funktionsverweise, siehe <a href="objects/Func.htm">Func-Objekt</a>.</p>
      <p id="ExitLimitation"><b>Bekannte Einschränkung:</b></p>
      <ul>
        <li>Seit v1.1.07.00 behoben: Wenn die Funktion, sowie eine von ihr aufgerufene Subroutine oder Funktion, <a href="commands/Exit.htm">Exit</a> verwendet, dann verhält sie sich wie beim Funktionsaufruf, der einen neuen Thread erstellt hat. Das heißt, sie kehrt sofort zum Aufrufer der Funktion zurück, anstatt den aktuellen Thread zu beenden. Allerdings bewirkt das Exit weiterhin, dass das Script beendet wird, falls es nicht <a href="commands/_Persistent.htm">persistent</a> ist.</li>
      </ul>
      <h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
      <p>AutoHotkey unterstützt "mehrdimensionale" Arrays, indem Arrays in andere Arrays gespeichert werden. Zum Beispiel könnte eine Tabelle einen Array von Reihen repräsentieren, wobei jede Reihe selbst ein Array von Spalten ist. In diesem Fall kann der Inhalt der Spalte <code>y</code> der Reihe <code>x</code> mithilfe einer folgenden Methode gesetzt werden:</p>
      <pre>Tabelle[x][y] := Inhalt  <em>; A</em>
Tabelle[x, y] := Inhalt  <em>; B</em></pre>
      <p>Falls <code>Tabelle[x]</code> nicht vorhanden ist, unterscheiden sich <span class="Code"><em>A</em></span> und <span class="Code"><em>B</em></span> wie folgt:</p>
      <ul>
        <li><span class="Code"><em>A</em></span> schlägt fehl, während <span class="Code"><em>B</em></span> automatisch ein Objekt erstellt und es in <code>Tabelle[x]</code> speichert.</li>
        <li>Wenn <a href="#Custom_Objects">base</a> von <code>Tabelle</code> <a href="#Meta_Functions">Meta-Funktionen</a> definiert, dann werden sie wie folgt aufgerufen:
          <pre>Tabelle.base.__Get(Tabelle, x)<span class="dull">[y] := Inhalt</span>   <em>; A</em>
Tabelle.base.__Set(Tabelle, x, y, Inhalt)     <em>; B</em></pre>
          Folglich ermöglicht <em><span class="Code">B</span></em>, dass das Objekt ein benutzerdefiniertes Verhalten für die gesamte Zuweisung definieren kann.</li>
      </ul>
      <p>Mehrdimensionale Zuweisungen wie <code>Tabelle[a, b, c, d] := Wert</code> werden wie folgt behandelt:</p>
      <ul>
        <li>Falls nur ein Schlüssel übrig ist, wird die Zuweisung durchgeführt und zurückgegeben. Ansonsten:</li>
        <li>Suche im Objekt den ersten Schlüssel in der Liste.</li>
        <li>Wenn ein Nicht-Objekt gefunden wird, schlage fehl.</li>
        <li>Wenn kein Objekt gefunden wird, erstelle eins und speichere es.</li>
        <li>Rufe das Unterobjekt rekursiv auf, die restlichen Schlüssel und Werte werden übergeben - wiederholend von oben.</li>
      </ul>
      <p>Dieses Verhalten gilt nur für erstellte Objekte von Scripts, nicht für Sondertypen von Objekten wie COM-Objekte oder COM-Arrays.</p>
      <h3 id="Usage_Arrays_of_Functions">Arrays mit Funktionen</h3>
      <p>Ein Array mit Funktionen ist im Prinzip ein Array, das Funktionsnamen oder Verweise enthält. Zum Beispiel:</p>
      <pre>Array := [Func("ErsteFunktion"), Func("ZweiteFunktion")]

<em>; Aufrufen jeder Funktion, Übergabe von "foo" als Parameter:</em>
Loop 2
    Array[A_Index].("foo")

<em>; Aufrufen jeder Funktion, indirekte Übergabe desselben Arrays als Parameter:</em>
Loop 2
    Array[A_Index]()

ErsteFunktion(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}
ZweiteFunktion(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}</pre>
      <p>Für die Abwärtskompatibilität wird die zweite Form das <i>Array</i> nicht als Parameter übergeben, wenn <code>Array[A_Index]</code> einen Funktionsnamen anstelle einer Funktionsreferenz enthält. Falls jedoch <code>Array[A_Index]</code> von <code>Array.base[A_Index]</code> <a href="#Custom_Objects">geerbt</a> wird, wird das <i>Array</i> als Parameter übergeben.</p>
      <h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
      <p>AutoHotkey-Objekte basieren auf Prototypen, anstatt auf Klassen. Das heißt, dass ein Objekt die Eigenschaften und Methoden von seinem Prototyp oder <code>base</code>-Objekt erben kann, aber eine vordefinierte Struktur nicht angegeben werden muss. Eigenschaften und Methoden können zu einem Objekt oder zu Objekten, die jederzeit davon abgeleitet werden, hinzugefügt werden (bzw. davon entfernt werden). Jedoch wird AutoHotkey die Klassen emulieren, indem <a href="#Custom_Classes">Klassendefinitionen</a> in gewöhnliche Objekte umgewandelt werden. Bei komplexere oder speziellere Situationen kann das Standardverhalten vom base-Objekt überschrieben werden, indem <i><a href="#Meta_Functions">Meta-Funktionen</a></i> definiert werden.</p>
      <p>Um ein Objekt zu erstellen, das von einem anderen Objekt abgeleitet wurde, können Scripts das <code>base</code> zuweisen oder das <code>new</code>-Schlüsselwort verwenden:</p>
      <pre>BaseObjekt := {foo: "bar"}
obj1 := Object(), obj1.base := BaseObjekt
obj2 := {base: BaseObjekt}
obj3 := new BaseObjekt
MsgBox % obj1.foo " " obj2.foo " " obj3.foo</pre>
      <h3 id="Custom_Prototypes">Prototypen</h3>
      <p>Prototyp- oder <code>base</code>-Objekte werden genauso wie andere Objekte konstruiert und manipuliert. Zum Beispiel ist es möglich, ein gewöhnliches Objekt mit einer Eigenschaft und Methode wie folgt zu konstruieren:</p>
      <pre><em>; Erstellt ein Objekt.</em>
Ding := {}
<em>; Speichert ein Wert.</em>
Ding.foo := "bar"
<em>; Erstellt eine Methode durch Speichern eines Funktionsverweises.</em>
Ding.test := Func("Ding_test")
<em>; Ruft die Methode auf.</em>
Ding.test()

Ding_test(this) {
   MsgBox % this.foo
}</pre>
      <p>Sobald <code>Ding.test()</code> aufgerufen wird, wird <i>Ding</i> automatisch am Anfang der Parameterliste eingefügt. Doch aus Gründen der Abwärtskompatibilität wird das nicht auftreten, wenn eine Funktion durch den Namen (anstatt durch den Verweis) direkt in das Objekt gespeichert wird (anstatt von einem base-Objekt geerbt zu werden). Vereinbarungsgemäß besteht der Funktionsname aus dem Objekttyp und dem Methodennamen.</p>
      <p>Ein Objekt ist ein <i>Prototyp</i> oder <i>base</i>, falls ein anderes Objekt von ihm abgeleitet wird:</p>
      <pre>Anderes := {}
Anderes.base := Ding
Anderes.test()</pre>
      <p>In diesem Fall erbt <i>Anderes</i> <i>foo</i> und <i>Test</i> von <i>Ding</i>. Diese Vererbung ist dynamisch, das heißt, sobald <code>Ding.foo</code> geändert wird, spiegelt sich die Änderung durch <code>Anderes.foo</code> wider. Wenn das Script auf <code>Anderes.foo</code> verweist, wird der Wert in <i>Anderes</i> gespeichert und alle weiteren Änderungen an <code>Ding.foo</code> beeinflussen nicht <code>Anderes.foo</code>. Sobald <code>Anderes.test()</code> aufgerufen wird, enthält der <i>this</i>-Parameter einen Verweis auf <i>Anderes</i>, anstatt auf <i>Ding</i>. </p>
      <h3 id="Custom_Classes">Klassen <span class="ver">[v1.1.00+]</span></h3>
      <p>Der Einfachheit und Vertrautheit halber kann das "class"-Schlüsselwort verwendet werden, um ein base-Objekt zu konstruieren. Eine grundlegende Klassendefinition könnte wie folgt aussehen:</p>
      <pre>class Klassenname extends BaseKlassenname
{
    Instanzvariable := Ausdruck
    static Klassenvariable := Ausdruck

    class Unterklasse
    {
        ...
    }

    Methode()
    {
        ...
    }
}

</pre>
      <p>Sobald das Script geladen wird, wird ein Objekt konstruiert und in die globale (oder seit v1.1.05 in die <a href="Functions.htm#SuperGlobal">superglobale</a>) Variable <i>Klassenname</i> gespeichert. Um daher diese Klasse vor v1.1.05 innerhalb einer Funktion zu verweisen, ist eine Deklaration wie <code>global Klassenname</code> erforderlich, solange die Funktion nicht im <a href="Functions.htm#AssumeGlobal">Modus für die globale Ansicht</a> ist. Wenn <code>extends BaseKlassenname</code> vorhanden ist, muss der <i>BaseKlassenname</i> der vollständige Name einer anderen Klasse sein (seit v1.1.11 spielt die Reihenfolge, in der sie definiert werden, keine Rolle mehr). Der vollständige Name jeder Klasse ist in <code><i>Objekt</i>.__Class</code> gespeichert.</p>
      <p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und verschachtelte Klassendefinitionen enthalten.</p>
      <pre id="Custom_Classes_var">    Instanzvariable := Ausdruck

</pre>
      <p>Deklarationen von <b>Instanzvariablen</b> <span class="ver">[v1.1.01+]</span> werden jedesmal beim Erstellen einer Klasseninstanz mit dem <a href="#Custom_NewDelete">new</a>-Schlüsselwort ausgewertet. Die <a href="#Custom_NewDelete">__New()</a>-Methode wird nach der Auswertung solcher Deklarationen aufgerufen, einschließlich derjenigen, die in base-Klassen definiert wurden. Der <i>Ausdruck</i> kann mithilfe von <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, alle anderen Variablenverweise werden jedoch als global angesehen. Um auf eine Instanzvariable zuzugreifen, gebt immer das Zielobjekt an; zum Beispiel <code><b>this</b>.Instanzvariable</code>.</p>
      <pre id="Custom_Classes_staticvar">    static Klassenvariable := Ausdruck

</pre>
      <p>Deklarationen von <b>Klassenvariablen</b> <span class="ver">[v1.1.00.01+]</span> werden in der aktuellen Reihenfolge und vor dem <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> nur einmal ausgewertet. Jede Deklaration speichert einen Wert im Klassenobjekt. Wie mit allen Werten oder Methoden vom Klassenobjekt kann dieser Wert durch abgeleitete Objekte geerbt werden. Jeder Variablenverweis im <i>Ausdruck</i> wird als global angesehen. Um auf eine Klassenvariable zuzugreifen, gebt immer die Klasse oder das abgeleitete Objekt an; zum Beispiel <code><b>Klassenname</b>.Klassenvariable</code>.</p>
      <pre id="Custom_Classes_class">    class Unterklasse
    {
        ...
    }

</pre>
      <p>Mit Definitionen von <b>verschachtelten Klassen</b> kann ein Klassenobjekt innerhalb einer anderen Klasse anstelle einer separaten globalen Variable gespeichert werden. Im obigen Beispiel konstruiert <code>class Unterklasse</code> ein Objekt und speichert es in <code>Klassenname.Unterklasse</code>. Daher kann die <i>Unterklasse</i> an Klassen oder Objekte vererbt werden, die vom <i>Klassennamen</i> abgeleitet werden.</p>
      <pre id="Custom_Classes_method">    Methode()
    {
        ...
    }

</pre>
      <p>Definitionen von <b>Methoden</b> sind scheinbar das Gleiche wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der normalerweise einen Verweis auf ein abgeleitetes Objekt der Klasse enthält. Allerdings könnte er auch einen Verweis auf die Klasse selbst oder auf eine abgeleitete Klasse enthalten, je nachdem, wie die Methode aufgerufen wurde. Methoden werden <a href="#Function_References">mittels Verweis</a> in das Klassenobjekt gespeichert.</p>
      <p id="Custom_Classes_base">Zusätzlich zum versteckten Parameter <code>this</code> können Methodendefinitionen das Pseudo-Schlüsselwort <code>base</code> verwenden, um die base-Klasse der Klasse aufzurufen, die die Methodendefinition enthält. Zum Beispiel ist <code>base.Methode()</code> in der oberen Methode gleichwertig mit <code>BaseKlassenname.Methode.(this)</code>. Beachtet, dass sich das von <code>this.base.base.Methode()</code> wie folgt unterscheidet:</p>
      <ul>
        <li>Es ruft immer base von der aktuellen Klasse auf, selbst wenn <code>this</code> von einer <i>Unterklasse</i> der aktuellen Klasse abgeleitet wird.</li>
        <li>Es übergibt <code>this</code> automatisch, aber nicht <code>this.base.base</code>.</li>
      </ul>
      <p><code>base</code> hat nur eine besondere Bedeutung, wenn ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> danach erfolgt, daher funktioniert so etwas wie <code>obj := base, obj.Methode()</code> nicht. Scripts können das Sonderverhalten von <i>base</i> deaktivieren, indem ein nicht-leerer Wert zugewiesen wird; allerdings ist das nicht empfohlen. Da die Variable <i>base</i> leer sein muss, reduziert sich die Performance, wenn im Script <a href="commands/_NoEnv.htm">#NoEnv</a> weggelassen wird.</p>
      <h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
      <p>Sobald ein abgeleitetes Objekt mit dem <code>new</code>-Schlüsselwort erstellt wird <span class="ver">[benötigt v1.1.00+]</span>, wird die definierte <code>__New</code>-Methode über ihr base-Objekt aufgerufen. Diese Methode kann Parameter akzeptieren, das Objekt initialisieren und das Ergebnis des <code>new</code>-Operators durch Zurückgeben eines Wertes überschreiben. Beim Zerstören eines Objekts wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
      <pre>m1 := new GMem(0, 20)
m2 := {base: GMem}.__New(0, 30)

class GMem
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "uint", aFlags, "ptr", aGröße, "ptr")
        If !this.ptr
            Return ""
        MsgBox % "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
        return this  <em>; Diese Zeile kann weggelassen werden, wenn der Operator 'new' verwendet wird.</em>
    }

    __Delete()
    {
        MsgBox % "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "ptr", this.ptr)
    }
}</pre>
      <h3 id="Meta_Functions">Meta-Funktionen</h3>
      <pre class="Syntax"><strong>Methodensyntax:</strong>
class <i>Klassenname</i> {
    __Get([Schlüssel, Schlüssel2, ...])
    __Set([Schlüssel, Schlüssel2, ...], Wert)
    __Call(Name [, Parameter...])
}

<strong>Funktionssyntax:</strong>
<i>MeinGet</i>(this [, Schlüssel, Schlüssel2, ...])
<i>MeinSet</i>(this [, Schlüssel, Schlüssel2, ...], Wert)
<i>MeinCall</i>(this, Name [, Parameter...])

<i>Klassenname</i> := { __Get: Func("<i>MeinGet</i>"), __Set: Func("<i>MeinSet</i>"), __Call: Func("<i>MeinCall</i>") }</pre>
      <p>Meta-Funktionen sind Methoden, die mit base von einem Objekt definiert wurden. Damit kann genau angegeben werden, wie das Objekt agieren soll, falls ein unbekannter Schlüssel angefordert wird. Wenn zum Beispiel dem <code>Objekt.Schlüssel</code> keinen Wert zugewiesen wurde, wird die <i>__Get</i>-Meta-Funktion aufgerufen. Ebenso wird <i>__Set</i> bei <code>Objekt.Schlüssel := Wert</code> und <i>__Call</i> bei <code>Objekt.Schlüssel()</code> aufgerufen.</p>
      <p>In diesen Fällen wird das base-Objekt wie folgt aufgerufen:</p>
      <ul>
        <li>Falls dieses base-Objekt die geeignete Meta-Funktion definiert, wird es aufgerufen. Wenn die Meta-Funktion einen Wert direkt mit <code>Return</code> zurückgibt, wird der Rückgabewert als Ergebnis der Operation verwendet und keine weitere Verarbeitung durchgeführt.
          <p><i>Set</i>: Falls die Operation erfolgreich war, sollte <i>__Set</i> den neuen Wert des Feldes zurückgeben, der möglicherweise vom originalen Rückgabewert abweicht.  Dadurch können Zuweisungen wie in <code>a.x := b.y := z</code> verkettet werden. Falls die Zuweisung nicht erfolgreich war, sollte ein leerer String zurückgegeben werden, damit das Script den Fehler erkennen kann.</p>
        </li>
        <li>Bei einer <i>Get</i>- oder <i>Call</i>-Operation wird ein passender Schlüssel in den Feldern des base-Objekts gesucht.
          <p><i>Get</i>: Wenn er gefunden wird, wird dieser Feldwert zurückgegeben.<br>
            <i>Call</i>: Wenn er gefunden wird, wird die gespeicherte Funktion im Feld aufgerufen (mittels Name oder <a href="#Function_References">Verweis</a>), indem das originale Zielobjekt als <i>this</i>-Parameter übergeben wird.</p>
        </li>
        <li>Eigenes base-Objekt rekursiv aufrufen. Dadurch wird ermöglicht, dass die  Eigenschaften eines Objekts von ihrer base, von der base ihrer base und so weiter "geerbt" werden.</li>
      </ul>
      <p>Wenn (und nur wenn) die Operation von keinem base-Objekt behandelt wird, wird die Verarbeitung wie gewohnt fortgesetzt:</p>
      <ul>
        <li><i>Get</i>: Wenn der Schlüssel "base" ist, wird die base des Objekts abgerufen.</li>
        <li><i>Set</i>: Wenn der Schlüssel "base" ist, wird die base des Objekts gesetzt; Nicht-Objektwerte bewirken, dass die vorhandene base entfernt wird.
          <p style="margin-left: 2.6em; margin-top: 0.25em;">Ansonsten wird ein neues Schlüssel-Wert-Paar erstellt und in das Objekt gespeichert.</p>
        </li>
        <li><i>Call</i>: Eine <a href="objects/Object.htm">interne Methode</a> kann aufgerufen werden.</li>
      </ul>
      <p><b>Bekannte Einschränkungen:</b></p>
      <ul>
        <li>Das Verwenden von <code>Return</code> ohne Wert ist gleichbedeutend mit <code>Return ""</code>. Das kann in einer zukünftigen Version geändert werden, sodass <code>Return</code> verwendet werden kann, um aus einer Meta-Funktion zu "flüchten", ohne dabei das Standardverhalten zu überschreiben.</li>
        <li>Siehe <a href="#ExitLimitation">Exit-Einschränkung</a>.</li>
      </ul>
      <h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
      <p><i>__Get</i> und <i>__Set</i> können verwendet werden, um Eigenschaften zu implementieren, deren Werte auf irgendeiner Weise berechnet oder beschränkt sind. Zum Beispiel könnten sie wie folgt verwendet werden, um ein "Farbe"-Objekt mit R, G, B und RGB-Eigenschaften zu implementieren, in denen tatsächlich nur der RGB-Wert gespeichert wird:</p>
      <pre>rot := new Farbe(0xff0000), rot.R -= 5
cyan := new Farbe(0x00ffff)

MsgBox % "rot: " rot.R "," rot.G "," rot.B " = " rot.RGB
MsgBox % "cyan: " cyan.R "," cyan.G "," cyan.B " = " cyan.RGB

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    __Get(aName)
    {
        If (aName = "R")
            Return (this.RGB &gt;&gt; 16) &amp; 255
        If (aName = "G")
            Return (this.RGB &gt;&gt; 8) &amp; 255
        If (aName = "B")
            Return this.RGB &amp; 255
    }

    __Set(aName, aWert)
    {
        If aName in R,G,B
        {
            aWert &amp;= 255

            If      (aName = "R")
                this.RGB := (aWert &lt;&lt; 16) | (this.RGB &amp; ~0xff0000)
            Else If (aName = "G")
                this.RGB := (aWert &lt;&lt; 8)  | (this.RGB &amp; ~0x00ff00)
            Else  <em>; (aName = "B")</em>
                this.RGB :=  aWert        | (this.RGB &amp; ~0x0000ff)

            <em>; 'Return' muss verwendet werden, um darauf hinzuweisen, dass ein neues Schlüssel-Wert-Paar nicht erstellt werden sollte.
            ; Damit wird auch definiert, was in 'x' von 'x := clr[name] := val' gespeichert wird:</em>
            Return aWert
        }
    }
}</pre>
      <h4 id="Objects_as_Functions">Objekte als Funktionen</h4>
      <p>Bei einem Aufruf wie <code>obj.func(param)</code> könnte <i>obj.func</i> einen Funktionsnamen oder ein Objekt enthalten. Wenn <i>obj.func</i> ein Objekt enthält, wird es mit <i>obj</i> als Schlüssel aufgerufen.  In den meisten Fällen ist <code>obj.func[obj]</code> nicht vorhanden, stattdessen wird die __Call-<a href="#Meta_Functions">Meta-Funktion</a> von <i>obj.func</i> aufgerufen. Das kann verwendet werden, um das Verhalten von Funktionsaufrufen auf einer abstrakten Weise wie folgt zu ändern:</p>
      <pre><em>; Erstellt ein Prototyp für ein Array mit Funktionen.</em>
FuncArrayType := {__Call: "FuncType_Call"}
<em>; Erstellt ein Array mit Funktionen.</em>
funcArray := {1: "Eins", 2: "Zwei", base: FuncArrayType}
<em>; Erstellt ein Objekt, das das Array als Methode verwendet.</em>
obj := {func: funcArray}
<em>; Aufrufen der Methode.</em>
obj.func("foo", "bar")

FuncType_Call(func, obj, params*)
{
    <em>; Aufrufen einer Liste mit Funktionen.</em>
    Loop % ObjMaxIndex(func)
        func[A_Index](params*)
}

Eins(param1, param2) {
    ListVars
    Pause
}
Zwei(param1, param2) {
    ListVars
    Pause
}</pre>
      <p>Sobald diese Technik mit Klassendefinitionen kombiniert wird, können die dynamischen Eigenschaften aus dem vorherigen Abschnitt bequem definiert werden:</p>
      <pre>blau := new Farbe(0x0000ff)
MsgBox % blau.R "," blau.G "," blau.B

class Eigenschaften
{
    __Call(aTarget, aName, aParams*)
    {
        <em>; Falls dieses Eigenschaftsobjekt eine Definition für diese Halb-Eigenschaft enthält, ruft es auf.
        ; Achtet darauf, nicht this.HasKey(aName) zu verwenden, da das sonst in  __Call rekursiv ausgeführt wird.</em>
        If IsObject(aZiel) &amp;&amp; ObjHasKey(this, aName)
            Return this[aName].(aZiel, aParams*)
    }
}

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    class __Get extends Eigenschaften
    {
        R() {
            Return (this.RGB &gt;&gt; 16) &amp; 255
        }
        G() {
            Return (this.RGB &gt;&gt; 8) &amp; 255
        }
        B() {
            Return this.RGB &amp; 255
        }
    }

    <em>;...</em>
}</pre>
      <h4 id="Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</h4>
      <p>Sobald ein neues Objekt mithilfe einer <a href="#Usage_Arrays_of_Arrays">Multiparameter-Zuweisung</a> wie <code>Tabelle[x, y] := Inhalt</code> indirekt erstellt wird, besitzt das neue Objekt keine base und folglich keine benutzerdefinierten Methoden oder Sonderverhalten. <code>__Set</code> könnte benutzt werden, um diese Objekte wie folgt zu initialisieren.</p>
      <pre>x := {base: {addr: Func("x_Addr"), __Set: Func("x_Setter")}}

<em>; Wert zuweisen, indirekt x_Setter aufrufen, um Unterobjekte zu erstellen.</em>
x[1,2,3] := "..."

<em>; Wert abrufen und Beispielmethode aufrufen.</em>
MsgBox % x[1,2,3] "`n" x.addr() "`n" x[1].addr() "`n" x[1,2].addr()

x_Setter(x, p1, p2, p3) {
    x[p1] := new x.base
}

x_Addr(x) {
    Return &amp;x
}</pre>
      <p>Da <code>x_Setter</code> vier vorgeschriebene Parameter hat, wird es nur aufgerufen, sobald zwei oder mehr Schlüsselparameter vorhanden sind. Wenn die Zuweisung von oben durchgeführt wird, passiert Folgendes:</p>
      <ul>
        <li><code>x[1]</code> existiert nicht, daher wird <code>x_Setter(x,1,2,3)</code> aufgerufen (<code>"..."</code> wird nicht übergeben, da zu wenig Parameter vorhanden sind).
          <ul>
            <li><code>x[1]</code> wird ein neues Objekt mit derselben base wie <code>x</code> zugewiesen.</li>
            <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
          </ul>
        </li>
        <li><code>x[1][2]</code> existiert nicht, daher wird <code>x_Setter(x[1],2,3,"...")</code> aufgerufen.
          <ul>
            <li><code>x[1][2]</code> wird ein neues Objekt mit derselben base wie <code>x[1]</code> zugewiesen.</li>
            <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
          </ul>
        </li>
        <li><code>x[1][2][3]</code> existiert nicht, da <code>x_Setter</code> aber vier Parameter benötigt und nur drei vorhanden sind (<code>x[1][2], 3, "..."</code>), wird es nicht aufgerufen und die Zuweisung normal beendet.</li>
      </ul>
      <h2 id="Default_Base_Object">Standard-base-Objekt</h2>
      <p>Sobald ein Nicht-Objekt-Wert im Objekt-Syntax verwendet wird, wird das <i>Standard-base-Objekt</i> aufgerufen. Zum einen fürs Debuggen nützlich, zum anderen, um ein objektähnliches Verhalten für Strings, Zahlen und/oder Variablen global zu definieren. Die Standard-base ist zugänglich, indem <code>.base</code> mit einem Nicht-Objekt-Wert verwendet wird; zum Beispiel <code>"".base</code>.  Obwohl die Standard-base nicht wie in <code>"".base := Object()</code> <i>gesetzt</i> werden kann, könnte die Standard-base selbst eine base wie in <code>"".base.base := Object()</code> haben.</p>
      <h4 id="Automatic_Var_Init">Automatische Variableninitialisierung</h4>
      <p>Falls eine leere Variable als Ziel für eine <i>Set</i>-Operation verwendet wird, wird sie direkt an die __Set-Meta-Funktion übergeben, wodurch sie ein neues Objekt in die Variable einfügen kann. Aus Platzgründen unterstützt dieses Beispiel nicht mehr als ein Parameter; mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> wäre das möglich.</p>
      <pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox % empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    If (var = "")
        var := Object(key, value)
}</pre>
      <h4 id="Pseudo_Properties">Pseudo-Eigenschaften</h4>
      <p>Die vereinfachte Syntax des Objekts gilt auch für Strings und Zahlen.</p>
      <pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox % A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox % A_AhkPath.length.is("integer")

Default_Get_PseudoProperty(nonobj, key)
{
    If (key = "length")
        Return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    If nonobj is %type%
        Return true
    Return false
}</pre>
      <p>Beachtet, dass interne Funktionen auch verwendet werden können, aber die Klammern in diesem Fall nicht weggelassen werden können:</p>
      <pre>"".base.length := Func("StrLen")
MsgBox % A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>
      <h4 id="Default__Warn">Debuggen</h4>
      <p>Falls ein Wert nicht als Objekt behandelt werden soll, kann eine Warnmeldung angezeigt werden, sobald ein Nicht-Objekt-Wert aufgerufen wird:</p>
      <pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1="", p2="", p3="", p4="")
{
    ListLines
    MsgBox Ein Nicht-Objekt-Wert wurde unsachgemäß aufgerufen.`n`nSpeziell: %nonobj%
}</pre>
      <h2 id="Implementation">Implementierung</h2>
      <h3 id="Reference_Counting">Referenzzählung</h3>
      <p>AutoHotkey verwendet ein grundlegendes Referenz-Zählwerk, um benutzte Ressourcen eines Objekts automatisch freizugeben, falls es nicht länger durch das Script verwiesen wird. Script-Autoren sollten dieses Zählwerk nicht unbedingt aufrufen, es sei denn, sie arbeiten direkt mit unverwalteten Pointer auf Objekte. Für weitere Informationen, siehe <a href="commands/ObjAddRef.htm">ObjAddRef</a>.</p>
      <pre><em>; Erhöht die Referenzzählung des Objekts, um "es am Leben zu erhalten":</em>
<a href="commands/ObjAddRef.htm">ObjAddRef</a>(Adresse)
...
<em>; Verringert die Referenzzählung des Objekts, damit sie freigegeben werden kann:</em>
ObjRelease(Adresse)

</pre>
      <p>Allerdings muss ObjAddRef nicht verwendet werden, wenn eine Adresse mithilfe von <code><a href="#Implementation_Pointers">Object(obj)</a></code> sofort bezogen wird.</p>
      <p>Generell sollte jede neue Kopie einer Objektadresse als ein Objektverweis behandelt werden, nur nicht, wenn das Script wie vorgesehen für den Aufruf von ObjAddRef und/oder ObjRelease verantwortlich ist. Sobald zum Beispiel eine Adresse mit <code>x := Adresse</code> kopiert wird, sollte ObjAddRef aufgerufen werden, um die Referenzzählung zu erhöhen. Sobald außerdem das Script mit einer bestimmten Kopie der Objektadresse fertig ist, sollte es ObjRelease aufrufen. Dadurch wird sichergestellt, dass das Objekt freigegeben wird, wenn der letzte Verweis davon verloren gegangen ist - und nicht vorher.</p>
      <p>Um Code beim Freigeben des letzten Verweises auf ein Objekt auszuführen, implementiert die <a href="#Custom_NewDelete">__Delete</a>-Meta-Funktion.</p>
      <p><b>Bekannte Einschränkungen:</b></p>
      <ul>
        <li>Zirkelbezüge müssen gebrochen werden, bevor ein Objekt freigegeben werden kann. Für Details und ein Beispiel, siehe <a href="#Circular_References">Freigeben von Objekten</a>. </li>
        <li>Obwohl Verweise in statischen und globalen Variablen automatisch beim Beenden des Programms freigegeben werden, gilt das nicht für Verweise in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel. Diese Verweise werden nur freigegeben, wenn die Funktion oder der Ausdruck normal beendet werden konnte.</li>
      </ul>
      <p>Obwohl der verwendete Speicher des Objekts beim Beenden des Programms vom Betriebssystem wiedergewonnen wird, wird <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen, wenn alle Verweise auf das Objekt freigegeben wurden. Das kann wichtig sein, wenn es andere Ressourcen freigibt, die nicht automatisch durch das Betriebssystem wiedergewonnen werden, wie zum Beispiel temporäre Dateien.</p>
      <h3 id="Implementation_Pointers">Pointer auf Objekte</h3>
      <p>In einigen seltenen Fällen kann es erforderlich sein, mithilfe von DllCall ein Objekt an einen externen Code zu übergeben oder es in eine binäre Datenstruktur für den späteren Abruf zu speichern. Eine Objektadresse kann mithilfe von <code>x := &amp;obj</code> abgerufen werden; falls die Variable <i>obj</i> allerdings geleert wird, könnte das Objekt vorzeitig freigegeben werden. Damit so etwas nicht passiert, verwendet ObjAddRef wie oben oder die <code>Object()</code>-Funktion wie folgt:</p>
      <pre>Adresse := Object(Objekt)</pre>
      <p>Darüber hinaus kann diese Funktion auch verwendet werden, um die Adresse wieder in ein Verweis umzuwandeln:</p>
      <pre>Objekt := Object(Adresse)</pre>
      <p>In jedem Fall wird die <a href="#Reference_Counting">Referenzzählung</a> des Objekts automatisch erhöht, damit das Objekt nicht vorzeitig freigegeben wird.</p>
      <p>Beachtet, dass diese Funktionen ebenso für Objekte gelten, die nicht mit <a href="#Usage_Associative_Arrays">Object()</a> erstellt wurden, wie <a href="commands/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="objects/File.htm">File-Objekte</a>.</p>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(0);</script>
</body>
</html>
