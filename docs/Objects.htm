<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Objekte</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="css/default.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="../NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(1);</script>


<h1>Objekte</h1>

<p>In AutoHotkey ist ein <i>Objekt</i> eine abstrakte Datenstruktur, die drei grundlegende Funktionen erm&ouml;glicht:</p>
<ul>
  <li>GET - Abrufen eines Wertes.</li>
  <li>SET - Setzen eines Wertes.</li>
  <li>CALL - Aufrufen einer Methode (eine Funktion, die das Zielobjekt beeinflusst).</li>
</ul>
<p>Ein Objekt<i>verweis</i> ist ein Pointer oder Handle auf ein bestimmtes Objekt. Objektverweise k&ouml;nnen wie Strings und Zahlen in Variablen gespeichert werden, an Funktionen &uuml;bergeben oder von Funktionen zur&uuml;ckgegeben werden und in Objekten gespeichert werden. Falls eine Variable, die einen Verweis enth&auml;lt, in eine andere Variable kopiert wird (z. B. mit <code>x := y</code>), verweisen beide Variablen auf das gleiche Objekt.</p>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Es sind folgende Objekttypen enthalten:</p>
<ul>
  <li><a href="objects/Object.htm"><b>Objekt</b></a> - scriptf&auml;higes assoziatives Array.</li>
  <li><a href="objects/File.htm">Datei</a> - erm&ouml;glicht eine Schnittstelle f&uuml;r die Dateibearbeitung.</li>
  <li><a href="objects/Func.htm">Funktion</a> - eine Funktion.</li>
  <li><a href="commands/ComObjCreate.htm">ComObject</a> - Verpackt eine IDispatch-Schnittstelle (ein COM oder "Automatisierungsobjekt").</li>
</ul>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlagen</a> - <a href="#Usage_Simple_Arrays">Einfache Arrays</a>, <a href="#Usage_Associative_Arrays">Assoziative Arrays</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Remarks">Bemerkungen</a></li>
  <li><a href="#Extended_Usage">Erweiterte Grundlagen</a> - <a href="#Function_References">Funktionsverweise</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>, <a href="#Usage_Arrays_of_Functions">Arrays mit Funktionen</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#Custom_Prototypes">Prototypen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Meta-Funktionen</a></li>
  <li><a href="#Default_Base_Object">Standard-Basisobjekt</a> - <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzz&auml;hlung</a>, <a href="#Implementation_Pointers">Pointer auf Objekte</a></li>
</ul>

<a name="Syntax"></a><h2 id="Usage">Grundlagen</h2>

<h3 id="Usage_Simple_Arrays">Einfache Arrays</h3>
<p>Erstellen eines Arrays:</p>
<pre>Array := [Element1, Element2, ..., ElementN]
Array := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Index]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Index] := Wert</pre>
<p>Anf&uuml;gen eines Elements:</p>
<pre>Array.<a href="objects/Object.htm#Insert">Insert</a>(Wert)</pre>
<p>Einf&uuml;gen beliebig vieler Elemente ab einem bestimmten Index:</p>
<pre>Array.<a href="objects/Object.htm#Insert">Insert</a>(Index, Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Remove">Remove</a>(Index)</pre>
<p>Falls das Array nicht leer ist, werden <a href="objects/Object.htm#MinMaxIndex">MinIndex</a> und <a href="objects/Object.htm#MinMaxIndex">MaxIndex</a> jeweils den niedrigsten und h&ouml;chsten Index zur&uuml;ckgeben, der zurzeit im Array benutzt wird. Da der niedrigste Index fast immer 1 ist, wird MaxIndex f&uuml;r gew&ouml;hnlich die Anzahl an Elemente zur&uuml;ckgeben. Der Inhalt des Arrays kann per Index oder mit einer For-Schleife durchlaufen werden. Zum Beispiel:</p>
<pre>array := ["eins", "zwei", "drei"]

<em>; Iterieren von 1 bis zur Gesamtanzahl der Elemente:</em>
<a href="commands/Loop.htm">Loop</a> % array.MaxIndex()
    MsgBox % array[A_Index]

<em>; Den Inhalt des Arrays enumerieren:</em>
<a href="commands/For.htm">For</a> Index, Wert in array
    MsgBox % "Element " Index " enth&auml;lt '" Wert "'"

</pre>

<a name="Arrays"></a><h3 id="Usage_Associative_Arrays">Assoziative Arrays</h3>
<p>Ein assoziatives Array ist ein Objekt, das eine Sammlung von eindeutigen Schl&uuml;sseln und Werten enth&auml;lt, wobei jeder Wert einem Schl&uuml;ssel zugeordnet ist. Schl&uuml;ssel k&ouml;nnen Strings, Integer oder Objekte sein, w&auml;hrend die Werte beliebige Typen sein k&ouml;nnen. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>Array := {Schl&uuml;sselA: WertA, Schl&uuml;sselB: WertB, ..., Schl&uuml;sselZ: WertZ}
Array := Object("Schl&uuml;sselA", WertA, "Schl&uuml;sselB", WertB, ..., "Schl&uuml;sselZ", WertZ)</pre>
<p>Beim Verwenden der Notation <code>{Schl&uuml;ssel:Wert}</code> sind Anf&uuml;hrungszeichen f&uuml;r Schl&uuml;ssel optional, solange sie nur aus Wortzeichen bestehen. Jeder Ausdruck kann als Schl&uuml;ssel verwendet werden; um jedoch eine Variable als Schl&uuml;ssel zu benutzen, umschlie&szlig;t sie mit Klammern. Zum Beispiel sind <code>{(Schl&uuml;sselVar): Wert}</code> und <code>{GetKey(): Wert}</code> g&uuml;ltig.</p>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Schl&uuml;ssel]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Schl&uuml;ssel] := Wert</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Remove">Remove</a>(Schl&uuml;ssel)</pre>
<p>Enumerieren von Elementen:</p>
<pre>array := {zehn: 10, zwanzig: 20, drei&szlig;ig: 30}
<a href="commands/For.htm">For</a> Schl&uuml;ssel, Wert in array
    MsgBox %Schl&uuml;ssel% = %Wert%</pre>
<p>Assoziative Arrays k&ouml;nnen klein gehalten werden - zum Beispiel enth&auml;lt <code>{1: "a", 1000: "b"}</code> nur zwei Schl&uuml;ssel-Wert-Paare, nicht 1000.</p>
<p id="same_thing">Inzwischen wurde vielleicht schon bemerkt, dass sich die Syntaxen von assoziativen Arrays und von einfachen Arrays sehr &auml;hneln. Tats&auml;chlich sind sie das Gleiche in v1.x. Solange <code>[]</code> als einfaches lineares Array behandelt wird, bleibt dessen Rolle klar und erh&ouml;ht die Chance, dass das eigene Script mit einer zuk&uuml;nftigen Version von AutoHotkey weiterhin funktioniert, in der die Implementierung m&ouml;glicherweise ge&auml;ndert wurde.</p>

<h3 id="Usage_Objects">Objekte</h3>
<p>Abrufen einer Eigenschaft:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<p>Setzen einer Eigenschaft:</p>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Aufrufen einer Methode:</p>
<pre>R&uuml;ckgabewert := Objekt.Methode(Parameter)</pre>
<p>Aufrufen einer Methode mit einem errechneten Methodennamen:</p>
<pre>R&uuml;ckgabewert := Object[Methodenname](Parameter)</pre>
<p>Einige Eigenschaften von COM-Objekten und benutzerdefinierten Objekten k&ouml;nnen Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Parameter]
Objekt.Eigenschaft[Parameter] := Wert</pre>
<p><strong>Verwandte Befehle:</strong> <a href="objects/Object.htm">Objekt</a>, <a href="objects/File.htm">Datei-Objekt</a>, <a href="objects/Func.htm">Funktionsobjekt</a>, <a href="commands/ComObjCreate.htm">COM-Objekt</a></p>
<p><b>Bekannte Einschr&auml;nkung:</b></p>
<ul>
<li>Zurzeit wird <code><span class="dull">x</span>.y[z]<span class="dull">()</span></code> als <code><span class="dull">x</span>["y", z]<span class="dull">()</span></code> behandelt, dass nicht unterst&uuml;tzt wird. Als &Uuml;bergangsl&ouml;sung wird <code>x.y</code> in <code><span class="red">(</span><span class="dull">x.y</span><span class="red">)</span>[z]()</code> zuerst ausgewertet und danach das Ergebnis als Ziel des Methodenaufrufs verwendet. Beachtet, dass <code>x.y[z].()</code> nicht diese Einschr&auml;nkung hat, da es wie <code>(x.y[z]).()</code> ausgewertet wird.</li></ul>

<h3 id="Usage_Remarks">Bemerkungen</h3>

<h4>Syntax</h4>
<p>Alle Objektarten unterst&uuml;tzen sowohl die Array-Syntax (eckige Klammern) als auch die Objekt-Syntax (Punkte).</p>
<p>Dar&uuml;ber hinaus k&ouml;nnen Objektverweise auch in Ausdr&uuml;cke verwendet werden:</p>
<ul>
  <li>Wenn ein Objektverweis mit irgendeinem anderen Wert mithilfe von <code>= == != &lt;&gt;</code> verglichen wird, dann werden sie nur als gleich angesehen, wenn beide Werte auf dasselbe Objekt verweisen.</li>
  <li>Objekte werden immer als <i>wahr</i> angesehen, falls ein boolescher Wert erforderlich ist, wie z. B. in <code>If obj</code>, <code>!obj</code> oder <code>obj ? x : y</code>.</li>
  <li>Eine Objektadresse kann mithilfe des <code>&amp;</code>-Operators abgerufen werden. Damit kann das Objekt eindeutig identifiziert werden, sobald sein letzter Verweis <a href="#Refs">freigegeben</a> wird.</li>
</ul>
<p>Sobald ein Objekt in einem Rahmen verwendet wird, in dem ein Objekt nicht erwartet wird, wird es als einen leeren String behandelt. Zum Beispiel zeigt <code>MsgBox %Objekt%</code> eine leere MsgBox an und <code>Objekt + 1</code> ergibt einen leeren String. Man sollte sich nicht auf dieses Verhalten verlassen, da sich das noch &auml;ndern kann.</p>
<p>Falls nach einem Methodenaufruf unmittelbar ein Zuweisungsoperator erfolgt, dann wird eine Eigenschaft mit Parametern gesetzt. Zum Beispiel sind beide Angaben gleichwertig:</p>
<pre>obj.item(x) := y
obj.item[x] := y</pre>
<p id="cassign">Verbundzuweisungen wie <code>x.y += 1</code> und <code>--arr[1]</code> werden unterst&uuml;tzt.</p>

<h4>Schl&uuml;ssel</h4>
<p>Einige Einschr&auml;nkungen gelten beim Zuweisen von Werten an Schl&uuml;ssel des Objekts, das mit <code>[]</code>, <code>{}</code> oder dem <code>new</code>-Operator erstellt wurde:</p>
<ul>
  <li>Integer-Schl&uuml;ssel werden im urspr&uuml;nglichen signed Integer-Typ gespeichert. AutoHotkey 32-Bit unterst&uuml;tzt Integer-Schl&uuml;ssel im Bereich von -2147483648 bis 2147483647. AutoHotkey unterst&uuml;tzt 64-Bit-Integer, aber nur AutoHotkey 64-Bit unterst&uuml;tzt den vollen Umfang f&uuml;r Schl&uuml;ssel in einem Objekt.</li>
  <li>Daher wird das String-Format von Integer-Werten nicht beibehalten. Zum Beispiel sind <code>x[0x10]</code>, <code>x[16]</code> und <code>x[00016]</code> gleichwertig. Das gilt auch f&uuml;r numerische Strings, die keinen Dezimalpunkt enthalten.</li>
  <li>Direkt vorhandene Strings in Anf&uuml;hrungszeichen werden in v1.x als rein nicht-numerisch angesehen, daher sind <code>x[1]</code> und <code>x["1"]</code> <i>nicht</i> gleichwertig. Wenn dar&uuml;ber hinaus ein direkt vorhandener String in Anf&uuml;hrungszeichen mit anderen Werten verkettet wird (wie in <code>"0x" x</code>), wird das Ergebnis als rein nicht-numerisch behandelt. Allerdings gilt das nicht f&uuml;r Variablen, somit sind <code>x[1]</code> und <code>x[y:="1"]</code> gleichwertig. Dieses Problem wird in v2 gel&ouml;st, daher sollten Scripts vermeiden, numerische Literale in Anf&uuml;hrungszeichen als Schl&uuml;ssel zu verwenden.</li>
  <li>Flie&szlig;kommazahlen werden nicht als Schl&uuml;ssel unterst&uuml;tzt - stattdessen werden sie in Strings umgewandelt. In v1.x behalten Flie&szlig;komma-Literale ihr urspr&uuml;ngliches Format, w&auml;hrend reine Flie&szlig;kommazahlen (wie z. B. das Ergebnis von <code>0+1.0</code> oder <code>Sqrt(y)</code>) das aktuelle <a href="commands/SetFormat.htm">Float-Format</a> erzwingen. Aus Gr&uuml;nden der Konsistenz und Klarheit sollten Scripts vermeiden, Flie&szlig;komma-Literale als Schl&uuml;ssel zu verwenden.</li>
  <li>Der String-Schl&uuml;ssel <a href="#Custom_Objects">"base"</a> hat eine besondere Bedeutung, au&szlig;er es wird mit <a href="objects/Object.htm#Insert">Insert</a> verwendet.


<p></p></li>
</ul>

<h2 id="Extended_Usage">Erweiterte Grundlagen</h2>
<h3 id="Function_References">Funktionsverweise <span class="ver">[v1.1.00+]</span></h3>
<p>Wenn die Variable <i>Funktion</i> einen Funktionsnamen enth&auml;lt, kann die Funktion wie folgt aufgerufen werden: <code>%Funktion%()</code> oder <code>Funktion.()</code>. Allerdings muss die Funktion dabei jedesmal aufgel&ouml;st werden, dass ineffizient ist, falls die Funktion mehr als einmal aufgerufen wird. Um die Performance zu verbessern, kann das Script einen Verweis auf die Funktion abrufen und sie f&uuml;r sp&auml;ter speichern:</p>
<pre>Funktion := Func("EigeneFunktion")</pre>
<p>Um eine Funktion mit einem Verweis aufzurufen, muss die folgende Syntax verwendet werden:</p>
<pre>R&uuml;ckgabewert := Funktion.(<i>Parameter</i>)</pre>
<p>F&uuml;r Details &uuml;ber zus&auml;tzliche Eigenschaften von Funktionsverweise, siehe <a href="objects/Func.htm">Funktionsobjekt</a>.</p>
<p><a name="ExitLimitation"></a><b>Bekannte Einschr&auml;nkung:</b></p>
<ul>
<li>Wenn die Funktion, sowie eine von ihr aufgerufene Subroutine oder Funktion, <a href="commands/Exit.htm">Exit</a> verwendet, dann verh&auml;lt sie sich wie beim Funktionsaufruf, der einen neuen Thread erstellt hat. Das hei&szlig;t, sie kehrt sofort zum Aufrufer der Funktion zur&uuml;ck, anstatt den aktuellen Thread zu beenden. Allerdings bewirkt das Exit weiterhin, dass das Script beendet wird, falls es nicht <a href="commands/_Persistent.htm">persistent</a> ist.</li></ul>

<h3 id="Usage_Arrays_of_Arrays"><a name="JaggedArrays"></a>Mehrdimensionale Arrays</h3>
<p>AutoHotkey unterst&uuml;tzt "mehrdimensionale" Arrays, indem Arrays in andere Arrays gespeichert werden. Zum Beispiel k&ouml;nnte eine Tabelle einen Array von Reihen repr&auml;sentieren, wobei jede Reihe selbst ein Array von Spalten ist. In diesem Fall kann der Inhalt der Spalte <code>y</code> der Reihe <code>x</code> mithilfe einer folgenden Methode gesetzt werden:</p>
<pre>Tabelle[x][y] := Inhalt  <em>; A</em>
Tabelle[x, y] := Inhalt  <em>; B</em></pre>
<p>Falls <code>Tabelle[x]</code> nicht vorhanden ist, unterscheiden sich <span class="Code"><em>A</em></span> und <span class="Code"><em>B</em></span> wie folgt:</p>
<ul>
  <li><span class="Code"><em>A</em></span> schl&auml;gt fehl, w&auml;hrend <span class="Code"><em>B</em></span> automatisch ein Objekt erstellt und es in <code>Tabelle[x]</code> speichert.</li>
  <li>Wenn die <a href="#Custom_Objects">Basis</a> von <code>Tabelle</code> <a href="#Meta_Functions">Meta-Funktionen</a> definiert, dann werden sie wie folgt aufgerufen:
  


<pre>Tabelle.base.__Get(Tabelle, x)<span class="dull">[y] := Inhalt</span>   <em>; A</em>
Tabelle.base.__Set(Tabelle, x, y, Inhalt)     <em>; B</em></pre>
  Folglich erm&ouml;glicht <em><span class="Code">B</span></em>, dass das Objekt ein benutzerdefiniertes Verhalten f&uuml;r die gesamte Zuweisung definieren kann.</li>
</ul>
<p>Dieses Verhalten gilt nur f&uuml;r erstellte Objekte von Scripts, nicht f&uuml;r Sondertypen von Objekten wie COM-Objekte oder COM-Arrays.</p>

<h3 id="Usage_Arrays_of_Functions"><a name="FuncArrays"></a>Arrays mit Funktionen</h3>
<p>Ein Array mit Funktionen ist im Prinzip ein Array, das Funktionsnamen oder Verweise enth&auml;lt. Zum Beispiel:</p>
<pre>Array := [Func("ErsteFunktion"), Func("ZweiteFunktion")]

<em>; Aufrufen jeder Funktion, &Uuml;bergabe von "foo" als Parameter:</em>
Loop 2
    Array[A_Index].("foo")

<em>; Aufrufen jeder Funktion, indirekte &Uuml;bergabe desselben Arrays als Parameter:</em>
Loop 2
    Array[A_Index]()

ErsteFunktion(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}
ZweiteFunktion(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}</pre>
<p>F&uuml;r die Abw&auml;rtskompatibilit&auml;t wird die zweite Form das <i>Array</i> nicht als Parameter &uuml;bergeben, wenn <code>Array[A_Index]</code> einen Funktionsnamen anstelle einer Funktionsreferenz enth&auml;lt. Falls jedoch <code>Array[A_Index]</code> von <code>Array.base[A_Index]</code> <a href="#Custom_Objects">geerbt</a> wird, wird das <i>Array</i> als Parameter &uuml;bergeben.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>AutoHotkey-Objekte basieren auf Prototypen, anstatt auf Klassen. Das hei&szlig;t, dass ein Objekt die Eigenschaften und Methoden von seinem Prototyp oder <code>Basis</code>-Objekt erben kann, aber eine vordefinierte Struktur nicht angegeben werden muss. Eigenschaften und Methoden k&ouml;nnen zu einem Objekt oder zu Objekten, die jederzeit davon abgeleitet werden, hinzugef&uuml;gt werden (bzw. davon entfernt werden). Jedoch wird AutoHotkey die Klassen emulieren, indem <a href="#Custom_Classes">Klassendefinitionen</a> in gew&ouml;hnliche Objekte umgewandelt werden. Bei komplexere oder speziellere Situationen kann das Standardverhalten vom Basisobjekt &uuml;berschrieben werden, indem <i><a href="#Meta_Functions">Meta-Funktionen</a></i> definiert werden.</p>
<p>Um ein Objekt zu erstellen, das von einem anderen Objekt abgeleitet wurde, k&ouml;nnen Scripts das <code>base</code> zuweisen oder das <code>new</code>-Schl&uuml;sselwort verwenden:</p>
<pre>Basisobjekt := {foo: "bar"}
obj1 := Object(), obj1.base := Basisobjekt
obj2 := {base: Basisobjekt}
obj3 := new Basisobjekt
MsgBox % obj1.foo " " obj2.foo " " obj3.foo</pre>

<h3 id="Custom_Prototypes">Prototypen</h3>
<p>Prototyp- oder <code>Basis</code>-Objekte werden genauso wie andere Objekte konstruiert und manipuliert. Zum Beispiel ist es m&ouml;glich, ein gew&ouml;hnliches Objekt mit einer Eigenschaft und Methode wie folgt zu konstruieren:</p>
<pre><em>; Erstellt ein Objekt.</em>
Ding := {}
<em>; Speichert ein Wert.</em>
Ding.foo := "bar"
<em>; Erstellt eine Methode durch Speichern eines Funktionsverweises.</em>
Ding.test := Func("Ding_test")
<em>; Ruft die Methode auf.</em>
Ding.test()

Ding_test(this) {
   MsgBox % this.foo
}</pre>
<p>Sobald <code>Ding.test()</code> aufgerufen wird, wird <i>Ding</i> automatisch am Anfang der Parameterliste eingef&uuml;gt. Doch aus Gr&uuml;nden der Abw&auml;rtskompatibilit&auml;t wird das nicht auftreten, wenn eine Funktion durch den Namen (anstatt durch den Verweis) direkt in das Objekt gespeichert wird (anstatt von einem Basisobjekt geerbt zu werden). Vereinbarungsgem&auml;&szlig; besteht der Funktionsname aus dem Objekttyp und dem Methodennamen.</p>
<p>Ein Objekt ist ein <i>Prototyp</i> oder eine <i>Basis</i>, falls ein anderes Objekt von ihm abgeleitet wird:</p>
<pre>Anderes := {}
Anderes.base := Ding
Anderes.test()</pre>
<p>In diesem Fall erbt <i>Anderes</i> <i>foo</i> und <i>Test</i> von <i>Ding</i>. Diese Vererbung ist dynamisch, das hei&szlig;t, sobald <code>Ding.foo</code> ge&auml;ndert wird, spiegelt sich die &Auml;nderung durch <code>Anderes.foo</code> wider. Wenn das Script auf <code>Anderes.foo</code> verweist, wird der Wert in <i>Anderes</i> gespeichert und alle weiteren &Auml;nderungen an <code>Ding.foo</code> beeinflussen nicht <code>Anderes.foo</code>. Sobald <code>Anderes.test()</code> aufgerufen wird, enth&auml;lt der <i>this</i>-Parameter einen Verweis auf <i>Anderes</i>, anstatt auf <i>Ding</i>.
</p>

<h3 id="Custom_Classes">Klassen <span class="ver">[v1.1.00+]</span></h3>
<p>Der Einfachheit und Vertrautheit halber kann das "class"-Schl&uuml;sselwort verwendet werden, um ein Basisobjekt zu konstruieren. Eine grundlegende Klassendefinition k&ouml;nnte wie folgt aussehen:</p>
<pre>class Klassenname extends Basisklassenname
{
    Instanzvariable := Ausdruck
    static Klassenvariable := Ausdruck

    class Unterklasse
    {
        ...
    }

    Methode()
    {
        ...
    }
}

</pre>
<p>Sobald das Script geladen wird, wird ein Objekt konstruiert und in die globale (oder seit v1.1.05 in die <a href="Functions.htm#SuperGlobal">superglobale</a>) Variable <i>Klassenname</i> gespeichert. Um daher diese Klasse vor v1.1.05 innerhalb einer Funktion zu verweisen, ist eine Deklaration wie <code>global Klassenname</code> erforderlich, solange die Funktion nicht im <a href="Functions.htm#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> ist. Wenn <code>extends Basisklassenname</code> vorhanden ist, muss der <i>Basisklassenname</i> der vollst&auml;ndige Name einer zuvor definierten Klasse sein. Der vollst&auml;ndige Name jeder Klasse ist in <code><i>Objekt</i>.__Class</code> gespeichert.</p>
<p>Klassendefinitionen k&ouml;nnen Variablendeklarationen, Methodendefinitionen und verschachtelte Klassendefinitionen enthalten.</p>
<pre id="Custom_Classes_var">    Instanzvariable := Ausdruck

</pre>
<p>Deklarationen von <b>Instanzvariablen</b> <span class="ver">[v1.1.01+]</span> werden jedesmal beim Erstellen einer Klasseninstanz mit dem <a href="#Custom_NewDelete">new</a>-Schl&uuml;sselwort ausgewertet. Die <a href="#Custom_NewDelete">__New()</a>-Methode wird nach der Auswertung solcher Deklarationen aufgerufen, einschlie&szlig;lich derjenigen, die in Basisklassen definiert wurden. Der <i>Ausdruck</i> kann mithilfe von <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, alle anderen Variablenverweise werden jedoch als global angesehen. Um auf eine Instanzvariable zuzugreifen, gebt immer das Zielobjekt an; zum Beispiel <code><b>this</b>.Instanzvariable</code>.</p>
<pre id="Custom_Classes_staticvar">    static Klassenvariable := Ausdruck

</pre>
<p>Deklarationen von <b>Klassenvariablen</b> <span class="ver">[v1.1.00.01+]</span> werden in der aktuellen Reihenfolge und vor dem <a href="Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> nur einmal ausgewertet. Jede Deklaration speichert einen Wert im Klassenobjekt. Wie mit allen Werten oder Methoden vom Klassenobjekt kann dieser Wert durch abgeleitete Objekte geerbt werden. Jeder Variablenverweis im <i>Ausdruck</i> wird als global angesehen. Um auf eine Klassenvariable zuzugreifen, gebt immer die Klasse oder das abgeleitete Objekt an; zum Beispiel <code><b>Klassenname</b>.Klassenvariable</code>.</p>
<pre id="Custom_Classes_class">    class Unterklasse
    {
        ...
    }

</pre>
<p>Mit Definitionen von <b>verschachtelten Klassen</b> kann ein Klassenobjekt innerhalb einer anderen Klasse anstelle einer separaten globalen Variable gespeichert werden. Im obigen Beispiel konstruiert <code>class Unterklasse</code> ein Objekt und speichert es in <code>Klassenname.Unterklasse</code>. Daher kann die <i>Unterklasse</i> an Klassen oder Objekte vererbt werden, die vom <i>Klassennamen</i> abgeleitet werden.</p>
<pre id="Custom_Classes_method">    Method()
    {
        ...
    }

</pre>
<p>Definitionen von <b>Methoden</b> sind scheinbar das Gleiche wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der normalerweise einen Verweis auf ein abgeleitetes Objekt der Klasse enth&auml;lt. Allerdings k&ouml;nnte er auch einen Verweis auf die Klasse selbst oder auf eine abgeleitete Klasse enthalten, je nachdem, wie die Methode aufgerufen wurde. Methoden werden <a href="#Function_References">mittels Verweis</a> in das Klassenobjekt gespeichert.</p>
<p id="Custom_Classes_base">Zus&auml;tzlich zum versteckten Parameter <code>this</code> k&ouml;nnen Methodendefinitionen das Pseudo-Schl&uuml;sselwort <code>base</code> verwenden, um die Basisklasse der Klasse aufzurufen, die die Methodendefinition enth&auml;lt. Zum Beispiel ist <code>base.Methode()</code> in der oberen Methode gleichwertig mit <code>Basisklassenname.Methode.(this)</code>, au&szlig;er dass die globale Variable <i>Basisklassenname</i> nicht deklariert werden muss. Beachtet, dass sich das von <code>this.base.base.Methode()</code> wie folgt unterscheidet:</p>
<ul>
  <li>Es ruft immer die Basis der aktuellen Klasse auf, selbst wenn <code>this</code> von einer <i>Unterklasse</i> der aktuellen Klasse abgeleitet wird.</li>
  <li>Es &uuml;bergibt <code>this</code> automatisch, aber nicht <code>this.base.base</code>.</li>
</ul>
<p><code>base</code> hat nur eine besondere Bedeutung, wenn ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> danach erfolgt, daher funktioniert so etwas wie <code>obj := base, obj.Methode()</code> nicht. Scripts k&ouml;nnen das Sonderverhalten von <i>base</i> deaktivieren, indem ein nicht-leerer Wert zugewiesen wird; allerdings ist das nicht empfohlen. Da die Variable <i>base</i> leer sein muss, reduziert sich die Performance, wenn das Script <a href="commands/_NoEnv.htm">#NoEnv</a> wegl&auml;sst.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Sobald ein abgeleitetes Objekt mit dem <code>new</code>-Schl&uuml;sselwort erstellt wird <span class="ver">[ben&ouml;tigt v1.1.00+]</span>, wird die definierte <code>__New</code>-Methode &uuml;ber ihr Basisobjekt aufgerufen. Diese Methode kann Parameter akzeptieren, das Objekt initialisieren und das Ergebnis des <code>new</code>-Operators durch Zur&uuml;ckgeben eines Wertes &uuml;berschreiben. Beim Zerst&ouml;ren eines Objekts wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := new GMem(0, 20)
m2 := {base: GMem}.__New(0, 30)

class GMem
{
    __New(aFlags, aGr&ouml;&szlig;e)
    {
        this.ptr := DllCall("GlobalAlloc", "uint", aFlags, "ptr", aGr&ouml;&szlig;e, "ptr")
        If !this.ptr
            Return ""
        MsgBox % "New GMem mit einer Gr&ouml;&szlig;e von " aGr&ouml;&szlig;e " Bytes auf der Adresse " this.ptr "."
    }

    __Delete()
    {
        MsgBox % "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "ptr", this.ptr)
    }
}</pre>

<h3 id="Meta_Functions">Meta-Funktionen</h3>
<p>Meta-Funktionen sind Methoden, die mit der Basis eines Objekts definiert wurden. Damit kann genau angegeben werden, wie das Objekt agieren soll, falls ein unbekannter Schl&uuml;ssel angefordert wird. Wenn zum Beispiel dem <code>Objekt.Schl&uuml;ssel</code> keinen Wert zugewiesen wurde, wird die <i>__Get</i>-Meta-Funktion aufgerufen. Ebenso wird <i>__Set</i> bei <code>Objekt.Schl&uuml;ssel := Wert</code> und <i>__Call</i> bei <code>Objekt.Schl&uuml;ssel()</code> aufgerufen.</p>
<p>In diesen F&auml;llen wird das Basisobjekt wie folgt aufgerufen:</p>
<ul>
  <li>Falls dieses Basisobjekt die geeignete Meta-Funktion definiert, wird es aufgerufen. Wenn die Meta-Funktion einen Wert direkt mit <code>Return</code> zur&uuml;ckgibt, wird der R&uuml;ckgabewert als Ergebnis der Operation verwendet und keine weitere Verarbeitung durchgef&uuml;hrt.
    


<p><i>Set</i>: Falls die Operation erfolgreich war, sollte <i>__Set</i> den neuen Wert des Feldes zur&uuml;ckgeben, der m&ouml;glicherweise vom originalen R&uuml;ckgabewert abweicht.  Dadurch k&ouml;nnen Zuweisungen wie in <code>a.x := b.y := z</code> verkettet werden. Falls die Zuweisung nicht erfolgreich war, sollte ein leerer String zur&uuml;ckgegeben werden, damit das Script den Fehler erkennen kann.</p></li>
  <li>Bei einer <i>Get</i>- oder <i>Call</i>-Operation wird ein passender Schl&uuml;ssel in den Feldern des Basisobjekts gesucht.
    


<p><i>Get</i>: Wenn er gefunden wird, wird dieser Feldwert zur&uuml;ckgegeben.<br> <i>Call</i>: Wenn er gefunden wird, wird die gespeicherte Funktion im Feld aufgerufen (mittels Name oder <a href="#Function_References">Verweis</a>), indem das originale Zielobjekt als <i>this</i>-Parameter &uuml;bergeben wird.</p></li>
  <li>Eigenes Basisobjekt rekursiv aufrufen. Dadurch wird erm&ouml;glicht, dass die  Eigenschaften eines Objekts von ihrer Basis, von der Basis ihrer Basis und so weiter "geerbt" werden.</li>
</ul>
<p>Wenn (und nur wenn) die Operation von keinem Basisobjekt behandelt wird, wird die Verarbeitung wie gewohnt fortgesetzt:</p>
<ul>
  <li><i>Get</i>: Wenn der Schl&uuml;ssel "base" ist, wird die Basis des Objekts abgerufen.</li>
  <li><i>Set</i>: Wenn der Schl&uuml;ssel "base" ist, wird die Basis des Objekts gesetzt; Nicht-Objektwerte bewirken, dass die vorhandene Basis entfernt wird.
  


<p style="margin-left: 2.6em; margin-top: 0.25em;">Ansonsten wird ein neues Schl&uuml;ssel-Wert-Paar erstellt und in das Objekt gespeichert.</p></li>
  <li><i>Call</i>: Eine <a href="objects/Object.htm">interne Methode</a> kann aufgerufen werden.</li>
</ul>
<p><b>Bekannte Einschr&auml;nkungen:</b></p>
<ul>
<li>Das Verwenden von <code>Return</code> ohne Wert ist gleichbedeutend mit <code>Return ""</code>. Das kann in einer zuk&uuml;nftigen Version ge&auml;ndert werden, sodass <code>Return</code> verwendet werden kann, um aus einer Meta-Funktion zu "fl&uuml;chten", ohne dabei das Standardverhalten zu &uuml;berschreiben.</li>
<li>Siehe <a href="#ExitLimitation">Exit-Einschr&auml;nkung</a>.</li></ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p><i>__Get</i> und <i>__Set</i> k&ouml;nnen verwendet werden, um Eigenschaften zu implementieren, deren Werte auf irgendeiner Weise berechnet oder beschr&auml;nkt sind. Zum Beispiel k&ouml;nnten sie wie folgt verwendet werden, um ein "Farbe"-Objekt mit R, G, B und RGB-Eigenschaften zu implementieren, in denen tats&auml;chlich nur der RGB-Wert gespeichert wird:</p>
<pre>rot := new Farbe(0xff0000), rot.R -= 5
cyan := new Farbe(0x00ffff)

MsgBox % "rot: " rot.R "," rot.G "," rot.B " = " rot.RGB
MsgBox % "cyan: " cyan.R "," cyan.G "," cyan.B " = " cyan.RGB

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    __Get(aName)
    {
        If (aName = "R")
            Return (this.RGB &gt;&gt; 16) &amp; 255
        If (aName = "G")
            Return (this.RGB &gt;&gt; 8) &amp; 255
        If (aName = "B")
            Return this.RGB &amp; 255
    }

    __Set(aName, aWert)
    {
        If aName in R,G,B
        {
            aWert &amp;= 255

            If      (aName = "R")
                this.RGB := (aWert &lt;&lt; 16) | (this.RGB &amp; ~0xff0000)
            Else If (aName = "G")
                this.RGB := (aWert &lt;&lt; 8)  | (this.RGB &amp; ~0x00ff00)
            Else  <em>; (aName = "B")</em>
                this.RGB :=  aWert        | (this.RGB &amp; ~0x0000ff)

            <em>; 'Return' muss verwendet werden, um darauf hinzuweisen, dass ein neues Schl&uuml;ssel-Wert-Paar nicht erstellt werden sollte.
            ; Damit wird auch definiert, was in 'x' von 'x := clr[name] := val' gespeichert wird:</em>
            Return aWert
        }
    }
}</pre>

<h4 id="Objects_as_Functions">Objekte als Funktionen</h4>
<p>Bei einem Aufruf wie <code>obj.func(param)</code> k&ouml;nnte <i>obj.func</i> einen Funktionsnamen oder ein Objekt enthalten. Wenn <i>obj.func</i> ein Objekt enth&auml;lt, wird es mit <i>obj</i> als Schl&uuml;ssel aufgerufen.  In den meisten F&auml;llen ist <code>obj.func[obj]</code> nicht vorhanden, stattdessen wird die __Call-<a href="#Meta_Functions">Meta-Funktion</a> von <i>obj.func</i> aufgerufen. Das kann verwendet werden, um das Verhalten von Funktionsaufrufen auf einer abstrakten Weise wie folgt zu &auml;ndern:</p>
<pre><em>; Erstellt ein Prototyp f&uuml;r ein Array mit Funktionen.</em>
FuncArrayType := {__Call: "FuncType_Call"}
<em>; Erstellt ein Array mit Funktionen.</em>
funcArray := {1: "Eins", 2: "Zwei", base: FuncArrayType}
<em>; Erstellt ein Objekt, das das Array als Methode verwendet.</em>
obj := {func: funcArray}
<em>; Aufrufen der Methode.</em>
obj.func("foo", "bar")

FuncType_Call(func, obj, params*)
{
    <em>; Aufrufen einer Liste mit Funktionen.</em>
    Loop % ObjMaxIndex(func)
        func[A_Index](params*)
}

Eins(param1, param2) {
    ListVars
    Pause
}
Zwei(param1, param2) {
    ListVars
    Pause
}</pre>
<p>Sobald diese Technik mit Klassendefinitionen kombiniert wird, k&ouml;nnen die dynamischen Eigenschaften aus dem vorherigen Abschnitt bequem definiert werden:</p>
<pre>blau := new Farbe(0x0000ff)
MsgBox % blau.R "," blau.G "," blau.B

class Eigenschaften
{
    __Call(aTarget, aName, aParams*)
    {
        <em>; Falls dieses Eigenschaftsobjekt eine Definition f&uuml;r diese Halb-Eigenschaft enth&auml;lt, ruft es auf.
        ; Achtet darauf, nicht this.HasKey(aName) zu verwenden, da das sonst in  __Call rekursiv ausgef&uuml;hrt wird.</em>
        If IsObject(aZiel) &amp;&amp; ObjHasKey(this, aName)
            Return this[aName].(aZiel, aParams*)
    }
}

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    class __Get extends Eigenschaften
    {
        R() {
            Return (this.RGB &gt;&gt; 16) &amp; 255
        }
        G() {
            Return (this.RGB &gt;&gt; 8) &amp; 255
        }
        B() {
            Return this.RGB &amp; 255
        }
    }

    <em>;...</em>
}</pre>

<h4 id="Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</h4>
<p>Sobald ein neues Objekt mithilfe einer <a href="#Usage_Arrays_of_Arrays">Multiparameter-Zuweisung</a> wie <code>Tabelle[x, y] := Inhalt</code> indirekt erstellt wird, besitzt das neue Objekt keine Basis und folglich keine benutzerdefinierten Methoden oder Sonderverhalten. <code>__Set</code> k&ouml;nnte benutzt werden, um diese Objekte wie folgt zu initialisieren.</p>
<pre>x := {base: {addr: Func("x_Addr"), __Set: Func("x_Setter")}}

<em>; Wert zuweisen, indirekt x_Setter aufrufen, um Unterobjekte zu erstellen.</em>
x[1,2,3] := "..."

<em>; Wert abrufen und Beispielmethode aufrufen.</em>
MsgBox % x[1,2,3] "`n" x.addr() "`n" x[1].addr() "`n" x[1,2].addr()

x_Setter(x, p1, p2, p3) {
    x[p1] := new x.base
}

x_Addr(x) {
    Return &amp;x
}</pre>
<p>Da <code>x_Setter</code> vier vorgeschriebene Parameter hat, wird es nur aufgerufen, sobald zwei oder mehr Schl&uuml;sselparameter vorhanden sind. Wenn die Zuweisung von oben durchgef&uuml;hrt wird, passiert Folgendes:</p>
<ul>
  <li><code>x[1]</code> existiert nicht, daher wird <code>x_Setter(x,1,2,3)</code> aufgerufen (<code>"..."</code> wird nicht &uuml;bergeben, da zu wenig Parameter vorhanden sind).</li>
  <ul>
    <li><code>x[1]</code> wird ein neues Objekt mit derselben Basis wie <code>x</code> zugewiesen.</li>
    <li>Kein R&uuml;ckgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul>
  <li><code>x[1][2]</code> existiert nicht, daher wird <code>x_Setter(x[1],2,3,"...")</code> aufgerufen.</li>
  <ul>
    <li><code>x[1][2]</code> wird ein neues Objekt mit derselben Basis wie <code>x[1]</code> zugewiesen.</li>
    <li>Kein R&uuml;ckgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul>
  <li><code>x[1][2][3]</code> existiert nicht, da <code>x_Setter</code> aber vier Parameter ben&ouml;tigt und nur drei vorhanden sind (<code>x[1][2], 3, "..."</code>), wird es nicht aufgerufen und die Zuweisung normal beendet.</li>
</ul>

<h2 id="Default_Base_Object">Standard-Basisobjekt</h2>
<p>Sobald ein Nicht-Objekt-Wert im Objekt-Syntax verwendet wird, wird das <i>Standard-Basisobjekt</i> aufgerufen. Zum einen f&uuml;rs Debuggen n&uuml;tzlich, zum anderen, um ein objekt&auml;hnliches Verhalten f&uuml;r Strings, Zahlen und/oder Variablen global zu definieren. Die Standardbasis ist zug&auml;nglich, indem <code>.base</code> mit einem Nicht-Objekt-Wert verwendet wird; zum Beispiel <code>"".base</code>.  Obwohl die Standardbasis nicht wie in <code>"".base := Object()</code> <i>gesetzt</i> werden kann, k&ouml;nnte die Standardbasis selbst eine Basis wie in <code>"".base.base := Object()</code> haben.</p>

<h4 id="Automatic_Var_Init">Automatische Variableninitialisierung</h4>
<p>Falls eine leere Variable als Ziel f&uuml;r eine <i>Set</i>-Operation verwendet wird, wird sie direkt an die __Set-Meta-Funktion &uuml;bergeben, wodurch sie ein neues Objekt in die Variable einf&uuml;gen kann. Aus Platzgr&uuml;nden unterst&uuml;tzt dieses Beispiel nicht mehr als ein Parameter; mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> w&auml;re das m&ouml;glich.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox % empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    If (var = "")
        var := Object(key, value)
}</pre>

<h4 id="Pseudo_Properties">Pseudo-Eigenschaften</h4>
<p>Die vereinfachte Syntax des Objekts gilt auch f&uuml;r Strings und Zahlen.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox % A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox % A_AhkPath.length.is("integer")

Default_Get_PseudoProperty(nonobj, key)
{
    If (key = "length")
        Return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    If nonobj is %type%
        Return true
    Return false
}</pre>
<p>Beachtet, dass interne Funktionen auch verwendet werden k&ouml;nnen, aber die Klammern in diesem Fall nicht weggelassen werden k&ouml;nnen:</p>
<pre>"".base.length := Func("StrLen")
MsgBox % A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h4 id="Default__Warn">Debuggen</h4>
<p>Falls ein Wert nicht als Objekt behandelt werden soll, kann eine Warnmeldung angezeigt werden, sobald ein Nicht-Objekt-Wert aufgerufen wird:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1="", p2="", p3="", p4="")
{
    ListLines
    MsgBox Ein Nicht-Objekt-Wert wurde unsachgem&auml;&szlig; aufgerufen.`n`nSpeziell: %nonobj%
}</pre>

<h2 id="Implementation">Implementierung</h2>
<a name="Refs"></a><h3 id="Reference_Counting">Referenzz&auml;hlung</h3>
<p>AutoHotkey verwendet ein grundlegendes Referenz-Z&auml;hlwerk, um benutzte Ressourcen eines Objekts automatisch freizugeben, falls es nicht l&auml;nger durch das Script verwiesen wird. Script-Autoren sollten dieses Z&auml;hlwerk nicht unbedingt aufrufen, es sei denn, sie arbeiten direkt mit unverwalteten Pointer auf Objekte. F&uuml;r weitere Informationen, siehe <a href="commands/ObjAddRef.htm">ObjAddRef</a>.</p>
<pre><em>; Erh&ouml;ht die Referenzz&auml;hlung des Objekts, um "es am Leben zu erhalten":</em>
<a href="commands/ObjAddRef.htm">ObjAddRef</a>(Adresse)
...
<em>; Verringert die Referenzz&auml;hlung des Objekts, damit sie freigegeben werden kann:</em>
ObjRelease(Adresse)

</pre>
<p>Allerdings muss ObjAddRef nicht verwendet werden, wenn eine Adresse mithilfe von <code><a href="#AddressCast">Object(obj)</a></code> sofort bezogen wird.</p>
<p>Generell sollte jede neue Kopie einer Objektadresse als ein Objektverweis behandelt werden, nur nicht, wenn das Script wie vorgesehen f&uuml;r den Aufruf von ObjAddRef und/oder ObjRelease verantwortlich ist. Sobald zum Beispiel eine Adresse wie z.B. mit <code>x := Adresse</code> kopiert wird, sollte ObjAddRef aufgerufen werden, um die Referenzz&auml;hlung zu erh&ouml;hen. Sobald au&szlig;erdem das Script mit einer bestimmten Kopie der Objektadresse fertig ist, sollte es ObjRelease aufrufen. Dadurch wird sichergestellt, dass das Objekt freigegeben wird, wenn der letzte Verweis davon verloren gegangen ist - und nicht vorher.</p>
<p>Um Code beim Freigeben des letzten Verweises auf ein Objekt auszuf&uuml;hren, implementiert die <a href="#Custom_NewDelete">__Delete</a>-Meta-Funktion.</p>
<p><b>Bekannte Einschr&auml;nkungen:</b></p>
<ul>
  <li>Zirkelbez&uuml;ge m&uuml;ssen gebrochen werden, bevor ein Objekt freigegeben werden kann. Zum Beispiel:
  


<pre><em>; Erstellt zwei Objekte.</em>
x := {}, y := {}
<em>; Erstellt ein Zirkelbezug.</em>
x.untergeordnet := y, y.&uuml;bergeordnet := x

<em>; SCHLECHT:</em>
x := "", y := ""

<em>; Gut:</em>
y.&uuml;bergeordnet := ""  <em>; Bricht den Kreislauf.</em>
x := "", y := ""</pre></li>
  <li>Obwohl Verweise in statischen und globalen Variablen automatisch beim Beenden des Programms freigegeben werden, gilt das nicht f&uuml;r Verweise in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel. Diese Verweise werden nur freigegeben, wenn die Funktion oder der Ausdruck normal beendet werden konnte.</li>
</ul>
<p>Obwohl der verwendete Speicher des Objekts beim Beenden des Programms vom Betriebssystem wiedergewonnen wird, wird <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen, wenn alle Verweise auf das Objekt freigegeben wurden. Das kann wichtig sein, wenn es andere Ressourcen freigibt, die nicht automatisch durch das Betriebssystem wiedergewonnen werden, wie zum Beispiel tempor&auml;re Dateien.</p>

<a name="AddressCast"></a><h3 id="Implementation_Pointers">Pointer auf Objekte</h3>
<p>In einigen seltenen F&auml;llen kann es erforderlich sein, mithilfe von DllCall ein Objekt an einen externen Code zu &uuml;bergeben oder es in eine bin&auml;re Datenstruktur f&uuml;r den sp&auml;teren Abruf zu speichern. Eine Objektadresse kann mithilfe von <code>x := &amp;obj</code> abgerufen werden; falls die Variable <i>obj</i> allerdings geleert wird, k&ouml;nnte das Objekt vorzeitig freigegeben werden. Damit so etwas nicht passiert, verwendet ObjAddRef wie oben oder die <code>Object()</code>-Funktion wie folgt:</p>
<pre>Adresse := Object(Objekt)</pre>
<p>Dar&uuml;ber hinaus kann diese Funktion auch verwendet werden, um die Adresse wieder in ein Verweis umzuwandeln:</p>
<pre>Objekt := Object(Adresse)</pre>
<p>In jedem Fall wird die <a href="#Refs">Referenzz&auml;hlung</a> des Objekts automatisch erh&ouml;ht, damit das Objekt nicht vorzeitig freigegeben wird.</p>
<p>Beachtet, dass diese Funktionen ebenso f&uuml;r Objekte gelten, die nicht mit <a href="#Arrays">Object()</a> erstellt wurden, wie <a href="commands/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="objects/File.htm">Datei-Objekte</a>.</p>
</body></html>