<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Neubelegung von Tasten</title>
<meta name="description" content="Free keyboard remapper that can also remap mouse and joystick buttons. It can also automate repetitive tasks by sending keystrokes &amp; mouse clicks.">
<meta name="keywords" content="keyboard,remapper,remap,remapping,keys,key,keystrokes,clicks,mouse,buttons,button,joystick,hotkeys,hotkey">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="alternate" type="application/rss+xml" title="AutoHotkey Forum RSS" href="../../forum/rss.php">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Neubelegung von Tasten</h1>

<h2>Einf&uuml;hrung</h2>
<p>Diese hier beschriebene Funktion wird weder f&uuml;r Joysticks unterst&uuml;tzt noch funktioniert sie in Windows 95/98/Me. Daf&uuml;r gibt es folgende Alternativmethoden:</p>
<ul>
  <li><a href="#Win9x">Neubelegung in Windows 9x</a></li>
  <li><a href="RemapJoystick.htm">Joystick-Neubelegung</a></li>
</ul>
<p><strong>Einschr&auml;nkung</strong>: Die unten beschriebene Neubelegungsfunktion von AutoHotkey ist in der Regel nicht so eindeutig und effektiv wie das direkte Neubelegen der Windows-Registrierung. F&uuml;r die Vor- und Nachteile der einzelnen Ans&auml;tze, siehe <a href="#registry">Neubelegung mit der Registrierung</a>.</p>
<h2 id="Remap">Tastatur und Maus neu belegen</h2>
<p></p>
<h3>Neubelegung der Tastatur</h3>
<p>Die Syntax f&uuml;r die interne Neubelegungsfunktion lautet <span class="Syntax">Originaltaste::Zieltaste</span>. Sobald zum Beispiel ein <a href="../Scripts.htm">Script</a> folgende Zeile enth&auml;lt, verh&auml;lt sich die Taste <kbd>A</kbd> wie die Taste <kbd>B</kbd>:</p>
<pre>a::b</pre>
<p>Im oberen Beispiel wird die Taste <kbd>B</kbd> selbst nicht ver&auml;ndert. Diese wird weiterhin ein "b" senden, solange sie nicht wie im folgenden Beispiel neu belegt wird:</p>
<pre>a::b
b::a</pre>
<p>In den oberen Beispielen sollten wenn m&ouml;glich Kleinbuchstaben verwendet werden, weil dabei auch die entsprechenden Gro&szlig;buchstaben neu belegt werden (das hei&szlig;t, dass Gro&szlig;buchstaben gesendet werden, sobald die Feststelltaste aktiv ist oder die Umschalt-Taste gedr&uuml;ckt gehalten wird). Falls auf der rechten Seite hingegen ein Gro&szlig;buchstabe angegeben ist, wird die Gro&szlig;schreibung erzwungen. Zum Beispiel erzeugt die folgende Zeile ein gro&szlig;geschriebenes B, wenn "a" oder "A" eingegeben wird (solange die Feststelltaste deaktiviert ist):</p>
<pre>a::B <br></pre>
<p></p>
<h3><a name="RemapMouse"></a>Neubelegung der Maus</h3>
<p>Um stattdessen die Maus neu zu belegen, verwendet die gleiche Methode. Zum Beispiel:</p>
<table class="info">
  <tbody>
<tr>
    <td>MButton::Shift</td>
    <td>Die mittlere Maustaste verh&auml;lt sich wie <kbd>Umschalt</kbd>.</td>
  </tr>
  <tr>
    <td>XButton1::LButton</td>
    <td>Die vierte Maustaste verh&auml;lt sich wie die linke Maustaste.</td>
  </tr>
  <tr>
    <td>RAlt::RButton</td>
    <td><kbd>RAlt</kbd> verh&auml;lt sich wie die rechte Maustaste.</td></tr></tbody></table>
<h3>Weitere n&uuml;tzliche Neubelegungen</h3>
<table class="info">
  <tbody>
<tr>
    <td>Capslock::Ctrl</td>
    <td><kbd>Feststell</kbd> verh&auml;lt sich wie <kbd>Strg</kbd>. Um die Umschaltf&auml;higkeit der Feststelltaste zu erhalten, f&uuml;gt au&szlig;erdem&nbsp; <code>+Capslock::Capslock</code> hinzu (damit wird die Feststelltaste aktiviert oder deaktiviert, wenn der Benutzer die Umschalttaste gedr&uuml;ckt h&auml;lt und dabei die Feststelltaste dr&uuml;ckt).</td>
  </tr>
  <tr>
    <td>XButton2::^LButton</td>
    <td>Die f&uuml;nfte Maustaste (XButton2) erzeugt <kbd>Strg</kbd>+Linksklick.</td>
  </tr>
  <tr>
    <td>RAlt::AppsKey</td>
    <td><kbd>RAlt</kbd> verh&auml;lt sich wie <kbd>Men&uuml;</kbd> (&ouml;ffnet das Kontextmen&uuml;).</td>
  </tr>
  <tr>
    <td>RCtrl::RWin</td>
    <td><kbd>RStrg</kbd> verh&auml;lt sich wie <kbd>RWin</kbd>.</td>
  </tr>
  <tr>
    <td>Ctrl::Alt</td>
    <td><kbd>Strg</kbd> verh&auml;lt sich wie <kbd>Alt</kbd>. Siehe jedoch <a href="#AltTab">Alt-Tab-Probleme</a>.</td>
  </tr>
  <tr>
    <td>^x::^c</td>
    <td><kbd>Strg</kbd>+<kbd>X</kbd> erzeugt <kbd>Strg</kbd>+<kbd>C</kbd>. F&uuml;hrt auch dazu, dass <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>X</kbd> die Tastenkombination <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>C</kbd> erzeugt, usw.</td>
  </tr>
  <tr>
    <td>RWin::Return</td>
    <td>Deaktiviert <kbd>RWin</kbd>, indem ihr einfach ein <a href="../commands/Return.htm">Return</a> zugewiesen wird.</td>
  </tr>
</tbody></table>
<p>Die oben genannten Beispiele k&ouml;nnen ausprobiert werden, indem sie in einer neuen Textdatei z. B. namens "Remap.ahk" kopiert werden und die Datei danach ausgef&uuml;hrt wird.</p>
<p>In der <a href="../KeyList.htm">Tastenliste</a> k&ouml;nnen alle Tastennamen der Tastatur und Maus gefunden werden.</p>
<h2>Bemerkungen</h2>
<p>Mit den Anweisungen <a href="../commands/_IfWinActive.htm">#IfWinActive/Exist</a> k&ouml;nnen die Neubelegungen nur f&uuml;r bestimmte Fenster g&uuml;ltig gemacht werden. Zum Beispiel:</p>
<pre>#IfWinActive ahk_class Notepad
a::b  <em>; Im Editor verh&auml;lt sich die Taste "a" wie die Taste "b".</em>
#IfWinActive  <em>; Alle nachfolgenden Neubelegungen und Hotkeys gelten f&uuml;r alle Fenster.</em></pre>
<p>Die Neubelegung einer Taste ist bei folgenden Ma&szlig;nahmen "vollst&auml;ndig":</p>
<ul>
  <li>Wenn ein Modifikator wie <kbd>Strg</kbd> oder <kbd>Umschalt</kbd> gedr&uuml;ckt gehalten wird, w&auml;hrend die originale Taste eingegeben wird, wird dieser Modifikator f&uuml;r die Zieltaste wirksam. Zum Beispiel w&uuml;rde <code>b::a</code> die Tastenkombination <kbd>Strg</kbd>+<kbd>A</kbd> erzeugen, falls <kbd>Strg</kbd>+<kbd>B</kbd> gedr&uuml;ckt wird.</li>
  <li>Generell beeinflusst die Feststelltaste neu belegte Tasten auf die gleiche Weise wie normale Tasten.</li>
  <li>Die Zieltaste wird gedr&uuml;ckt gehalten, solange die originale Taste gedr&uuml;ckt gehalten wird. Allerdings unterst&uuml;tzen einige Spiele keine Neubelegung. In solchen F&auml;llen werden die Neubelegungen einfach von der Tastatur und Maus ignoriert.</li>
  <li>Neu belegte Tasten werden automatisch wiederholt, w&auml;hrend sie gedr&uuml;ckt gehalten werden (au&szlig;er Tasten, die mit Maustasten neu belegt wurden).</li>
</ul>
<p><a name="HookHotkeys"></a>Obwohl eine neu belegte Taste normale Hotkeys ausl&ouml;sen kann, kann sie dennoch keine Maus- oder <a href="../commands/_UseHook.htm">Hook-Hotkeys</a> ausl&ouml;sen (mit <a href="../commands/ListHotkeys.htm">ListHotkeys</a> k&ouml;nnen Hook-Hotkeys festgestellt werden). Falls zum Beispiel die Neubelegung <code>a::b</code> aktiv ist, wird durch Dr&uuml;cken von  <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd> der Hotkey ^!b ausgel&ouml;st, solange ^!b kein Hook-Hotkey ist. Ist ^!b jedoch ein Hook-Hotkey, kann ^!a als ein Hotkey definiert werden, damit <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd> die gleiche Aktion wie <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>B</kbd> ausf&uuml;hrt. Zum Beispiel:</p>
<pre>a::b
^!a::
^!b::
ToolTip %A_ThisHotkey% wurde gedr&uuml;ckt.
Return</pre>
<p><a name="SendPlay"></a>Wenn <a href="../commands/SendMode.htm">SendMode</a> im automatischen Ausf&uuml;hrungsbereich verwendet wird (oberste Teil des Scripts), werden alle Neubelegungen davon beeinflusst. Da jedoch die Neubelegung <a href="../commands/Send.htm#blind">Send {Blind}</a> verwendet, das vom <a href="../commands/SendMode.htm">SendPlay-Modus</a> nicht vollst&auml;ndig unterst&uuml;tzt wird, funktionieren m&ouml;glicherweise einige Neubelegungen nicht richtig im SendPlay-Modus (besonders <kbd>Strg</kbd>, <kbd>Umschalt</kbd>, <kbd>Alt</kbd> und <kbd>Win</kbd>). Als &Uuml;bergangsl&ouml;sung sollte SendPlay im automatischen Ausf&uuml;hrungsbereich weggelassen werden, falls Neubelegungen vorhanden sind - verwendet <a href="../commands/Send.htm#SendPlay">SendPlay</a> anstelle von Send. Alternativ k&ouml;nnen die Neubelegungen auch in Hotkeys umgewandelt werden (wie unten beschrieben), die SendEvent anstelle von Send direkt aufrufen.</p>
<p>Sobald ein Script gestartet wird, wird jede Neubelegung in zwei <a href="../Hotkeys.htm">Hotkeys</a> umgewandelt. Zum Beispiel enth&auml;lt ein Script mit <code>a::b</code><em></em> stattdessen folgende zwei Hotkeys:</p>
<pre>*<strong>a</strong>::
SetKeyDelay -1   <em>; Wenn die Zieltaste eine Maustaste ist, dann verwendet stattdessen SetMouseDelay.</em>
Send <a href="../commands/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownTemp}  <em>; DownTemp ist wie Down, nur dass andere Send-Befehle im Script nicht davon ausgehen, dass "b" w&auml;hrend des Sendens unten bleiben soll.</em>
Return

*<strong>a up</strong>::
SetKeyDelay -1  <em>; Siehe den unteren Hinweis, warum die Druckdauer nicht mit einem der beiden SetKeyDelays angegeben wird.</em>
Send {Blind}{<strong>b</strong> Up}
Return</pre>
<p>Allerdings unterscheiden sich die oberen Hotkeys unter folgenden Umst&auml;nden:</p>
<ol>
  <li>Sobald <kbd>LStrg</kbd> die Originaltaste und <kbd>Alt</kbd> die Zieltaste ist, wird die Zeile <code>Send {Blind}{LAlt DownTemp}</code> mit <code>Send {Blind}<strong>{LCtrl Up}</strong>{LAlt DownTemp}</code> ersetzt. Das Gleiche gilt, wenn <kbd>RStrg</kbd> das Original ist, jedoch ohne {RCtrl up}.</li>
  <li>Sobald eine Tastatur-Taste mit einer Maustaste (z. B. <code>RCtrl::RButton</code>) neu belegt wird, verwenden die oben genannten Hotkeys SetMouseDelay anstelle von SetKeyDelay. Dar&uuml;ber hinaus wird der erste oben genannte Hotkey mit folgendem ersetzt, um die automatische Wiederholung von Maustasten zu verhindern:
    


















































<pre>*RCtrl::
SetMouseDelay -1
If not GetKeyState("RButton")  <em>; d. h. die rechte Maustaste wurde noch nicht gedr&uuml;ckt.</em>
    Send {Blind}{RButton DownTemp}
Return</pre>
  </li>
</ol>
<p>Beachtet, dass der zweite Parameter (<a href="../commands/SetKeyDelay.htm#dur">Druckdauer</a>) von SetKeyDelay bei den oben genannten Hotkeys entf&auml;llt. Denn die Druckdauer gilt nicht f&uuml;r den dr&uuml;ckenden und loslassenden Status, wie z. B. {b down} und {b up}. Allerdings gilt die Druckdauer weiterhin f&uuml;r die Status&auml;nderungen der Tasten <kbd>Umschalt</kbd>, <kbd>Strg</kbd>, <kbd>Alt</kbd> und <kbd>Win</kbd>, die Neubelegungen wie <code>a::B</code> oder <code>a::^b</code> beeinflussen. Folglich gilt die Druckdauer, die im <a href="../Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> aktiviert wurde, f&uuml;r alle Neubelegungen.</p>
<p>Obwohl ein Tastenpaar nicht direkt mit einer Taste neu belegt werden kann (z. B. ist <code>a &amp; c::b</code> ung&uuml;ltig), kann dieser Effekt dennoch erreicht werden, indem die Up- und Down-Hotkeys von weiter oben direkt hinzugef&uuml;gt werden: ersetzt einfach <code>*a::</code> mit <code>a &amp; c::</code>, und <code>*a up::</code> mit <code>a &amp; c up::</code></p>
<p>Da Neubelegungen wie oben beschrieben in Hotkeys umgewandelt werden, werden sie vom <a href="../commands/Suspend.htm">Suspend</a>-Befehl beeinflusst. Ebenso kann mit dem <a href="../commands/Hotkey.htm">Hotkey</a>-Befehl eine Neubelegung deaktiviert oder bearbeitet werden. Zum Beispiel deaktivieren die zwei folgenden Befehle die Neubelegung <code>a::b</code>.</p>
<pre>Hotkey, *a, off
Hotkey, *a up, off</pre>
<p><a name="AltTab"></a>Alt-Tab-Probleme: Wenn eine Taste oder Maustaste mit <kbd>Alt</kbd> neu belegt wird, dann ist diese Taste wahrscheinlich nicht in der Lage, ein Alt-Tab-Ereignis richtig auszuf&uuml;hren. Als m&ouml;gliche &Uuml;bergangsl&ouml;sung kann der Hotkey <code>*Tab::Send {Blind}{Tab}</code> hinzugef&uuml;gt werden. Seit euch aber bewusst, dass dabei wahrscheinlich das wirkliche <kbd>Alt</kbd> beim Alt-Tab gest&ouml;rt wird. Daher sollte der Hotkey nur verwendet werden, wenn das Alt-Tab ausschlie&szlig;lich mit neu belegten Tasten und/oder <a href="../Hotkeys.htm#alttab">Alt-Tab-Hotkeys</a> ausgef&uuml;hrt wird.</p>
<p>Zus&auml;tzlich zu den Tasten und Maustasten in der <a href="../KeyList.htm">Tastenliste</a> kann die Originaltaste auch eine virtuelle Taste (VKnn) oder ein Scancode (SCnnn) sein (siehe <a href="../KeyList.htm#SpecialKeys">Sondertasten</a>). Das Gleiche gilt auch f&uuml;r die Zieltaste, aber mit der Ausnahme, dass nach der virtuellen Taste optional auch ein Scancode angegeben werden kann. Zum Beispiel ist bei den meisten Tastaturbelegungen  <code>sc01e::vk42sc030</code> das Gleiche wie <code>a::b</code>.</p>
<p>Um eine Taste stattdessen zu deaktivieren, erstellt ein Hotkey, der nur ein <a href="../commands/Return.htm">Return</a> enth&auml;lt. Zum Beispiel wird mit <code>F1::Return</code> die Taste <kbd>F1</kbd> deaktiviert.</p>
<p>Die folgenden Tasten werden nicht von der internen Neubelegungsmethode unterst&uuml;tzt:</p>
<ul>
  <li>Das Mausrad (WheelUp/Down/Left/Right).</li>
  <li><kbd>Pause</kbd> und <kbd>UntBr</kbd> als Zieltasten (da deren Namen mit den entsprechenden Befehlsnamen &uuml;bereinstimmen).</li>
  <li>Geschweifte Klammern {} als Zieltasten. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>, z. B. <code>x::+sc01A</code> und <code>y::+sc01B</code>.</li>
  <li>Ein Prozentzeichen (%) als Zieltaste. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>.</li>
  <li>"Return" als Zieltaste. Verwendet stattdessen "Enter".</li>
</ul>
<h2>Den Mauszeiger mit der Tastatur bewegen</h2>
<p>Die Tastatur kann dazu verwendet werden, den Mauszeiger wie im <a href="../scripts/NumpadMouse.htm">Tastatur-zu-Maus-Script</a> zu bewegen. Da das Script eine reibungslose Bewegung, Beschleunigung und andere Funktionen f&uuml;r den Zeiger erm&ouml;glicht, ist es empfehlenswert, die Tastatur als Maus zu verwenden. Das folgende Beispiel hingegen ist eine einfachere Demonstration:</p>
<pre>*#up::MouseMove, 0, -10, 0, R  <em>; Win + Pfeil oben =&gt; Zeiger nach oben bewegen</em>
*#Down::MouseMove, 0, 10, 0, R  <em>; Win + Pfeil unten =&gt; Zeiger nach unten bewegen</em>
*#Left::MouseMove, -10, 0, 0, R  <em>; Win + Pfeil links =&gt; Zeiger nach links bewegen</em>
*#Right::MouseMove, 10, 0, 0, R  <em>; Win + Pfeil rechts =&gt; Zeiger nach rechts bewegen</em>

*&lt;#RCtrl::  <em>; WinLinks + SteuerungRechts =&gt; Linksklick (Steuerung/Umschalt f&uuml;r Steuerung+Klick oder Umschalt+Klick gedr&uuml;ckt halten).</em>
SendEvent {Blind}{LButton down}
KeyWait RCtrl  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{LButton up}
Return

*&lt;#AppsKey::  <em>; Win links + Men&uuml;-Taste =&gt; Rechtsklick</em>
SendEvent {Blind}{RButton down}
KeyWait AppsKey  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{RButton up}
Return</pre>
<h2 id="registry">Neubelegung mittels "Scancode Map" von der Registrierung</h2>
<p><strong>Vorteile:</strong></p>
<ul>
  <li>Die Neubelegung mit der Registrierung ist in der Regel eindeutiger und effektiver als die <a href="#Remap">Neubelegung mit AutoHotkey</a>. Zum Beispiel werden mit dieser Methode mehr Spiele unterst&uuml;tzt, weil keine <a href="#AltTab">Alt-Tab-Probleme </a>vorhanden sind und Hook-Hotkeys von AutoHotkey ausgef&uuml;hrt werden k&ouml;nnen (w&auml;hrend die Neubelegung mit AutoHotkey eine <a href="#HookHotkeys">&Uuml;bergangsl&ouml;sung</a> ben&ouml;tigt).</li>
  <li>Die dazugeh&ouml;rigen Registrierungseintr&auml;ge k&ouml;nnen manuell bearbeitet werden (siehe unten). Das hei&szlig;t, dass absolut keine externe Software notwendig ist, um die Tastatur neu zu belegen. Obwohl <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> zum &Auml;ndern der Registrierungseintr&auml;ge verwendet werden kann, muss es dennoch nicht die ganze Zeit laufen (im Gegensatz zu AutoHotkey).</li>
</ul>
<p><strong>Nachteile:</strong></p>
<ul>
  <li>Die Neubelegung mit der Registrierung ist relativ permanent: es wird ein Neustart ben&ouml;tigt, um die &Auml;nderungen wirksam oder r&uuml;ckg&auml;ngig zu machen.</li>
  <li>Die Auswirkung ist global: es k&ouml;nnen keine Neubelegungen f&uuml;r bestimmte Benutzer, Anwendungen oder Gebietsschemen erstellt werden.</li>
  <li>Es k&ouml;nnen keine Tastatureingaben gesendet werden, die durch <kbd>Umschalt</kbd>, <kbd>Strg</kbd>, <kbd>Alt</kbd> oder <kbd>AltGr</kbd> modifiziert werden. Zum Beispiel kann ein Kleinbuchstabe nicht mit einem Gro&szlig;buchstaben neu belegt werden.</li>
  <li>Es wird nicht von Windows 95/98/Me unterst&uuml;tzt (AutoHotkey erm&ouml;glicht eine <a href="#Win9x">eingeschr&auml;nkte Neubelegung in Win9x</a>).</li>
  <li>Es wird nur die Tastatur unterst&uuml;tzt (AutoHotkey erm&ouml;glicht eine <a href="#RemapMouse">Neubelegung der Maus</a> und einige&nbsp;<a href="Remap.htm#Win9x">eingeschr&auml;nkte</a><a href="RemapJoystick.htm"> Joystick-Neubelegungen</a>).</li>
</ul>
<p><strong>Wie &Auml;nderungen an der Registrierung vorgenommen werden k&ouml;nnen:</strong> Es gibt mindestens zwei Methoden, um Tasten mittels Registrierung neu zu belegen:</p>
<ol>
  <li>Verwendet ein Programm wie <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> (Freeware), um Tasten visuell neu belegen zu k&ouml;nnen. Dieses Programm &auml;ndert automatisch die Registrierung f&uuml;r euch. </li>
  <li>Tasten k&ouml;nnen manuell neu belegt werden, indem eine .reg-Datei (Klartext) erstellt und in die Registrierung geladen wird. Siehe dazu <a href="http://www.autohotkey.com/forum/post-56216.html#56216">www.autohotkey.com/forum/post-56216.html#56216</a>.</li>
</ol>
<h2 id="alt"><a name="Win9x"></a>Neubelegungsmethode f&uuml;r Windows 95/98/Me</h2>
<p>Es wird empfohlen, hierbei <a href="../commands/Send.htm">Send</a> und <a href="../commands/KeyWait.htm">KeyWait</a> zu verwenden. Zum Beispiel erm&ouml;glicht der folgende Hotkey, dass sich die Taste <kbd>A</kbd> wie <kbd>&larr;</kbd> verh&auml;lt:</p>
<pre>a::
Send {Left down}  <em>; H&auml;lt die linke Pfeiltaste gedr&uuml;ckt.</em>
KeyWait a  <em>; Wartet, bis die Taste losgelassen wird.</em>
Send {Left up}  <em>; L&auml;sst die linke Pfeiltaste los.</em>
Return</pre>
<h2>Verwandte Befehle</h2>
<p><a href="../KeyList.htm#Joystick">Tastenliste</a>, <a href="../commands/GetKeyState.htm">GetKeyState</a>, <a href="RemapJoystick.htm">Neubelegung eines Joysticks</a></p>
</body></html>