<!DOCTYPE HTML>
<html>
<head>
<title>Neubelegung von Tasten</title>
<meta name="keywords" content="Grundlage">
<meta name="description" content="Freier Tastatur-Remapper, mit dem auch Maus- oder Joysticktasten neubelegt werden k&ouml;nnen. Zudem kann er wiederholende Aufgaben durch Senden von Tastatureingaben und Mausklicks automatisieren.">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
    <h1>Neubelegung von Tasten</h1>
    <h2>Einf&uuml;hrung</h2>
    <p>Diese hier beschriebene Funktion wird weder f&uuml;r Joysticks unterst&uuml;tzt noch funktioniert sie in Windows 95/98/Me. Daf&uuml;r gibt es folgende Alternativmethoden:</p>
    <ul>
      <li><a href="#Win9x">Neubelegung in Windows 9x</a></li>
      <li><a href="RemapJoystick.htm">Joystick-Neubelegung</a></li>
    </ul>
    <p><strong>Einschr&auml;nkung</strong>: Die unten beschriebene Neubelegungsfunktion von AutoHotkey ist in der Regel nicht so eindeutig und effektiv wie das direkte Neubelegen der Windows-Registrierung. F&uuml;r die Vor- und Nachteile der einzelnen Ans&auml;tze, siehe <a href="#registry">Neubelegung mit der Registrierung</a>.</p>
    <h2 id="Remap">Tastatur und Maus neu belegen</h2>
    <h3>Neubelegung der Tastatur</h3>
    <p>Die Syntax f&uuml;r die interne Neubelegungsfunktion lautet <code>Originaltaste::Zieltaste</code>. Enth&auml;lt ein <a href="../Scripts.htm">Script</a> beispielsweise folgende Zeile, wird sich die A-Taste wie die B-Taste verhalten:</p>
    <pre>a::b</pre>
    <p>Im oberen Beispiel wird die B-Taste selbst nicht ver&auml;ndert. Sie wird weiterhin ein "b" senden, solange sie nicht wie im folgenden Beispiel neu belegt wird:</p>
    <pre>a::b
b::a</pre>
    <p>In den oberen Beispielen sollten wenn m&ouml;glich Kleinbuchstaben verwendet werden, weil dabei auch die entsprechenden Gro&szlig;buchstaben neu belegt werden (das hei&szlig;t, dass Gro&szlig;buchstaben gesendet werden, sobald die FESTSTELL-Taste aktiv ist oder die UMSCHALT-Taste gedr&uuml;ckt gehalten wird). Falls auf der rechten Seite hingegen ein Gro&szlig;buchstabe angegeben ist, wird die Gro&szlig;schreibung erzwungen. Zum Beispiel erzeugt die folgende Zeile ein gro&szlig;geschriebenes B, wenn "a" oder "A" eingegeben wird (solange die FESTSTELL-Taste deaktiviert ist):</p>
    <pre>a::B <br>
</pre>
    <h3 id="RemapMouse">Neubelegung der Maus</h3>
    <p>Um stattdessen die Maus neu zu belegen, verwendet die gleiche Methode. Zum Beispiel:</p>
    <table class="info">
      <tr>
        <td>MButton::Shift</td>
        <td>Die mittlere Maustaste verh&auml;lt sich wie die UMSCHALT-Taste.</td>
      </tr>
      <tr>
        <td>XButton1::LButton</td>
        <td>Die vierte Maustaste verh&auml;lt sich wie die linke Maustaste.</td>
      </tr>
      <tr>
        <td>RAlt::RButton</td>
        <td>Die rechte ALT-Taste verh&auml;lt sich wie die rechte Maustaste.</td>
      </tr>
    </table>
    <h3>Weitere n&uuml;tzliche Neubelegungen</h3>
    <table class="info">
      <tr>
        <td>Capslock::Ctrl</td>
        <td>Die FESTSTELL-Taste verh&auml;lt sich wie die STRG-Taste. Um die Umschaltf&auml;higkeit der FESTSTELL-Taste zu erhalten, f&uuml;gt au&szlig;erdem&nbsp; <code>+Capslock::Capslock</code> hinzu (damit wird die FESTSTELL-Taste aktiviert oder deaktiviert, wenn der Benutzer die UMSCHALT-Taste gedr&uuml;ckt h&auml;lt und dabei die FESTSTELL-Taste dr&uuml;ckt).</td>
      </tr>
      <tr>
        <td>XButton2::^LButton</td>
        <td>Die f&uuml;nfte Maustaste (XButton2) erzeugt STRG+MAUSTASTE-LINKS.</td>
      </tr>
      <tr>
        <td>RAlt::AppsKey</td>
        <td>Die rechte ALT-Taste verh&auml;lt sich wie die MEN&Uuml;-Taste (&ouml;ffnet das Kontextmen&uuml;).</td>
      </tr>
      <tr>
        <td>RCtrl::RWin</td>
        <td>Die rechte STRG-Taste verh&auml;lt sich wie die rechte WIN-Taste.</td>
      </tr>
      <tr>
        <td>Ctrl::Alt</td>
        <td>Die STRG-Taste verh&auml;lt sich wie die ALT-Taste. Siehe jedoch <a href="#AltTab">Alt-Tab-Probleme</a>.</td>
      </tr>
      <tr>
        <td>^x::^c</td>
        <td>STRG+X erzeugt STRG+C. F&uuml;hrt auch dazu, dass STRG+ALT+X die Tastenkombination STRG+ALT+C erzeugt, usw.</td>
      </tr>
      <tr>
        <td>RWin::Return</td>
        <td>Deaktiviert die rechte WIN-Taste, indem man ihr einfach ein <a href="../commands/Return.htm">Return</a> zuweist.</td>
      </tr>
    </table>
    <p>Die oben genannten Beispiele k&ouml;nnen ausprobiert werden, indem sie in einer neuen Textdatei z. B. namens "Remap.ahk" kopiert werden und die Datei danach ausgef&uuml;hrt wird.</p>
    <p>In der <a href="../KeyList.htm">Tastenliste</a> k&ouml;nnen alle Tastennamen der Tastatur und Maus gefunden werden.</p>
    <h2>Bemerkungen</h2>
    <p>Mit den Direktiven <a href="../commands/_IfWinActive.htm">#IfWinActive/Exist</a> k&ouml;nnen die Neubelegungen nur f&uuml;r bestimmte Fenster g&uuml;ltig gemacht werden. Zum Beispiel:</p>
    <pre>#IfWinActive ahk_class Notepad
a::b  <em>; Im Editor verh&auml;lt sich die A-Taste wie die B-Taste.</em>
#IfWinActive  <em>; Alle nachfolgenden Neubelegungen und Hotkeys gelten f&uuml;r alle Fenster.</em></pre>
    <p>Die Neubelegung einer Taste ist bei folgenden Ma&szlig;nahmen "vollst&auml;ndig":</p>
    <ul>
      <li>Wenn ein Modifikatortaste wie STRG oder UMSCHALT gedr&uuml;ckt gehalten wird, w&auml;hrend die originale Taste eingegeben wird, wird diese Modifikatortaste f&uuml;r die Zieltaste wirksam. Zum Beispiel w&uuml;rde <code>b::a</code> die Tastenkombination STRG+A erzeugen, falls STRG+B gedr&uuml;ckt wird.</li>
      <li>Generell beeinflusst die FESTSTELL-Taste neu belegte Tasten auf die gleiche Weise wie normale Tasten.</li>
      <li>Die Zieltaste wird gedr&uuml;ckt gehalten, solange die originale Taste gedr&uuml;ckt gehalten wird. Allerdings unterst&uuml;tzen einige Spiele keine Neubelegung. In solchen F&auml;llen werden die Neubelegungen einfach von der Tastatur und Maus ignoriert.</li>
      <li>Neu belegte Tasten werden automatisch wiederholt, w&auml;hrend sie gedr&uuml;ckt gehalten werden (au&szlig;er Tasten, die mit Maustasten neu belegt wurden).</li>
    </ul>
    <p id="HookHotkeys">Obwohl eine neu belegte Taste normale Hotkeys ausl&ouml;sen kann, kann sie standardm&auml;&szlig;ig keine Maus- oder <a href="../commands/_UseHook.htm">Hook-Hotkeys</a> ausl&ouml;sen (mit <a href="../commands/ListHotkeys.htm">ListHotkeys</a> k&ouml;nnen Hook-Hotkeys festgestellt werden). Falls zum Beispiel die Neubelegung <code>a::b</code> aktiv ist, wird durch Dr&uuml;cken von STRG+ALT+A der Hotkey <code>^!b</code> ausgel&ouml;st, solange <code>^!b</code> kein Hook-Hotkey ist. Ist <code>^!b</code> jedoch ein Hook-Hotkey, kann <code>^!a</code> als ein Hotkey definiert werden, damit STRG+ALT+A die gleiche Aktion wie STRG+ALT+B ausf&uuml;hrt. Zum Beispiel:</p>
    <pre>a::b
^!a::
^!b::
ToolTip %A_ThisHotkey% wurde gedr&uuml;ckt.
Return</pre>
    <p>Seit v1.1.06 kann alternativ <a href="../commands/_InputLevel.htm">#InputLevel</a> verwendet werden, um das Standardverhalten zu &uuml;berschreiben. Zum Beispiel:</p>
    <pre>#InputLevel 1
a::b

#InputLevel 0
^!b::
ToolTip %A_ThisHotkey% wurde gedr&uuml;ckt.
return</pre>
    <p id="SendPlay">Wenn <a href="../commands/SendMode.htm">SendMode</a> im automatischen Ausf&uuml;hrungsbereich verwendet wird (oberste Teil des Scripts), werden alle Neubelegungen davon beeinflusst. Da jedoch die Neubelegung <a href="../commands/Send.htm#blind">Send {Blind}</a> verwendet, das vom <a href="../commands/SendMode.htm">SendPlay-Modus</a> nicht vollst&auml;ndig unterst&uuml;tzt wird, funktionieren m&ouml;glicherweise einige Neubelegungen nicht richtig im SendPlay-Modus (besonders die Tasten STRG, UMSCHALT, ALT und WIN). Als &Uuml;bergangsl&ouml;sung sollte SendPlay im automatischen Ausf&uuml;hrungsbereich weggelassen werden, falls Neubelegungen vorhanden sind - verwendet <a href="../commands/Send.htm#SendPlay">SendPlay</a> anstelle von Send. Alternativ k&ouml;nnen die Neubelegungen auch in Hotkeys umgewandelt werden (wie unten beschrieben), die SendEvent anstelle von Send direkt aufrufen.</p>
    <p>Sobald ein Script gestartet wird, wird jede Neubelegung in zwei <a href="../Hotkeys.htm">Hotkeys</a> umgewandelt. Zum Beispiel enth&auml;lt ein Script mit <code>a::b</code><em></em> stattdessen folgende zwei Hotkeys:</p>
    <pre>*<strong>a</strong>::
SetKeyDelay -1   <em>; Wenn die Zieltaste eine Maustaste ist, dann verwendet stattdessen SetMouseDelay.</em>
Send <a href="../commands/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownTemp}  <em>; DownTemp ist wie Down, nur dass andere Send-Befehle im Script nicht davon ausgehen, dass "b" w&auml;hrend des Sendens unten bleiben soll.</em>
Return

*<strong>a up</strong>::
SetKeyDelay -1  <em>; Siehe den unteren Hinweis, warum die Druckdauer nicht mit einem der beiden SetKeyDelays angegeben wird.</em>
Send {Blind}{<strong>b</strong> Up}
Return</pre>
    <p>Allerdings unterscheiden sich die oberen Hotkeys unter folgenden Umst&auml;nden:</p>
    <ol>
      <li>Sobald die linke STRG-Taste die Originaltaste und die ALT-Taste die Zieltaste ist, wird die Zeile <code>Send {Blind}{LAlt DownTemp}</code> mit <code>Send {Blind}<strong>{LCtrl Up}</strong>{LAlt DownTemp}</code> ersetzt. Das Gleiche gilt, wenn die rechte STRG-Taste das Original ist, jedoch ohne <code>{RCtrl up}</code>.</li>
      <li>Sobald eine Tastatur-Taste mit einer Maustaste (z. B. <code>RCtrl::RButton</code>) neu belegt wird, verwenden die oben genannten Hotkeys SetMouseDelay anstelle von SetKeyDelay. Dar&uuml;ber hinaus wird der erste oben genannte Hotkey mit folgendem ersetzt, um die automatische Wiederholung von Maustasten zu verhindern:
        <pre>*RCtrl::
SetMouseDelay -1
If not GetKeyState("RButton")  <em>; d. h. die rechte Maustaste wurde noch nicht gedr&uuml;ckt.</em>
    Send {Blind}{RButton DownTemp}
Return</pre>
      </li>
    </ol>
    <p>Beachtet, dass der zweite Parameter (<a href="../commands/SetKeyDelay.htm#dur">Druckdauer</a>) von SetKeyDelay bei den oben genannten Hotkeys entf&auml;llt. Denn die Druckdauer gilt nicht f&uuml;r den dr&uuml;ckenden und loslassenden Status, wie z. B. <code>{b down}</code> und <code>{b up}</code>. Allerdings gilt die Druckdauer weiterhin f&uuml;r die Status&auml;nderungen der Tasten UMSCHALT, STRG, ALT und WIN, die Neubelegungen wie <code>a::B</code> oder <code>a::^b</code> beeinflussen. Folglich gilt die Druckdauer, die im <a href="../Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> aktiviert wurde, f&uuml;r alle Neubelegungen.</p>
    <p>Obwohl ein Tastenpaar nicht direkt mit einer Taste neu belegt werden kann (z. B. ist <code>a &amp; c::b</code> ung&uuml;ltig), kann dieser Effekt dennoch erreicht werden, indem die Up- und Down-Hotkeys von weiter oben direkt hinzugef&uuml;gt werden: ersetzt einfach <code>*a::</code> mit <code>a &amp; c::</code>, und <code>*a up::</code> mit <code>a &amp; c up::</code>.</p>
    <p>Da Neubelegungen wie oben beschrieben in Hotkeys umgewandelt werden, werden sie vom <a href="../commands/Suspend.htm">Suspend</a>-Befehl beeinflusst. Ebenso kann mit dem <a href="../commands/Hotkey.htm">Hotkey</a>-Befehl eine Neubelegung deaktiviert oder bearbeitet werden. Zum Beispiel deaktivieren die zwei folgenden Befehle die Neubelegung <code>a::b</code>.</p>
    <pre>Hotkey, *a, off
Hotkey, *a up, off</pre>
    <p id="AltTab">Alt-Tab-Probleme: Wenn eine Taste oder Maustaste mit der ALT-Taste neu belegt wird, dann ist diese Taste wahrscheinlich nicht in der Lage, ein Alt-Tab-Ereignis richtig auszuf&uuml;hren. Als m&ouml;gliche &Uuml;bergangsl&ouml;sung kann der Hotkey <code>*Tab::Send {Blind}{Tab}</code> hinzugef&uuml;gt werden. Seit euch aber bewusst, dass dabei wahrscheinlich die echte ALT-Taste bei Alt-Tab gest&ouml;rt wird. Daher sollte der Hotkey nur verwendet werden, wenn das Alt-Tab ausschlie&szlig;lich mit neu belegten Tasten und/oder <a href="../Hotkeys.htm#alttab">Alt-Tab-Hotkeys</a> ausgef&uuml;hrt wird.</p>
    <p>Zus&auml;tzlich zu den Tasten und Maustasten in der <a href="../KeyList.htm">Tastenliste</a> kann die Originaltaste auch eine virtuelle Taste (VKnn) oder ein Scancode (SCnnn) sein (siehe <a href="../KeyList.htm#SpecialKeys">Sondertasten</a>). Das Gleiche gilt auch f&uuml;r die Zieltaste, aber mit der Ausnahme, dass nach der virtuellen Taste optional auch ein Scancode angegeben werden kann. Zum Beispiel ist bei den meisten Tastaturbelegungen <code>sc01e::vk42sc030</code> das Gleiche wie <code>a::b</code>.</p>
    <p>Um eine Taste stattdessen zu deaktivieren, erstellt ein Hotkey, der nur ein <a href="../commands/Return.htm">Return</a> enth&auml;lt. Zum Beispiel wird mit <code>F1::Return</code> die F1-Taste deaktiviert.</p>
    <p>Die folgenden Tasten werden nicht von der internen Neubelegungsmethode unterst&uuml;tzt:</p>
    <ul>
      <li>Das Mausrad (WheelUp/Down/Left/Right).</li>
      <li>PAUSE- und BREAK-Taste als Zieltasten (da deren Namen mit den entsprechenden Befehlsnamen &uuml;bereinstimmen).</li>
      <li>Geschweifte Klammern {} als Zieltasten. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>, z. B. <code>x::+sc01A</code> und <code>y::+sc01B</code>.</li>
      <li>Ein Prozentzeichen (%) als Zieltaste. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>.</li>
      <li>"Return" als Zieltaste. Verwendet stattdessen "Enter".</li>
    </ul>
    <h2>Den Mauszeiger mit der Tastatur bewegen</h2>
    <p>Die Tastatur kann dazu verwendet werden, den Mauszeiger wie im <a href="../scripts/NumpadMouse.htm">Tastatur-zu-Maus-Script</a> zu bewegen. Da das Script eine reibungslose Bewegung, Beschleunigung und andere Funktionen f&uuml;r den Zeiger erm&ouml;glicht, ist es empfehlenswert, die Tastatur als Maus zu verwenden. Das folgende Beispiel hingegen ist eine einfachere Demonstration:</p>
    <pre>*#up::MouseMove, 0, -10, 0, R  <em>; WIN + NACH-OBEN =&gt; Zeiger nach oben bewegen</em>
*#Down::MouseMove, 0, 10, 0, R  <em>; WIN + NACH-UNTEN =&gt; Zeiger nach unten bewegen</em>
*#Left::MouseMove, -10, 0, 0, R  <em>; WIN + NACH-LINKS =&gt; Zeiger nach links bewegen</em>
*#Right::MouseMove, 10, 0, 0, R  <em>; WIN + NACH-RECHTS =&gt; Zeiger nach rechts bewegen</em>

*&lt;#RCtrl::  <em>; WinLinks + StrgRechts =&gt; Linksklick (STRG/UMSCHALT f&uuml;r STRG+Klick oder UMSCHALT+Klick gedr&uuml;ckt halten).</em>
SendEvent {Blind}{LButton down}
KeyWait RCtrl  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{LButton up}
Return

*&lt;#AppsKey::  <em>; WinLinks + Men&uuml;-Taste =&gt; Rechtsklick</em>
SendEvent {Blind}{RButton down}
KeyWait AppsKey  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{RButton up}
Return</pre>
    <h2 id="registry">Neubelegung mittels "Scancode Map" von der Registrierung</h2>
    <p><strong>Vorteile:</strong></p>
    <ul>
      <li>Die Neubelegung mit der Registrierung ist in der Regel eindeutiger und effektiver als die <a href="#Remap">Neubelegung mit AutoHotkey</a>. Zum Beispiel werden mit dieser Methode mehr Spiele unterst&uuml;tzt, weil keine <a href="#AltTab">Alt-Tab-Probleme </a>vorhanden sind und Hook-Hotkeys von AutoHotkey ausgef&uuml;hrt werden k&ouml;nnen (w&auml;hrend die Neubelegung mit AutoHotkey eine <a href="#HookHotkeys">&Uuml;bergangsl&ouml;sung</a> ben&ouml;tigt).</li>
      <li>Die dazugeh&ouml;rigen Registrierungseintr&auml;ge k&ouml;nnen manuell bearbeitet werden (siehe unten). Das hei&szlig;t, dass absolut keine externe Software notwendig ist, um die Tastatur neu zu belegen. Obwohl <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> zum &Auml;ndern der Registrierungseintr&auml;ge verwendet werden kann, muss es dennoch nicht die ganze Zeit laufen (im Gegensatz zu AutoHotkey).</li>
    </ul>
    <p><strong>Nachteile:</strong></p>
    <ul>
      <li>Die Neubelegung mit der Registrierung ist relativ permanent: es wird ein Neustart ben&ouml;tigt, um die &Auml;nderungen wirksam oder r&uuml;ckg&auml;ngig zu machen.</li>
      <li>Die Auswirkung ist global: es k&ouml;nnen keine Neubelegungen f&uuml;r bestimmte Benutzer, Anwendungen oder Gebietsschemen erstellt werden.</li>
      <li>Es k&ouml;nnen keine Tastatureingaben gesendet werden, die durch UMSCHALT, STRG, ALT oder ALTGR modifiziert werden. Zum Beispiel kann ein Kleinbuchstabe nicht mit einem Gro&szlig;buchstaben neu belegt werden.</li>
      <li>Es wird nicht von Windows 95/98/Me unterst&uuml;tzt (AutoHotkey erm&ouml;glicht eine <a href="#Win9x">eingeschr&auml;nkte Neubelegung in Win9x</a>).</li>
      <li>Es wird nur die Tastatur unterst&uuml;tzt (AutoHotkey erm&ouml;glicht eine <a href="#RemapMouse">Neubelegung der Maus</a> und einige&nbsp;<a href="Remap.htm#Win9x">eingeschr&auml;nkte</a><a href="RemapJoystick.htm"> Joystick-Neubelegungen</a>).</li>
    </ul>
    <p><strong>Wie &Auml;nderungen an der Registrierung vorgenommen werden k&ouml;nnen:</strong> Es gibt mindestens zwei Methoden, um Tasten mittels Registrierung neu zu belegen:</p>
    <ol>
      <li>Verwendet ein Programm wie <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> (Freeware), um Tasten visuell neu belegen zu k&ouml;nnen. Dieses Programm &auml;ndert automatisch die Registrierung f&uuml;r euch. </li>
      <li>Tasten k&ouml;nnen manuell neu belegt werden, indem eine .reg-Datei (Klartext) erstellt und in die Registrierung geladen wird. Siehe dazu <a href="http://www.autohotkey.com/forum/post-56216.html#56216">www.autohotkey.com/forum/post-56216.html#56216</a>.</li>
    </ol>
    <h2 id="Win9x">Neubelegungsmethode f&uuml;r Windows 95/98/Me</h2>
    <p>Es wird empfohlen, hierbei <a href="../commands/Send.htm">Send</a> und <a href="../commands/KeyWait.htm">KeyWait</a> zu verwenden. Zum Beispiel erm&ouml;glicht der folgende Hotkey, dass sich die A-Taste wie die NACH-LINKS-Taste verh&auml;lt:</p>
    <pre>a::
Send {Left down}  <em>; H&auml;lt die linke Pfeiltaste gedr&uuml;ckt.</em>
KeyWait a  <em>; Wartet, bis die Taste losgelassen wird.</em>
Send {Left up}  <em>; L&auml;sst die linke Pfeiltaste los.</em>
Return</pre>
    <h2>Verwandte Befehle</h2>
    <p><a href="../KeyList.htm#Joystick">Tastenliste</a>, <a href="../commands/GetKeyState.htm">GetKeyState</a>, <a href="RemapJoystick.htm">Neubelegung eines Joysticks</a></p>
  </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>