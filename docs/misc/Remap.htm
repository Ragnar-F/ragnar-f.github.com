<!DOCTYPE HTML>
<html>
<head>
<title>Neubelegung von Tasten</title>
<meta name="description" content="Freier Tastatur-Remapper, der auch Maus- und Joystick-Tasten neubelegen kann. Zudem kann er wiederholende Aufgaben durch Senden von Tastatureingaben &amp; Mausklicks automatisieren.">
<meta name="keywords" content="tastatur,remapper,neubelegen,neubelegung,taste,tastatureingaben,klicks,maus,tasten,joystick,hotkeys,hotkey">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Neubelegung von Tasten</h1>

<h2>Einführung</h2>
<p><strong>Einschränkung</strong>: Die unten beschriebene Neubelegungsfunktion von AutoHotkey ist in der Regel nicht so eindeutig und effektiv wie das direkte Neubelegen der Windows-Registrierung. Für die Vor- und Nachteile der einzelnen Ansätze, siehe <a href="#registry">Neubelegung mit der Registrierung</a>.</p>
<h2 id="Remap">Tastatur und Maus neu belegen</h2>
<p>Die Syntax für die interne Neubelegungsfunktion lautet <code>Originaltaste::Zieltaste</code>. Enthält ein <a href="../Scripts.htm">Script</a> beispielsweise folgende Zeile, wird sich die A-Taste wie die B-Taste verhalten:</p>
<pre>a::b</pre>
<p>Im oberen Beispiel wird die B-Taste selbst nicht verändert. Sie wird weiterhin ein "b" senden, solange sie nicht wie im folgenden Beispiel neu belegt wird:</p>
<pre>a::b
b::a</pre>
<p>In den oberen Beispielen sollten wenn möglich Kleinbuchstaben verwendet werden, weil dabei auch die entsprechenden Großbuchstaben neu belegt werden (das heißt, dass Großbuchstaben gesendet werden, sobald die FESTSTELL-Taste aktiv ist oder die UMSCHALT-Taste gedrückt gehalten wird). Falls auf der rechten Seite hingegen ein Großbuchstabe angegeben ist, wird die Großschreibung erzwungen. Zum Beispiel erzeugt die folgende Zeile ein großgeschriebenes B, wenn "a" oder "A" eingegeben wird (solange die FESTSTELL-Taste deaktiviert ist):</p>
<pre>a::B</pre>
<p>&nbsp;</p>
<p><strong><a name="RemapMouse"></a>Neubelegung der Maus</strong>: Um stattdessen die Maus neu zu belegen, verwendet die gleiche Methode. Zum Beispiel:</p>
<table class="info">
  <tr>
    <td>MButton::Shift</td>
    <td>Die mittlere Maustaste verhält sich wie die UMSCHALT-Taste.</td>
  </tr>
  <tr>
    <td>XButton1::LButton</td>
    <td>Die vierte Maustaste verhält sich wie die linke Maustaste.</td>
  </tr>
  <tr>
    <td>RAlt::RButton</td>
    <td>Die rechte ALT-Taste verhält sich wie die rechte Maustaste.</td>
  </tr>
</table>
<p>&nbsp;</p>
<p><strong>Weitere nützliche Neubelegungen</strong></p>
<table class="info">
  <tr>
    <td>Capslock::Ctrl</td>
    <td>Die FESTSTELL-Taste verhält sich wie die STRG-Taste. Um die Umschaltfähigkeit der FESTSTELL-Taste zu erhalten, fügt außerdem  <code>+Capslock::Capslock</code> hinzu (damit wird die FESTSTELL-Taste aktiviert oder deaktiviert, wenn der Benutzer die UMSCHALT-Taste gedrückt hält und dabei die FESTSTELL-Taste drückt).</td>
  </tr>
  <tr>
    <td>XButton2::^LButton</td>
    <td>Die fünfte Maustaste (XButton2) erzeugt STRG+MAUSTASTE-LINKS.</td>
  </tr>
  <tr>
    <td>RAlt::AppsKey</td>
    <td>Die rechte ALT-Taste verhält sich wie die MENÜ-Taste (öffnet das Kontextmenü).</td>
  </tr>
  <tr>
    <td>RCtrl::RWin</td>
    <td>Die rechte STRG-Taste verhält sich wie die rechte WIN-Taste.</td>
  </tr>
  <tr>
    <td>Ctrl::Alt</td>
    <td>Die STRG-Taste verhält sich wie die ALT-Taste. Siehe jedoch <a href="#AltTab">Alt-Tab-Probleme</a>.</td>
  </tr>
  <tr>
    <td>^x::^c</td>
    <td>STRG+X erzeugt STRG+C. Führt auch dazu, dass STRG+ALT+X die Tastenkombination STRG+ALT+C erzeugt, usw.</td>
  </tr>
  <tr>
    <td>RWin::Return</td>
    <td>Deaktiviert die rechte WIN-Taste, indem man ihr einfach ein <a href="../commands/Return.htm">Return</a> zuweist.</td>
  </tr>
</table>
<p>Die oben genannten Beispiele können ausprobiert werden, indem sie in einer neuen Textdatei z. B. namens "Remap.ahk" kopiert werden und die Datei danach ausgeführt wird.</p>
<p>In der <a href="../KeyList.htm">Tastenliste</a> können alle Tastennamen der Tastatur und Maus gefunden werden.</p>
<h2>Bemerkungen</h2>
<p>Mit den Direktiven <a href="../commands/_IfWinActive.htm">#IfWinActive/Exist</a> können die Neubelegungen nur für bestimmte Fenster gültig gemacht werden. Zum Beispiel:</p>
<pre>#IfWinActive ahk_class Notepad
a::b  <em>; Im Editor verhält sich die A-Taste wie die B-Taste.</em>
#IfWinActive  <em>; Alle nachfolgenden Neubelegungen und Hotkeys gelten für alle Fenster.</em></pre>
<p>Die Neubelegung einer Taste ist bei folgenden Maßnahmen "vollständig":</p>
<ul>
  <li>Wenn ein Modifikatortaste wie STRG oder UMSCHALT gedrückt gehalten wird, während die originale Taste eingegeben wird, wird diese Modifikatortaste für die Zieltaste wirksam. Zum Beispiel würde <code>b::a</code> die Tastenkombination STRG+A erzeugen, falls STRG+B gedrückt wird.</li>
  <li>Generell beeinflusst die FESTSTELL-Taste neu belegte Tasten auf die gleiche Weise wie normale Tasten.</li>
  <li>Die Zieltaste wird gedrückt gehalten, solange die originale Taste gedrückt gehalten wird. Allerdings unterstützen einige Spiele keine Neubelegung. In solchen Fällen werden die Neubelegungen einfach von der Tastatur und Maus ignoriert.</li>
  <li>Neu belegte Tasten werden automatisch wiederholt, während sie gedrückt gehalten werden (außer Tasten, die mit Maustasten neu belegt wurden).</li>
</ul>
<p><a name="HookHotkeys"></a>Obwohl eine neu belegte Taste normale Hotkeys auslösen kann, kann sie standardmäßig keine Maus- oder <a href="../commands/_UseHook.htm">Hook-Hotkeys</a> auslösen (mit <a href="../commands/ListHotkeys.htm">ListHotkeys</a> können Hook-Hotkeys festgestellt werden). Falls zum Beispiel die Neubelegung <code>a::b</code> aktiv ist, wird durch Drücken von STRG+ALT+A der Hotkey <code>^!b</code> ausgelöst, solange <code>^!b</code> kein Hook-Hotkey ist. Ist <code>^!b</code> jedoch ein Hook-Hotkey, kann <code>^!a</code> als ein Hotkey definiert werden, damit STRG+ALT+A die gleiche Aktion wie STRG+ALT+B ausführt. Zum Beispiel:</p>
<pre>a::b
^!a::
^!b::
ToolTip %A_ThisHotkey% wurde gedrückt.
Return</pre>
<p>Seit v1.1.06 kann alternativ <a href="../commands/_InputLevel.htm">#InputLevel</a> verwendet werden, um das Standardverhalten zu überschreiben. Zum Beispiel:</p>
<pre>#InputLevel 1
a::b

#InputLevel 0
^!b::
ToolTip %A_ThisHotkey% wurde gedrückt.
return</pre>
<p><a name="SendPlay"></a>Wenn <a href="../commands/SendMode.htm">SendMode</a> im automatischen Ausführungsbereich verwendet wird (oberste Teil des Scripts), werden alle Neubelegungen davon beeinflusst. Da jedoch die Neubelegung <a href="../commands/Send.htm#blind">Send {Blind}</a> verwendet, das vom <a href="../commands/SendMode.htm">SendPlay-Modus</a> nicht vollständig unterstützt wird, funktionieren möglicherweise einige Neubelegungen nicht richtig im SendPlay-Modus (besonders die Tasten STRG, UMSCHALT, ALT und WIN). Als Übergangslösung sollte SendPlay im automatischen Ausführungsbereich weggelassen werden, falls Neubelegungen vorhanden sind - verwendet <a href="../commands/Send.htm#SendPlay">SendPlay</a> anstelle von Send. Alternativ können die Neubelegungen auch in Hotkeys umgewandelt werden (wie unten beschrieben), die SendEvent anstelle von Send direkt aufrufen.</p>
<p>Sobald ein Script gestartet wird, wird jede Neubelegung in zwei <a href="../Hotkeys.htm">Hotkeys</a> umgewandelt. Zum Beispiel enthält ein Script mit <code>a::b</code> stattdessen folgende zwei Hotkeys:</p>
<pre>*<strong>a</strong>::
SetKeyDelay -1   <em>; Wenn die Zieltaste eine Maustaste ist, dann verwendet stattdessen SetMouseDelay.</em>
Send <a href="../commands/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownTemp}  <em>; DownTemp ist wie Down, nur dass andere Send-Befehle im Script nicht davon ausgehen, dass "b" während des Sendens unten bleiben soll.</em>
Return

*<strong>a up</strong>::
SetKeyDelay -1  <em>; Siehe den unteren Hinweis, warum die Druckdauer nicht mit einem der beiden SetKeyDelays angegeben wird.</em>
Send {Blind}{<strong>b</strong> Up}
Return</pre>
<p>Allerdings unterscheiden sich die oberen Hotkeys unter folgenden Umständen:</p>
<ol>
  <li>Sobald die linke STRG-Taste die Originaltaste und die ALT-Taste die Zieltaste ist, wird die Zeile <code>Send {Blind}{LAlt DownTemp}</code> mit <code>Send {Blind}<strong>{LCtrl Up}</strong>{LAlt DownTemp}</code> ersetzt. Das Gleiche gilt, wenn die rechte STRG-Taste das Original ist, jedoch ohne <code>{RCtrl up}</code>.</li>
  <li>Sobald eine Tastatur-Taste mit einer Maustaste (z. B. <code>RCtrl::RButton</code>) neu belegt wird, verwenden die oben genannten Hotkeys SetMouseDelay anstelle von SetKeyDelay. Darüber hinaus wird der erste oben genannte Hotkey mit folgendem ersetzt, um die automatische Wiederholung von Maustasten zu verhindern:
    <pre>*RCtrl::
SetMouseDelay -1
If not GetKeyState("RButton")  <em>; d. h. die rechte Maustaste wurde noch nicht gedrückt.</em>
    Send {Blind}{RButton DownTemp}
Return</pre>
  </li>
</ol>
<p>Beachtet, dass der zweite Parameter (<a href="../commands/SetKeyDelay.htm#dur">Druckdauer</a>) von SetKeyDelay bei den oben genannten Hotkeys entfällt. Denn die Druckdauer gilt nicht für den drückenden und loslassenden Status, wie z. B. <code>{b down}</code> und <code>{b up}</code>. Allerdings gilt die Druckdauer weiterhin für die Statusänderungen der Tasten UMSCHALT, STRG, ALT und WIN, die Neubelegungen wie <code>a::B</code> oder <code>a::^b</code> beeinflussen. Folglich gilt die Druckdauer, die im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> aktiviert wurde, für alle Neubelegungen.</p>
<p>Obwohl ein Tastenpaar nicht direkt mit einer Taste neu belegt werden kann (z. B. ist <code>a &amp; c::b</code> ungültig), kann dieser Effekt dennoch erreicht werden, indem die Up- und Down-Hotkeys von weiter oben direkt hinzugefügt werden: ersetzt einfach <code>*a::</code> mit <code>a &amp; c::</code>, und <code>*a up::</code> mit <code>a &amp; c up::</code>.</p>
<p>Da Neubelegungen wie oben beschrieben in Hotkeys umgewandelt werden, werden sie vom <a href="../commands/Suspend.htm">Suspend</a>-Befehl beeinflusst. Ebenso kann mit dem <a href="../commands/Hotkey.htm">Hotkey</a>-Befehl eine Neubelegung deaktiviert oder bearbeitet werden. Zum Beispiel deaktivieren die zwei folgenden Befehle die Neubelegung <code>a::b</code>.</p>
<pre>Hotkey, *a, off
Hotkey, *a up, off</pre>
<p><a name="AltTab"></a>Alt-Tab-Probleme: Wenn eine Taste oder Maustaste mit der ALT-Taste neu belegt wird, dann ist diese Taste wahrscheinlich nicht in der Lage, ein Alt-Tab-Ereignis richtig auszuführen. Als mögliche Übergangslösung kann der Hotkey <code>*Tab::Send {Blind}{Tab}</code> hinzugefügt werden. Seit euch aber bewusst, dass dabei wahrscheinlich die echte ALT-Taste bei Alt-Tab gestört wird. Daher sollte der Hotkey nur verwendet werden, wenn das Alt-Tab ausschließlich mit neu belegten Tasten und/oder <a href="../Hotkeys.htm#alttab">Alt-Tab-Hotkeys</a> ausgeführt wird.</p>
<p>Zusätzlich zu den Tasten und Maustasten in der <a href="../KeyList.htm">Tastenliste</a> kann die Originaltaste auch eine virtuelle Taste (VKnn) oder ein Scancode (SCnnn) sein (siehe <a href="../KeyList.htm#SpecialKeys">Sondertasten</a>). Das Gleiche gilt auch für die Zieltaste, aber mit der Ausnahme, dass nach der virtuellen Taste optional auch ein Scancode angegeben werden kann. Zum Beispiel ist bei den meisten Tastaturbelegungen <code>sc01e::vk42sc030</code> das Gleiche wie <code>a::b</code>.</p>
<p>Um eine Taste stattdessen zu deaktivieren, erstellt ein Hotkey, der nur ein <a href="../commands/Return.htm">Return</a> enthält. Zum Beispiel wird mit <code>F1::Return</code> die F1-Taste deaktiviert.</p>
<p>Die folgenden Tasten werden nicht von der internen Neubelegungsmethode unterstützt:</p>
<ul>
  <li>Das Mausrad (WheelUp/Down/Left/Right).</li>
  <li>PAUSE- und BREAK-Taste als Zieltasten (da deren Namen mit den entsprechenden Befehlsnamen übereinstimmen).</li>
  <li>Geschweifte Klammern {} als Zieltasten. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>, z. B. <code>x::+sc01A</code> und <code>y::+sc01B</code>.</li>
  <li>Ein Prozentzeichen (%) als Zieltaste. Verwendet stattdessen die <a href="../commands/Send.htm#vk">VK/SC-Methode</a>.</li>
  <li>"Return" als Zieltaste. Verwendet stattdessen "Enter".</li>
</ul>
<h2>Den Mauszeiger mit der Tastatur bewegen</h2>
<p>Die Tastatur kann dazu verwendet werden, den Mauszeiger wie im <a href="../scripts/NumpadMouse.htm">Tastatur-zu-Maus-Script</a> zu bewegen. Da das Script eine reibungslose Bewegung, Beschleunigung und andere Funktionen für den Zeiger ermöglicht, ist es empfehlenswert, die Tastatur als Maus zu verwenden. Das folgende Beispiel hingegen ist eine einfachere Demonstration:</p>
<pre>*#up::MouseMove, 0, -10, 0, R  <em>; WIN + NACH-OBEN =&gt; Zeiger nach oben bewegen</em>
*#Down::MouseMove, 0, 10, 0, R  <em>; WIN + NACH-UNTEN =&gt; Zeiger nach unten bewegen</em>
*#Left::MouseMove, -10, 0, 0, R  <em>; WIN + NACH-LINKS =&gt; Zeiger nach links bewegen</em>
*#Right::MouseMove, 10, 0, 0, R  <em>; WIN + NACH-RECHTS =&gt; Zeiger nach rechts bewegen</em>

*&lt;#RCtrl::  <em>; WinLinks + StrgRechts =&gt; Linksklick (STRG/UMSCHALT für STRG+Klick oder UMSCHALT+Klick gedrückt halten).</em>
SendEvent {Blind}{LButton down}
KeyWait RCtrl  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{LButton up}
Return

*&lt;#AppsKey::  <em>; WinLinks + Menü-Taste =&gt; Rechtsklick</em>
SendEvent {Blind}{RButton down}
KeyWait AppsKey  <em>; Die automatische Wiederholung des Mausklicks verhindern.</em>
SendEvent {Blind}{RButton up}
Return</pre>
<h2 id="registry">Neubelegung mittels "Scancode Map" von der Registrierung</h2>
<p><strong>Vorteile:</strong></p>
<ul>
  <li>Die Neubelegung mit der Registrierung ist in der Regel eindeutiger und effektiver als die <a href="#Remap">Neubelegung mit AutoHotkey</a>. Zum Beispiel werden mit dieser Methode mehr Spiele unterstützt, weil keine <a href="#AltTab">Alt-Tab-Probleme</a> vorhanden sind und Hook-Hotkeys von AutoHotkey ausgeführt werden können (während die Neubelegung mit AutoHotkey eine <a href="#HookHotkeys">Übergangslösung</a> benötigt).</li>
  <li>Die dazugehörigen Registrierungseinträge können manuell bearbeitet werden (siehe unten). Das heißt, dass absolut keine externe Software notwendig ist, um die Tastatur neu zu belegen. Obwohl <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> zum Ändern der Registrierungseinträge verwendet werden kann, muss es dennoch nicht die ganze Zeit laufen (im Gegensatz zu AutoHotkey).</li>
</ul>
<p><strong>Nachteile:</strong></p>
<ul>
  <li>Die Neubelegung mit der Registrierung ist relativ permanent: es wird ein Neustart benötigt, um die Änderungen wirksam oder rückgängig zu machen.</li>
  <li>Die Auswirkung ist global: es können keine Neubelegungen für bestimmte Benutzer, Anwendungen oder Gebietsschemen erstellt werden.</li>
  <li>Es können keine Tastatureingaben gesendet werden, die durch UMSCHALT, STRG, ALT oder ALTGR modifiziert werden. Zum Beispiel kann ein Kleinbuchstabe nicht mit einem Großbuchstaben neu belegt werden.</li>
  <li>Es wird nur die Tastatur unterstützt (AutoHotkey ermöglicht eine <a href="#RemapMouse">Neubelegung der Maus</a> und einige <a href="RemapJoystick.htm">eingeschränkte Joystick-Neubelegungen</a>).</li>
</ul>
<p><strong>Wie Änderungen an der Registrierung vorgenommen werden können</strong>: Es gibt mindestens zwei Methoden, um Tasten mittels Registrierung neu zu belegen:</p>
<ol>
  <li>Verwendet ein Programm wie <a href="http://webpages.charter.net/krumsick/">KeyTweak</a> (Freeware), um Tasten visuell neu belegen zu können. Dieses Programm ändert automatisch die Registrierung für euch.</li>
  <li>Tasten können manuell neu belegt werden, indem eine .reg-Datei (Klartext) erstellt und in die Registrierung geladen wird. Siehe dazu <a href="http://www.autohotkey.com/forum/post-56216.html#56216">www.autohotkey.com/forum/post-56216.html#56216</a>.</li>
</ol>
<h2>Siehe auch</h2>
<p><a href="../KeyList.htm#Joystick">Liste mit Tasten</a><br>
<a href="../commands/GetKeyState.htm">GetKeyState</a><br>
<a href="RemapJoystick.htm">Neubelegung eines Joysticks</a></p>
</body>
</html>
