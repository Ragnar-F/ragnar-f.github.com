<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Callouts in regul&auml;ren Ausdr&uuml;cken</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="wrapper">
<script src="../navbar/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(1);</script>


<h1>Callouts in regul&auml;ren Ausdr&uuml;cken <span class="ver">[AHK_L 14+]</span></h1>

<p>Callouts bieten die M&ouml;glichkeit, inmitten der Mustererkennung die Kontrolle vor&uuml;bergehend an das Script zu &uuml;bergeben. F&uuml;r detaillierte Informationen &uuml;ber die PCRE-Standard-Callout-Funktion, siehe <a href="http://www.pcre.org/pcre.txt">pcre.txt</a>.</p>

<p>Callouts werden zurzeit nur in <a href="../commands/RegExMatch.htm">RegExMatch</a> und <a href="../commands/RegExReplace.htm">RegExReplace</a> unterst&uuml;tzt.</p>

<h3>Syntax</h3>

<p>Die Syntax f&uuml;r ein Callout ist in AutoHotkey_L <span class="Syntax">(?C<em>Nummer</em>:<em>Funktion</em>)</span>, bei der sowohl <em>Nummer</em> als auch <em>Funktion</em> optional sind. Der Doppelpunkt (:) ist nur erlaubt, wenn die <em>Funktion</em> angegeben ist, und optional, wenn die <em>Nummer</em> weggelassen wird. Wenn die <em>Funktion</em> angegeben ist, aber nicht der Name einer benutzerdefinierten Funktion ist, dann erscheint ein Kompilierungsfehler und die Mustererkennung startet nicht.</p>

<p>Wenn die <em>Funktion</em> weggelassen wird, muss der Funktionsname in eine Variable namens <b>pcre_callout</b> angegeben werden. Falls sowohl eine globale als auch lokale Variable mit diesem Namen vorhanden ist, hat die lokale Variable Vorrang. Wenn <em>pcre_callout</em> keinen Namen einer benutzerdefinierten Funktion enth&auml;lt, dann werden Callouts ohne die <em>Funktion</em> ignoriert.</p>

<h3>Callout-Funktionen</h3>

<pre class="Syntax">Funktion(&Uuml;bereinstimmung, Calloutnummer, Fundposition, Heuhaufen, NadelRegEx)
{
    ...
}</pre>
<p>Callout-Funktionen k&ouml;nnen bis zu 5 Parameter definieren:</p>
<ul>
  <li><b>&Uuml;bereinstimmung</b>: Gleichwertig mit <em>NichtZitierteAusgabevariable</em> von RegExMatch, einschlie&szlig;lich der Erstellung von Array-Variablen je nach Bedarf.</li>
  <li><b>Calloutnummer</b>: Empf&auml;ngt die <em>Nummer</em> des Callouts.</li>
  <li><b>Fundposition</b>: Empf&auml;ngt die Position einer potenziellen &Uuml;bereinstimmung.</li>
  <li><b>Heuhaufen</b>: Empf&auml;ngt den <em>Heuhaufen</em>, der an RegExMatch oder RegExReplace &uuml;bergeben wurde.</li>
  <li><b>NadelRegEx</b>: Empf&auml;ngt <em>NadelRegEx</em>, der an RegExMatch oder RegExReplace &uuml;bergeben wurde.</li>
</ul>
<p>Diese Namen dienen nur als Anregung. Die tats&auml;chlichen Namen k&ouml;nnen variieren.</p>

<p>Die Mustererkennung wird je nach R&uuml;ckgabewert der Callout-Funktion fortgesetzt oder fehlschlagen:</p>
<ul>
  <li>Sobald die Funktion eine <b>0</b> oder keinen numerischen Wert zur&uuml;ckgibt, wird die Erkennung normal fortgesetzt.</li>
  <li>Sobald die Funktion eine <b>1</b> oder h&ouml;her zur&uuml;ckgibt, schl&auml;gt die Erkennung zu diesem Zeitpunkt fehl, aber andere Erkennungen werden m&ouml;glicherweise fortgesetzt.</li>
  <li>Sobald die Funktion <b>-1</b> zur&uuml;ckgibt, wird die Erkennung abgebrochen.</li>
  <li>Sobald die Funktion einen Wert kleiner als -1 zur&uuml;ckgibt, dann wird er als ein PCRE-Fehlercode behandelt und die Erkennung abgebrochen. RegExMatch gibt einen leeren String zur&uuml;ck, w&auml;hrend RegExReplace den originalen <em>Heuhaufen</em> zur&uuml;ckgibt. In beiden F&auml;llen enth&auml;lt ErrorLevel den Fehlercode.</li>
</ul>

<p>Zum Beispiel:</p>
<pre>Heuhaufen = The quick brown fox jumps over the lazy dog.
RegExMatch(Heuhaufen, "i)(The) (\w+)\b(?CFunktion)")
Funktion(m) {
    MsgBox m=%m%`nm1=%m1%`nm2=%m2%
    Return 1
}</pre>
<p>Im oberen Beispiel wird die <em>Funktion</em> f&uuml;r jeden Teilstring einmal aufgerufen, der mit dem Teil des Musters vor dem Callout &uuml;bereinstimmt. <span class="Syntax">\b</span> wird verwendet, um unvollst&auml;ndige W&ouml;rter in &Uuml;bereinstimmungen wie <em>The quic</em>, <em>The qui</em>, <em>The qu</em>, etc. auszuschlie&szlig;en.</p>

<h3 id="EventInfo">EventInfo</h3>

<p>Zus&auml;tzliche Informationen sind verf&uuml;gbar, sobald auf die pcre_callout_block-Struktur mittels <b>A_EventInfo</b> zugegriffen wird.</p>
<pre>version           := NumGet(A_EventInfo,  0, "Int")
callout_number    := NumGet(A_EventInfo,  4, "Int")
offset_vector     := NumGet(A_EventInfo,  8)
subject           := NumGet(A_EventInfo,  8 + A_PtrSize)
subject_length    := NumGet(A_EventInfo,  8 + A_PtrSize*2, "Int")
start_match       := NumGet(A_EventInfo, 12 + A_PtrSize*2, "Int")
current_position  := NumGet(A_EventInfo, 16 + A_PtrSize*2, "Int")
capture_top       := NumGet(A_EventInfo, 20 + A_PtrSize*2, "Int")
capture_last      := NumGet(A_EventInfo, 24 + A_PtrSize*2, "Int")
pad := A_PtrSize=8 ? 4 : 0  <em>; Ausgleich f&uuml;r die 64-Bit-Datenausrichtung.</em>
callout_data      := NumGet(A_EventInfo, 28 + pad + A_PtrSize*2)
pattern_position  := NumGet(A_EventInfo, 28 + pad + A_PtrSize*3, "Int")
next_item_length  := NumGet(A_EventInfo, 32 + pad + A_PtrSize*3, "Int")
if version &gt;= 2
    mark   := StrGet(NumGet(A_EventInfo, 36 + pad + A_PtrSize*3, "Int"), "UTF-8")
</pre>
<p>Weitere Informationen k&ouml;nnen unter <a href="http://www.pcre.org/pcre.txt">pcre.txt</a>, <a href="../Functions.htm#NumGet">NumGet</a> und <a href="../Variables.htm#PtrSize">A_PtrSize</a> gefunden werden.</p>

<h3 id="auto">Auto-Callout</h3>

<p>Sobald ein <span class="Syntax">C</span> in den Optionen des Musters eingef&uuml;gt wird, wird der Auto-Callout-Modus aktiviert. In diesem Modus werden Callouts wie <span class="Syntax">(?C255)</span> vor jedem Element im Muster eingef&uuml;gt. Zum Beispiel k&ouml;nnte die folgende Vorlage verwendet werden, um regul&auml;re Ausdr&uuml;cke zu debuggen:</p>
<pre><em>; Bestimmt die Standard-Callout-Funktion.</em>
pcre_callout = DebugRegEx

<em>; Ruft RegExMatch mit der Auto-Callout-Option C auf.</em>
RegExMatch("xxxabc123xyz", "C)abc.*xyz")

DebugRegEx(&Uuml;bereinstimmung, Calloutnummer, Fundposition, Heuhaufen, NadelRegEx)
{
    <em>; F&uuml;r Beschreibungen dieser Felder, siehe pcre.txt.</em>
    start_match       := NumGet(A_EventInfo, 12 + A_PtrSize*2, "Int")
    current_position  := NumGet(A_EventInfo, 16 + A_PtrSize*2, "Int")
    pad := A_PtrSize=8 ? 4 : 0
    pattern_position  := NumGet(A_EventInfo, 28 + pad + A_PtrSize*3, "Int")
    next_item_length  := NumGet(A_EventInfo, 32 + pad + A_PtrSize*3, "Int")

    <em>; &gt;&gt;aktuelle &Uuml;bereinstimmung&lt;&lt; aufzeigen.</em>
    _HEUHAUFEN:=SubStr(Heuhaufen, 1, start_match)
        . "&gt;&gt;" SubStr(Heuhaufen, start_match + 1, current_position - start_match)
        . "&lt;&lt;" SubStr(Heuhaufen, current_position + 1)

    <em>; &gt;&gt;n&auml;chstes Element zu Auswertung&lt;&lt; aufzeigen.</em>
    _NADEL:=  SubStr(NadelRegEx, 1, pattern_position)
        . "&gt;&gt;" SubStr(NadelRegEx, pattern_position + 1, next_item_length)
        . "&lt;&lt;" SubStr(NadelRegEx, pattern_position + 1 + next_item_length)

    ListVars
    <em>; Pause dr&uuml;cken, um fortzufahren.</em>
    Pause
}</pre>

<h3>Bemerkungen</h3>

<p>Callouts werden auf dem aktuellen Quasi-Thread ausgef&uuml;hrt, aber der vorherige Wert von A_EventInfo wird wiederhergestellt, nachdem die Callout-Funktion einen Wert zur&uuml;ckgegeben hat. ErrorLevel wird nicht gesetzt, bis RegExMatch oder RegExReplace einen Wert zur&uuml;ckgibt.</p>
<p>PCRE wurde so optimiert, in einigen F&auml;llen fr&uuml;h abzubrechen, falls eine &Uuml;bereinstimmung nicht m&ouml;glich ist. Damit Callouts in solchen F&auml;llen aufgerufen werden, m&uuml;ssen diese Optimierungen mithilfe von <code>(*NO_START_OPT)</code> am Anfang des Musters deaktiviert werden. Das ben&ouml;tigt v1.1.05 oder h&ouml;her.</p>

</div>
</body></html>