<!DOCTYPE HTML>
<html>
<head>
<title>Callouts in regulären Ausdrücken</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>Callouts in regulären Ausdrücken <span class="ver">[AHK_L 14+]</span></h1>
<p>Callouts bieten die Möglichkeit, inmitten der Mustererkennung die Kontrolle vorübergehend an das Script zu übergeben. Für detaillierte Informationen über die PCRE-Standard-Callout-Funktion, siehe <a href="http://www.pcre.org/pcre.txt">pcre.txt</a>.</p>
<p>Callouts werden zurzeit nur in <a href="../commands/RegExMatch.htm">RegExMatch</a> und <a href="../commands/RegExReplace.htm">RegExReplace</a> unterstützt.</p>
<h3>Syntax</h3>
<p>Die Syntax für ein Callout ist in AutoHotkey <span class="Syntax">(?C<em>Nummer</em>:<em>Funktion</em>)</span>, bei der sowohl <em>Nummer</em> als auch <em>Funktion</em> optional sind. Der Doppelpunkt (:) ist nur erlaubt, wenn die <em>Funktion</em> angegeben ist, und optional, wenn die <em>Nummer</em> weggelassen wird. Wenn die <em>Funktion</em> angegeben ist, aber nicht der Name einer benutzerdefinierten Funktion ist, dann erscheint ein Kompilierungsfehler und die Mustererkennung startet nicht.</p>
<p>Wenn die <em>Funktion</em> weggelassen wird, muss der Funktionsname in eine Variable namens <b>pcre_callout</b> angegeben werden. Falls sowohl eine globale als auch lokale Variable mit diesem Namen vorhanden ist, hat die lokale Variable Vorrang. Wenn <em>pcre_callout</em> keinen Namen einer benutzerdefinierten Funktion enthält, dann werden Callouts ohne die <em>Funktion</em> ignoriert.</p>
<h3>Callout-Funktionen</h3>
<pre class="Syntax">Funktion(Übereinstimmung, Calloutnummer, Fundposition, Heuhaufen, NadelRegEx)
{
    ...
}</pre>
<p>Callout-Funktionen können bis zu 5 Parameter definieren:</p>
<ul>
  <li><b>Übereinstimmung</b>: Gleichwertig mit <em>NichtZitierteAusgabeVar</em> von RegExMatch, einschließlich der Erstellung von Array-Variablen je nach Bedarf.</li>
  <li><b>Calloutnummer</b>: Empfängt die <em>Nummer</em> des Callouts.</li>
  <li><b>Fundposition</b>: Empfängt die Position einer potenziellen Übereinstimmung.</li>
  <li><b>Heuhaufen</b>: Empfängt den <em>Heuhaufen</em>, der an RegExMatch oder RegExReplace übergeben wurde.</li>
  <li><b>NadelRegEx</b>: Empfängt <em>NadelRegEx</em>, der an RegExMatch oder RegExReplace übergeben wurde.</li>
</ul>
<p>Diese Namen dienen nur als Anregung. Die tatsächlichen Namen können variieren.</p>
<p>Die Mustererkennung wird je nach Rückgabewert der Callout-Funktion fortgesetzt oder fehlschlagen:</p>
<ul>
  <li>Sobald die Funktion eine <b>0</b> oder keinen numerischen Wert zurückgibt, wird die Erkennung normal fortgesetzt.</li>
  <li>Sobald die Funktion eine <b>1</b> oder höher zurückgibt, schlägt die Erkennung zu diesem Zeitpunkt fehl, aber andere Erkennungen werden möglicherweise fortgesetzt.</li>
  <li>Sobald die Funktion <b>-1</b> zurückgibt, wird die Erkennung abgebrochen.</li>
  <li>Sobald die Funktion einen Wert kleiner als -1 zurückgibt, dann wird er als ein PCRE-Fehlercode behandelt und die Erkennung abgebrochen. RegExMatch gibt einen leeren String zurück, während RegExReplace den originalen <em>Heuhaufen</em> zurückgibt. In beiden Fällen enthält ErrorLevel den Fehlercode.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>Heuhaufen = The quick brown fox jumps over the lazy dog.
RegExMatch(Heuhaufen, "i)(The) (\w+)\b(?CFunktion)")
Funktion(m) {
    MsgBox m=%m%`nm1=%m1%`nm2=%m2%
    Return 1
}</pre>
<p>Im oberen Beispiel wird die <em>Funktion</em> für jeden Teilstring einmal aufgerufen, der mit dem Teil des Musters vor dem Callout übereinstimmt. <span class="Syntax">\b</span> wird verwendet, um unvollständige Wörter in Übereinstimmungen wie <em>The quic</em>, <em>The qui</em>, <em>The qu</em>, etc. auszuschließen.</p>
<h3 id="EventInfo">EventInfo</h3>
<p>Zusätzliche Informationen sind verfügbar, sobald auf die pcre_callout_block-Struktur mittels <b>A_EventInfo</b> zugegriffen wird.</p>
<pre>version           := NumGet(A_EventInfo,  0, "Int")
callout_number    := NumGet(A_EventInfo,  4, "Int")
offset_vector     := NumGet(A_EventInfo,  8)
subject           := NumGet(A_EventInfo,  8 + A_PtrSize)
subject_length    := NumGet(A_EventInfo,  8 + A_PtrSize*2, "Int")
start_match       := NumGet(A_EventInfo, 12 + A_PtrSize*2, "Int")
current_position  := NumGet(A_EventInfo, 16 + A_PtrSize*2, "Int")
capture_top       := NumGet(A_EventInfo, 20 + A_PtrSize*2, "Int")
capture_last      := NumGet(A_EventInfo, 24 + A_PtrSize*2, "Int")
pad := A_PtrSize=8 ? 4 : 0  <em>; Ausgleich für die 64-Bit-Datenausrichtung.</em>
callout_data      := NumGet(A_EventInfo, 28 + pad + A_PtrSize*2)
pattern_position  := NumGet(A_EventInfo, 28 + pad + A_PtrSize*3, "Int")
next_item_length  := NumGet(A_EventInfo, 32 + pad + A_PtrSize*3, "Int")
if version &gt;= 2
    mark   := StrGet(NumGet(A_EventInfo, 36 + pad + A_PtrSize*3, "Int"), "UTF-8")
</pre>
<p>Weitere Informationen können unter <a href="http://www.pcre.org/pcre.txt">pcre.txt</a>, <a href="../Functions.htm#NumGet">NumGet</a> und <a href="../Variables.htm#PtrSize">A_PtrSize</a> gefunden werden.</p>
<h3 id="auto">Auto-Callout</h3>
<p>Sobald ein <span class="Syntax">C</span> in den Optionen des Musters eingefügt wird, wird der Auto-Callout-Modus aktiviert. In diesem Modus werden Callouts wie <span class="Syntax">(?C255)</span> vor jedem Element im Muster eingefügt. Zum Beispiel könnte die folgende Vorlage verwendet werden, um reguläre Ausdrücke zu debuggen:</p>
<pre><em>; Bestimmt die Standard-Callout-Funktion.</em>
pcre_callout = DebugRegEx

<em>; Ruft RegExMatch mit der Auto-Callout-Option C auf.</em>
RegExMatch("xxxabc123xyz", "C)abc.*xyz")

DebugRegEx(Übereinstimmung, Calloutnummer, Fundposition, Heuhaufen, NadelRegEx)
{
    <em>; Für Beschreibungen dieser Felder, siehe pcre.txt.</em>
    start_match       := NumGet(A_EventInfo, 12 + A_PtrSize*2, "Int")
    current_position  := NumGet(A_EventInfo, 16 + A_PtrSize*2, "Int")
    pad := A_PtrSize=8 ? 4 : 0
    pattern_position  := NumGet(A_EventInfo, 28 + pad + A_PtrSize*3, "Int")
    next_item_length  := NumGet(A_EventInfo, 32 + pad + A_PtrSize*3, "Int")

    <em>; &gt;&gt;aktuelle Übereinstimmung&lt;&lt; aufzeigen.</em>
    _HEUHAUFEN:=SubStr(Heuhaufen, 1, start_match)
        . "&gt;&gt;" SubStr(Heuhaufen, start_match + 1, current_position - start_match)
        . "&lt;&lt;" SubStr(Heuhaufen, current_position + 1)

    <em>; &gt;&gt;nächstes Element zu Auswertung&lt;&lt; aufzeigen.</em>
    _NADEL:=  SubStr(NadelRegEx, 1, pattern_position)
        . "&gt;&gt;" SubStr(NadelRegEx, pattern_position + 1, next_item_length)
        . "&lt;&lt;" SubStr(NadelRegEx, pattern_position + 1 + next_item_length)

    ListVars
    <em>; PAUSE drücken, um fortzufahren.</em>
    Pause
}</pre>
<h3>Bemerkungen</h3>
<p>Callouts werden auf dem aktuellen Quasi-Thread ausgeführt, aber der vorherige Wert von A_EventInfo wird wiederhergestellt, nachdem die Callout-Funktion einen Wert zurückgegeben hat. ErrorLevel wird nicht gesetzt, bis RegExMatch oder RegExReplace einen Wert zurückgibt.</p>
<p>PCRE wurde so optimiert, in einigen Fällen früh abzubrechen, falls eine Übereinstimmung nicht möglich ist. Damit Callouts in solchen Fällen aufgerufen werden, müssen diese Optimierungen mithilfe von <code>(*NO_START_OPT)</code> am Anfang des Musters deaktiviert werden. Das benötigt v1.1.05 oder höher.</p>
</body>
</html>
