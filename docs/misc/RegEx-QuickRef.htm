<!DOCTYPE HTML>
<html>
<head>
<title>Reguläre Ausdrücke (RegEx) - Kurzübersicht</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
<style type="text/css">
<!--
.regex {background-color: #FFEED3; font-weight: bold}
.subj {background-color: #DDFFDD}
-->
</style>
</head>
<body>
<h1>Reguläre Ausdrücke (RegEx) - Kurzübersicht</h1>

<h2>Grundlagen</h2>
<p><strong>Übereinstimmungen sind überall</strong>: Standardmäßig stimmt ein regulärer Ausdruck mit einem Teilstring <em>überall</em> innerhalb des durchsuchten Strings überein. Zum Beispiel stimmt der reguläre Ausdruck <span class="regex">abc</span> mit <span class="subj">abc</span>123, 123<span class="subj">abc</span> und 123<span class="subj">abc</span>xyz überein. Damit die Übereinstimmung nur am Anfang oder Ende erfolgt, verwendet einen <a href="#anchor">Anker</a>.</p>
<p><strong>Escapezeichen</strong>: Die meisten Zeichen wie abc123 können literal in einem regulären Ausdruck verwendet werden. Bei den Zeichen <strong>\.*?+[{|()^$</strong> muss allerdings ein umgekehrter Schrägstrich davor gesetzt werden, damit auch diese als literal angesehen werden. Zum Beispiel ist <span class="regex">\.</span> ein literaler Punkt und <span class="regex">\\</span> ein literaler umgekehrter Schrägstrich. Das Escapen kann mit \Q...\E verhindert werden. Zum Beispiel: \QLiteraler Text\E.</p>
<p><strong>Abhängigkeit von Groß- und Kleinschreibung</strong>: Standardmäßig sind reguläre Ausdrücke von der Groß- und Kleinschreibung abhängig. Das kann mit der "i"-Option geändert werden. Zum Beispiel sucht das Muster <span class="regex">i)abc</span> nach "abc", ohne Rücksicht auf die Groß- und Kleinschreibung. Siehe unten für weitere Modifikatoren.</p>

<h2 id="Options">Optionen (von der Groß- und Kleinschreibung abhängig)</h2>
<p>Am Anfang eines regulären Ausdrucks können beliebig viele Optionen stehen, gefolgt von einer schließenden Klammer. Zum Beispiel sucht das Muster "<span class="red">im)</span>abc" nach <em>abc</em> auf mehreren Zeilen, unabhängig von der Groß- und Kleinschreibung (die Klammer kann weggelassen werden, falls keine Optionen vorhanden sind). Obwohl diese Syntax vom traditionellen Weg abweicht, benötigt es keine speziellen Trennzeichen (z. B. Schrägstrich), daher müssen diese Trennzeichen innerhalb des Musters nicht mit einem Escapezeichen versehen werden. Darüber hinaus wird die Performance verbessert, da die Optionen einfacher zu parsen sind.</p>
<table class="info">
  <tr id="opt_i">
    <td><strong>i</strong></td>
    <td>Übereinstimmung ist nicht von Groß- und Kleinschreibung abhängig, das heißt, dass die Buchstaben von A bis Z identisch zu ihren Gegenstücken in Kleinbuchstaben sind.</td>
  </tr>
  <tr>
    <td><strong>m</strong></td>
    <td><p><a name="Multiline"></a>Mehrzeilig. Sieht <em>Heuhaufen</em> nicht als durchgehende Zeile, sondern als Ansammlung von einzelnen Zeilen (wenn es Zeilenumbrüche enthält). Insbesondere wird dadurch Folgendes geändert:</p>
      <p>1) Zirkumflex (^) hat nach jedem internen Zeilenumbruch eine Übereinstimmung, sowie auch am Anfang des <em>Heuhaufens</em>, wo es immer übereinstimmt (hat aber nach einem Zeilenumbruch <em>ziemlich am Ende</em> des <em>Heuhaufens</em> keine Übereinstimmung).</p>
      <p>2) Dollar-Zeichen ($) hat vor jedem Zeilenumbruch im <em>Heuhaufen</em> eine Übereinstimmung (sowie ganz am Ende, wo es immer übereinstimmt).</p>
      <p>Zum Beispiel stimmt das Muster "<span class="red">m)</span>^abc$" erst mit dem <em>Heuhaufen</em> "xyz`r`nabc" überein, wenn die "m"-Option vorhanden ist.</p>
      <p>Die "D"-Option wird ignoriert, wenn "m" vorhanden ist.</p></td>
  </tr>
  <tr id="opt_s">
    <td><strong>s</strong></td>
    <td>DotAll. Dadurch stimmt der Punkt (.) mit allen Zeichen überein, einschließlich Zeilenumbrüche (normalerweise stimmt es nicht mit Zeilenumbrüchen überein). Wenn jedoch das Zeilenumbruch-Zeichen standardmäßig CRLF (`r`n) ist, dann sind zwei Punkte erforderlich, damit eine Übereinstimmung erfolgt. Unabhängig von dieser Option stimmt eine negative Klasse wie [^a] immer mit Zeilenumbrüchen überein.</td>
  </tr>
  <tr id="opt_x">
    <td><strong>x</strong></td>
    <td>Ignoriert Leerraumzeichen im Muster, solange sie nicht mit einem Escapezeichen versehen sind oder sich in einer Zeichenklasse befinden. Die Zeichen `n und `t dazwischen werden ignoriert, sobald sie im PCRE ankommen, weil sie da bereits als unbearbeitete/literale Leerraumzeichen behandelt werden (\n und \t werden hingegen nicht ignoriert, weil sie Escapesequenzen im PCRE sind). Die <strong>x</strong>-Option ignoriert zudem Zeichen zwischen einem #-Zeichen (ohne versehenem Escapezeichen und außerhalb einer Zeichenklasse) und dem nächsten Zeilenumbruchszeichen. Damit ist es möglich, Kommentare innerhalb eines komplizierten Musters einzufügen. Dies gilt jedoch nur für Datenzeichen; Leerraumzeichen können nie innerhalb einer speziellen Zeichenfolgen wie (?( vorkommen, die ein Bedingungsmuster starten.</td>
  </tr>
  <tr id="opt_A">
    <td><strong>A</strong></td>
    <td>Zwingt das Muster zu verankern; das heißt, es kann nur am Anfang des <em>Heuhaufens</em> übereinstimmen. In den meisten Fällen ist dies das gleiche wie, als würde man das Muster explizit verankern, wie z. B. mit "^".</td>
  </tr>
  <tr id="opt_D">
    <td><strong>D</strong></td>
    <td>Zwingt Dollar-Zeichen ($), mit dem Ende des <em>Heuhaufens</em> übereinzustimmen, selbst wenn das letzte Zeichen im <em>Heuhaufen</em> ein Zeilenumbruch ist. Ohne diese Option erfolgt eine Übereinstimmung vor einem abschließenden Zeilenumbruch (falls vorhanden). Hinweis: Diese Option wird ignoriert, wenn "m" vorhanden ist.</td>
  </tr>
  <tr id="opt_J">
    <td><strong>J</strong></td>
    <td>Erlaubt doppelte <a href="../commands/RegExMatch.htm#NamedSubPat">benannte Teilausdrücke</a>. Das ist für Muster nützlich, in denen nur ein Teilausdruck von gleichnamigen Teilausdrücken übereinstimmen kann. Hinweis: Wenn mehrere Instanzen des bestimmten Namens mit etwas übereinstimmen, dann wird nur die Instanz ganz links gespeichert. Auch sind Variablennamen nicht von Groß- und Kleinschreibung abhängig.</td>
  </tr>
  <tr id="opt_U">
    <td><strong>U</strong></td>
    <td>Ungreedy (nicht gierig). Die Quantoren *+?{} verbrauchen so wenig Zeichen wie möglich für eine Übereinstimmung und lassen den Rest für den nächsten Teilausdruck übrig. Wenn die "U"-Option nicht aktiv ist, dann kann die Gier eines beliebigen Quantors mit einem nachfolgendem Fragezeichen aufgehoben werden. Wenn hingegen "U" <em>aktiv</em> ist, dann macht das Fragezeichen einen beliebigen Quantor gierig.</td>
  </tr>
  <tr id="opt_extra">
    <td><strong>X</strong></td>
    <td>PCRE_EXTRA. Ermöglicht PCRE-Funktionen, die mit Perl nicht kompatibel sind. Derzeit ist nur eine Funktion vorhanden, die eine Übereinstimmung mit jedem umgekehrten Schrägstrich in einem Muster mit einem nachfolgendem Buchstaben ohne besondere Bedeutung fehlschlagen lässt und ErrorLevel demzufolge setzt. Diese Option hilft, unbenutzte umgekehrte Schrägstriche für die zukünftige Verwendung zu reservieren. Ist diese Option nicht vorhanden, wird ein umgekehrter Schrägstrich mit einem nachfolgenden Buchstaben ohne besondere Bedeutung literal dargestellt (z. B. wird \g und g als literales g erkannt). Unabhängig dieser Option werden nicht-alphabetische umgekehrte Schrägstrich-Zeichenfolgen ohne besondere Bedeutung immer literal behandelt (z. B. wird sowohl \/ wie auch / als Schrägstrich erkannt).</td>
  </tr>
  <tr id="opt_P">
    <td><strong>P</strong></td>
    <td>Positionsmodus. Dadurch gibt RegExMatch() die Position und Länge der Übereinstimmung und deren Teilausdrücke zurück, anstatt ihre passenden Teilstrings. Für weitere Details, siehe <a href="../commands/RegExMatch.htm#PosMode">NichtZitierteAusgabeVar</a>.</td>
  </tr>
  <tr>
    <td><strong>S</strong></td>
    <td><a name="Study"></a>Überprüft das Muster, um die Performance zu verbessern. Das ist nützlich, wenn ein bestimmtes (besonders komplexes) Muster oft ausgeführt wird. Wenn PCRE einen Weg findet, die Performance zu verbessern, dann wird die Entdeckung zusammen mit dem Muster für nachfolgende Anwendungen desselben Musters in den Cache gespeichert (nachfolgende Verwendungen dieses Musters sollten auch die S-Option enthalten, weil notwendigerweise die Optionsbuchstaben und Reihenfolge exakt übereinstimmen müssen, um eine Übereinstimmung im Cache zu finden).</td>
  </tr>
  <tr id="opt_Callout">
    <td><strong>C</strong></td>
    <td>Aktiviert den Auto-Callout-Modus. Siehe <a href="../misc/RegExCallout.htm#auto">Callouts in regulären Ausdrücken</a> für weitere Informationen.</td>
  </tr>
  <tr id="opt_esc_n">
    <td><strong>`n</strong></td>
    <td>Wechselt vom Standard-Unterbrechungszeichen (`r`n) zu einem LF-Zeichen (`n), welches Standard in UNIX-Systemen ist. Das ausgewählte Unterbrechungszeichen beeinflusst das Verhalten von <a href="../misc/RegEx-QuickRef.htm#anchor">Verankerungen (^ und $)</a> und <a href="../misc/RegEx-QuickRef.htm#dot">Muster mit Punkten</a>.</td>
  </tr>
  <tr id="opt_esc_r">
    <td><strong>`r</strong></td>
    <td>Wechselt vom Standard-Unterbrechungszeichen (`r`n) zu einem CR-Zeichen (`r).</td>
  </tr>
  <tr>
    <td><strong>`a</strong></td>
    <td><a name="NEWLINE_ANY"></a>Seit v1.0.46.06 erkennt `a jede Art von Zeilenumbruch: `r, `n, `r`n, `v/VT/vertical tab/chr(0xB), `f/FF/formfeed/chr(0xC) und NEL/next-line/chr(0x85). Seit v1.0.47.05 können Zeilenumbrüche mit (*ANYCRLF) am Anfang eines Musters (nach den Optionen) auf CR, LF und CRLF beschränkt werden, zum Beispiel: <code>im)(*ANYCRLF)^abc$</code>.</td>
  </tr>
</table>
<p>Hinweis: Leerzeichen und Tabulatoren können verwendet werden, um jede Option voneinander zu trennen.</p>

<h2 id="Common">Häufig verwendete Symbole und Syntax</h2>
<table class="info">
	<tr>
		<td align="center"><strong>.</strong></td>
		<td><a name="dot"></a>Standardmäßig stimmt ein Punkt mit jedem Zeichen überein, das nicht zu einer Zeilenumbruchsreihe (`r`n) gehört. Dieses Verhalten kann jedoch geändert werden, wenn die Optionen <a href="#opt_s">DotAll (s)</a>, <a href="#opt_esc_n">LF (`n)</a>, <a href="#opt_esc_r">CR (`r)</a>, <a href="#NEWLINE_ANY">`a oder (*ANYCRLF)</a> verwendet werden. Zum Beispiel stimmt <span class="regex">ab.</span> mit <span class="subj">abc</span> und <span class="subj">abz</span> und <span class="subj">ab_</span> überein.</td>
	</tr>
	<tr>
		<td align="center"><strong>*</strong></td>
		<td><p>Mit dem Sternchen darf das voranstehende Element (Zeichen, <a href="#class">Klasse</a> oder <a href="#subpat">Teilausdruck</a>) kein- oder mehrmals vorkommen. Zum Beispiel stimmt <span class="regex">a*</span> mit <span class="subj">a</span>b und <span class="subj">aaa</span>b überein. Es stimmt auch mit dem Anfang eines beliebigen Strings überein, der überhaupt kein "a" enthält.</p>
	      <p><strong>Platzhalter</strong>: Das Punkt-Sternchen-Muster <span class="regex">.*</span> ist sehr großzügig, weil es mit beliebig vielen Vorkommen eines <em>beliebigen</em> Zeichens übereinstimmt (außer Zeilenumbruch: `r und `n). Zum Beispiel stimmt <span class="regex">abc.*123</span> mit <span class="subj">abcAnything123</span> sowie mit <span class="subj">abc123</span> überein.</p>		  </td>
	</tr>
	<tr>
	  <td align="center"><strong>?</strong></td>
	  <td>Mit dem Fragezeichen darf das voranstehende Element (Zeichen, <a href="#set">Klasse</a> oder <a href="#subpat">Teilausdruck</a>) kein- oder einmal vorkommen. Oder auch: "Das voranstehende Element ist optional". Zum Beispiel stimmt <span class="regex">colou?r</span> sowohl mit <span class="subj">color</span> als auch <span class="subj">colour</span> überein, weil das "u" optional ist.</td>
  </tr>
	<tr>
	  <td align="center"><strong>+</strong></td>
	  <td>Mit dem Pluszeichen darf das voranstehende Element (Zeichen, <a href="#class">Klasse</a> oder <a href="#subpat">Teilausdruck</a>) ein- oder mehrmals vorkommen. Zum Beispiel stimmt <span class="regex">a+</span> mit <span class="subj">a</span>b und <span class="subj">aaa</span>b überein. Aber im Gegensatz zu <span class="regex">a*</span> und <span class="regex">a?</span> stimmt das Muster <span class="regex">a+</span> nicht mit dem Anfang eines Strings überein, dem ein "a"-Zeichen fehlt.</td>
  </tr>
	<tr>
	  <td align="center">{min,max}</td>
	  <td><p>Damit darf das voranstehende Element (Zeichen, <a href="#set">Klasse</a> oder <a href="#subpat">Teilausdruck</a>) <em>min</em>- bis <em>max</em>-mal vorkommen. Zum Beispiel stimmt <span class="regex">a{1,2}</span> mit <span class="subj">a</span>b überein, bei <span class="subj">aa</span>ab jedoch nur die ersten 2 "a"-Zeichen.</p>
        <p>Ebenso stimmt {3} mit genau 3 Vorkommen ein und {3<strong>,</strong>} mit 3 oder mehr Vorkommen. Hinweis: Die angegebenen Zahlen müssen kleiner als 65536 sein. Außerdem muss der erste Wert kleiner gleich der zweite Wert sein.</p></td>
  </tr>
	<tr>
	  <td align="center"><strong>[...]</strong></td>
	  <td><p><a name="set"></a><a name="class"></a><strong>Zeichenklassen</strong>: Die eckigen Klammern umschließen eine Liste oder einen Bereich von Zeichen (oder beides). Zum Beispiel bedeutet <span class="regex">[abc]</span>: "jedes Zeichen, das entweder ein a, b oder c ist". Mit einem Bindestrich wird ein Bereich erzeugt, zum Beispiel bedeutet <span class="regex">[a-z]</span>: "jedes Zeichen von a bis z". Listen und Bereiche können kombiniert werden, zum Beispiel bedeutet <span class="regex">[a-zA-Z0-9_]</span>: "jedes Zeichen, das alphanumerisch oder ein Unterstrich ist".</p>
	    <p>Nach einer Zeichenklasse kann *, ?, + oder {min,max} erfolgen. Zum Beispiel stimmt <span class="regex">[0-9]+</span> mit einem oder mehreren Vorkommen von Ziffern überein, daher erfolgt eine Übereinstimmung mit xyz<span class="subj">123</span>, aber nicht mit abcxyz.</p>            
        <p>Die folgenden POSIX-Sets werden auch in Form von [[:xxx:]] unterstützt, wobei xxx ein folgendes Wort sein kann: alnum, alpha, ascii (0-127), blank (Leerzeichen oder Tabulator), cntrl (Steuerzeichen), digit (0-9), xdigit (hexadezimale Ziffern), print, graph (print ohne Leerzeichen), punct, lower, upper, space (Leerraum), word (gleiche wie <a href="#word">\w</a>).</p>
        <p>Innerhalb einer Zeichenklasse müssen die Zeichen nicht mit einem Escapezeichen versehen werden, es sei denn, sie haben eine besondere Bedeutung in der Klasse; z. B. <span class="regex">[\^a]</span>, <span class="regex">[a\-b]</span>, <span class="regex">[a\]]</span> und <span class="regex">[\\a]</span>.</p></td>
  </tr>
	<tr>
	  <td align="center"><strong>[^...]</strong></td>
	  <td>Stimmt mit jedem Zeichen überein, das <strong>nicht</strong> in der Klasse ist. Zum Beispiel stimmt <span class="regex">[^/]*</span> mit beliebig vielen Vorkommen überein, die <em>kein</em> Schrägstrich enthalten, wie z. B. <span class="subj">http:</span>//. Ebenso stimmt <span class="regex">[^0-9xyz]</span> mit jedem Zeichen überein, das keine Zahl oder nicht der Buchstabe x, y oder z ist.</td>
  </tr>
	<tr>
	  <td align="center"><strong>\d</strong></td>
	  <td>Stimmt mit jeder Ziffer überein (entspricht der Klasse <span class="regex">[0-9]</span>). Umgekehrt bedeutet das großgeschriebene \D: "jedes Zeichen, das <em>keine</em> Ziffer ist". Dieser und die anderen zwei Buchstaben können in einer <a href="#set">Klasse</a> verwendet werden, zum Beispiel bedeutet <span class="regex">[\d.-]</span>: "jede Ziffer, jeder Punkt oder jedes Minuszeichen".</td>
  </tr>
	<tr>
	  <td align="center"><strong>\s</strong></td>
	  <td>Stimmt mit jedem einzelnen Leerraumzeichen überein, was hauptsächlich Leerzeichen, Tabulatoren und Zeilenumbrüche (`r und `n) sind. Umgekehrt bedeutet das großgeschriebene \S: "jedes Zeichen, das <em>kein</em> Leerraumzeichen ist".</td>
  </tr>
	<tr>
	  <td align="center"><strong>\w</strong></td>
	  <td><a name="word"></a>Stimmt mit jedem "Wort"-Zeichen überein, nämlich alphanumerisch oder Unterstrich. Das ist gleichbedeutend mit <span class="regex">[a-zA-Z0-9_]</span>. Umgekehrt bedeutet das großgeschriebene \W: "jedes Zeichen, das <em>kein</em> Wort-Zeichen ist".</td>
  </tr>
	<tr>
	  <td align="center"><strong>^<br>
        
        $</strong></td>
	  <td><p><a name="anchor" id="anchor"></a>Zirkumflex (^) und Dollar-Zeichen ($) werden <em>Anker</em> genannt, weil sie keine Zeichen konsumieren, sondern das Muster an den Anfang oder an das Ende des durchsuchten Strings binden.</p>
	    <p><span class="regex">^</span> kann am Anfang eines Musters stehen, damit die Übereinstimmung ganz am Anfang einer Zeile erfolgt. Zum Beispiel stimmt <span class="regex">^abc</span> mit <span class="subj">abc</span>123 überein, aber nicht mit 123abc.</p>
	    <p><span class="regex">$</span> kann am Ende eines Musters stehen, damit die Übereinstimmung ganz am Ende einer Zeile erfolgt. Zum Beispiel stimmt <span class="regex">abc$</span> mit 123<span class="subj">abc</span> überein, aber nicht mit abc123.</p>
      <p>Die beiden Anker können kombiniert werden. Zum Beispiel stimmt <span class="regex">^abc$</span> nur mit <span class="subj">abc</span> überein (d. h. es dürfen sich keine anderen Zeichen davor oder dahinter befinden).</p>
      <p>Wenn der durchsuchte Text mehrere Zeilen enthält, dann können die Anker mithilfe der <a href="#Multiline">"m"-Option</a> für jede Zeile anstelle des ganzen Textes gültig gemacht werden. Zum Beispiel stimmt <span class="regex">m)^abc$</span> mit 123`r`n<span class="subj">abc</span>`r`n789 überein. Wenn die "m"-Option nicht vorhanden ist, dann erfolgt keine Übereinstimmung.</p></td>
  </tr>
	<tr>
	  <td align="center"><strong>\b</strong></td>
	  <td>\b bedeutet "Wortgrenze", das sich wie ein Anker verhält, weil es keine Zeichen konsumiert. Der Status des aktuellen Zeichens muss ein <a href="#word">Wort-Zeichen (\w)</a> sein, um das Gegenteil des vorherigen Zeichens zu sein. Es wird normalerweise verwendet, um eine versehentliche Übereinstimmung mit einem Wort zu vermeiden, das sich in einem anderen Wort befindet. Zum Beispiel stimmt <span class="regex">\bcat\b</span> nicht mit catfish überein, aber es stimmt mit <span class="subj">cat</span> überein, egal welche Interpunktionen oder Leerraumzeichen sie umgibt. Großgeschriebenes \B bewirkt das Gegenteil: das aktuelle Zeichen darf sich <em>nicht</em> an einer Wortgrenze befinden.</td>
  </tr>
	<tr>
	  <td align="center"><strong>|</strong></td>
	  <td>Mit dem vertikalen Strich werden mehrere Alternativen abgegrenzt. Eine Übereinstimmung erfolgt, wenn eine <em>beliebige</em> Alternative zufrieden gestellt ist. Zum Beispiel stimmt <span class="regex">gray|grey</span> sowohl mit <span class="subj">gray</span> als auch <span class="subj">grey</span> überein. Ebenso bewirkt <span class="regex">gr(a|e)y</span> mithilfe der unten genannten Klammern das Gleiche.</td>
  </tr>
	<tr>
	  <td align="center"><strong>(...)</strong></td>
	  <td><p><a name="subpat"></a>Elemente in Klammern werden häufig verwendet, um:</p>
	    <ul>
	      <li>die Reihenfolge der Auswertung zu bestimmen. Zum Beispiel stimmt <span class="regex">(Sonn|Mon|Diens|Donners|Frei|Sams)tag|Mittwoch</span> mit dem Namen jeden Tages überein.</li>
	      <li><span class="regex">*</span>, <span class="regex">?</span>, <span class="regex">+</span> oder <span class="regex">{min,max}</span> auf eine <em>Reihe</em> von Zeichen anstelle eines Zeichens anzuwenden. Zum Beispiel stimmt <span class="regex">(abc)+</span> mit einem oder mehreren Vorkommen von "abc" überein, daher erfolgt eine Übereinstimmung mit <span class="subj">abcabc</span>123, aber nicht mit ab123 oder bc123.</li>
          <li><a name="capture"></a>einen Teilausdruck wie der Punkt-Stern in <span class="regex">abc<span class="red">(.*)</span>xyz</span> einzufangen. Zum Beispiel speichert <a href="../commands/RegExMatch.htm">RegExMatch()</a> den Teilstring, der mit jedem Teilausdruck übereinstimmt, in einem <a href="../commands/RegExMatch.htm#Array">Ausgabe-Array</a>. Ebenso kann <a href="../commands/RegExReplace.htm">RegExReplace()</a> den Teilstring, der mit jedem Teilausdruck übereinstimmt, in das Ergebnis per <a href="../commands/RegExReplace.htm#BackRef">Rückreferenz</a> (z. B. $1) wieder einfügen. Damit die Klammern den Teilausdruck nicht einfangen, müssen die ersten beiden Zeichen innerhalb der Klammern <span class="regex">?:</span> sein, zum Beispiel: <span class="regex">(<span class="red">?:</span>.*)</span></li>
	      <li><a href="#Options">Optionen</a> nebenbei zu ändern. Zum Beispiel aktiviert <span class="regex">(?im)</span> für den Rest des Musters (oder Teilmuster) die Optionen für die Unabhängigkeit von Groß- und Kleinschreibung und für mehrere Zeilen. Umgekehrt deaktiviert <span class="regex">(?-im)</span> diese Optionen. Alle Optionen werden unterstützt, außer DPS`r`n`a.</li>
	    </ul></td>
  </tr>
	<tr>
	  <td align="center"><strong>\t<br>
  
  \r<br>
  usw.</strong></td>
	  <td><p>Diese Escapesequenzen sind Sonderzeichen. <span class="regex">\t</span> (Tabulator), <span class="regex">\r</span> (CR-Zeichen) und <span class="regex">\n</span> (LF-Zeichen) werden am häufigsten verwendet. In solchen Fällen kann optional ein umgekehrtes Häkchen (`) anstelle des umgekehrten Schrägstrichs verwendet werden. Escapesequenzen in Form von \xhh werden ebenfalls unterstützt, wobei <em>hh</em> der Hex-Code eines ANSI-Zeichensatzes zwischen 00 und FF ist.</p>
      <p>Seit v1.0.46.06 bedeutet <span class="regex">\R</span>: "jeder Zeilenumbruch beliebiger Art", die in der <a href="#NEWLINE_ANY">`a-Option</a> aufgelistet sind (in einer <a href="#class">Zeichenklasse</a> allerdings ist \R lediglich ein normales "R"). Seit v1.0.47.05 kann <span class="regex">\R</span> mit (*BSR_ANYCRLF) am Anfang eines Musters (nach den Optionen) auf CR, LF und CRLF beschränkt werden, zum Beispiel: <span class="regex">im)(*BSR_ANYCRLF)abc\Rxyz</span></p></td>
  </tr>
  <tr id="slashP">
    <td align="center"><strong>\p{xx}<br>\P{xx}<br>\X</strong></td>
    <td><p><span class="ver">[AHK_L 61+]:</span> Eigenschaften von Unicode-Zeichen. Wird nicht von den ANSI-Builds unterstützt. <span class="regex">\p{xx}</span> stimmt mit einem Zeichen anhand der xx-Eigenschaft überein, während <span class="regex">\P{xx}</span> mit einem beliebigen Zeichen <i>ohne</i> die xx-Eigenschaft übereinstimmt. Zum Beispiel stimmt <span class="regex">\pL</span> mit einem beliebigen Buchstaben überein und <span class="regex">\p{Lu}</span> mit einem großgeschriebenen Buchstaben. <span class="regex">\X</span> stimmt mit einer beliebigen Anzahl an Zeichen überein, die eine erweiterte Unicode-Sequenz formen.</p>
    <p>Für eine vollständige Namensliste von unterstützten Eigenschaften und andere Details sucht nach "\p{xx}" in <a href="http://www.pcre.org/pcre.txt">www.pcre.org/pcre.txt</a>.</p></td>
  </tr>
  <tr id="UCP">
    <td><strong>(*UCP)</strong></td>
    <td><p><span class="ver">[AHK_L 61+]:</span> Aus Performance-Gründen erkennen \d, \D, \s, \S, \w, \W, \b und \B standardmäßig nur ASCII-Zeichen, auch in Unicode-Builds. Wenn das Muster mit <span class="regex">(*UCP)</span> beginnt, dann werden die Unicode-Eigenschaften verwendet, um festzustellen, welche Zeichen übereinstimmen. Zum Beispiel wird \w gleichbedeutend mit <span class="regex">[\p{L}\p{N}_]</span> und \d wird gleichbedeutend mit <span class="regex">\p{Nd}</span>.</p>
    </td>
  </tr>
</table>
<p><strong>Greed (Gier)</strong>: Standardmäßig sind <span class="regex">*</span>, <span class="regex">?</span>, <span class="regex">+</span> und <span class="regex">{min,max}</span> gierig, weil sie alle Zeichen bis zum <em>letztmöglichen</em> Zeichen konsumieren, die das ganze Muster zufriedenstellen. Damit das Konsumieren beim <em>erstmöglichen</em> Zeichen endet, fügt nach den Quantoren ein Fragezeichen an. Zum Beispiel hat das Muster <span class="regex">&lt;.+&gt;</span> (ohne Fragezeichen) die folgende Bedeutung: suche nach einem &lt;, gefolgt von einem oder mehren Zeichen, gefolgt von einem &gt;. Um das Muster daran zu hindern, mit dem <em>ganzen</em> String <span class="subj"><span class="red"><strong>&lt;</strong></span>em&gt;text&lt;/em<span class="red"><strong>&gt;</strong></span></span> übereinzustimmen, fügt nach dem Pluszeichen ein Fragezeichen an: <span class="regex">&lt;.+<span class="red">?</span>&gt;</span>. Dadurch stoppt die Übereinstimmung beim ersten '&gt;' und stimmt daher nur mit dem ersten Tag <span class="subj"><span class="red"><strong>&lt;</strong></span>em<span class="red"><strong>&gt;</strong></span></span> überein.</p>
<p><strong>Vorausschauende und zurückschauende Behauptungen</strong>: Die Gruppen <span class="regex">(?=...)</span>, <span class="regex">(?!...)</span>, <span class="regex">(?&lt;=...)</span> und <span class="regex">(?&lt;!...)</span> werden <em>Behauptungen</em> genannt, weil sie darauf bestehen, dass eine Bedingung eintrifft, ohne dabei beliebige Zeichen zu konsumieren. Zum Beispiel ist <span class="regex">abc(?=.*xyz)</span> eine vorausschauende Behauptung, weil der String xyz sich irgendwo auf der rechten Seite des Strings abc befinden muss (ist das nicht der Fall, dann erfolgt keine Übereinstimmung). Mit <span class="regex">(?=...)</span> wird <em>positiv</em> vorausgeschaut, weil das angegebene Muster vorhanden sein muss. Im Gegenzug wird mit <span class="regex">(?!...)</span> <em>negativ</em> vorausgeschaut, weil das angegebene Muster <em>nicht</em> vorhanden sein darf. Ebenso wird mit <span class="regex">(?&lt;=...)</span> und <span class="regex">(?&lt;!...)</span> positiv bzw. negativ <em>zurückgeschaut</em>, weil sie auf der <em>linken</em> anstelle der rechten Seite nachschauen. Zurückschauende Behauptungen haben mehr Einschränkungen als vorausschauende Behauptungen, weil sie keine Quantoren mit verändernder Größe wie <span class="regex">*</span>, <span class="regex">?</span> und <span class="regex">+</span> unterstützen. Die Escapesequenz \K ist mit einer zurückschauenden Behauptung vergleichbar, weil sie alle zuletzt übereinstimmende Zeichen vom Endergebnis weglässt. Zum Beispiel stimmt <span class="regex">foo\Kbar</span> mit "foobar" überein, aber mit der Meldung, dass es eine Übereinstimmung mit "bar" hat.</p>
<p><strong>Siehe auch</strong>: Reguläre Ausdrücke werden von <a href="../commands/RegExMatch.htm">RegExMatch()</a>, <a href="../commands/RegExReplace.htm">RegExReplace()</a> und <a href="../commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> unterstützt.</p>
<p><strong>Schlussbemerkung</strong>: Obwohl diese Seite häufig verwendete RegEx-Funktionen anreißt, existieren noch weitere Funktionen, die untersucht werden können, wie z. B. bedingte Teilmuster. Das komplette Handbuch über PCRE kann auf <a href="http://www.pcre.org/pcre.txt">www.pcre.org/pcre.txt</a> gefunden werden.</p>
<p>&nbsp;</p>
</body>
</html>
