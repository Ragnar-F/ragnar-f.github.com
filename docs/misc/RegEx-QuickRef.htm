<!DOCTYPE HTML>
<html>
<head>
<title>Reguläre Ausdrücke (RegEx) - Kurzübersicht</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
<style type="text/css">
<!--
.regex {background-color: #FFEED3; font-weight: bold}
.subj {background-color: #DDFFDD}
-->
</style>
</head>
<body>
<h1>Reguläre Ausdrücke (RegEx) - Kurzübersicht</h1>

<h2>Grundlagen</h2>
<p><strong>Standardverhalten</strong>: Ein regulärer Ausdruck kann einen Teilstring innerhalb des zu durchsuchenden Strings finden, <em>egal wo</em> sich dieser befindet. Der reguläre Ausdruck <span class="regex">abc</span> würde beispielsweise mit <span class="subj">abc</span>123, 123<span class="subj">abc</span> und 123<span class="subj">abc</span>xyz übereinstimmen. Wenn eine Übereinstimmung am Anfang oder Ende erfolgen soll, verwende einen <a href="#anchor">Anker</a>.</p>
<p><strong>Escapezeichen</strong>: Die meisten Zeichen wie abc123 können direkt in einem regulären Ausdruck verwendet werden. Bei den Zeichen <strong>\.*?+[{|()^$</strong> muss man allerdings einen umgekehrten Schrägstrich davorsetzen. Zum Beispiel wäre <span class="regex">\.</span> ein normaler Punkt und <span class="regex">\\</span> ein normaler umgekehrter Schrägstrich. Mithilfe von \Q...\E kann man dieses Davorsetzen des Schrägstriches umgehen. Zum Beispiel: \QNormaler Text\E.</p>
<p><strong>Zeichengenau</strong>: Standardmäßig unterscheiden reguläre Ausdrücke zwischen Groß- und Kleinschreibung. Mit der "i"-Option kann das geändert werden. Zum Beispiel würde das Muster <span class="regex">i)abc</span> nach "abc" suchen, ohne auf die Groß- und Kleinschreibung zu achten. Siehe unten für weitere Modifikatoren.</p>

<h2 id="Options">Optionen (zeichengenau)</h2>
<p>Direkt am Anfang eines regulären Ausdrucks können beliebig viele Optionen angegeben werden, gefolgt von einer schließenden Klammer. Zum Beispiel würde das Muster "<span class="red">im)</span>abc" nach <em>abc</em> suchen, mit den Optionen "zeichenungenau" und "mehrzeilig" (die Klammer kann weggelassen werden, falls keine Optionen vorhanden sind). Obwohl diese Syntax vom traditionellen Weg abweicht, benötigt es keine speziellen Trennzeichen (wie z. B. einen Schrägstrich). Das heißt, dass solche Trennzeichen innerhalb des Musters nicht mit einem Escapezeichen versehen werden müssen. Da die Optionen dadurch einfacher zu parsen sind, ist die Performance erhöht.</p>
<table class="info">
  <tr id="opt_i">
    <td><strong>i</strong></td>
    <td>Zeichenungenaue Übereinstimmung. Die Großbuchstaben von A bis Z und ihre Kleinbuchstaben werden gleichwertig behandelt.</td>
  </tr>
  <tr>
    <td><strong>m</strong></td>
    <td><p><a name="Multiline"></a>Multiline (mehrzeilig). <em>Heuhaufen</em> wird nicht als durchgehende Zeile, sondern als Ansammlung von einzelnen Zeilen angesehen (sofern Zeilenumbrüche enthalten sind). Folgende Änderungen treten dabei in Kraft:</p>
      <p>1) Zirkumflex (^) hat nach jedem internen Zeilenumbruch eine Übereinstimmung, sowie immer am Anfang des <em>Heuhaufens</em> (aber nicht nach einem Zeilenumbruch <em>ziemlich am Ende</em> des <em>Heuhaufens</em>).</p>
      <p>2) Dollar-Zeichen ($) hat vor jedem Zeilenumbruch im <em>Heuhaufen</em> eine Übereinstimmung (sowie immer ganz am Ende).</p>
      <p>Zum Beispiel würde das Muster "<span class="red">m)</span>^abc$" nur mit dem <em>Heuhaufen</em> "xyz`r`nabc" übereinstimmen, wenn die "m"-Option vorhanden wäre.</p>
      <p>Die "D"-Option wird ignoriert, wenn "m" vorhanden ist.</p></td>
  </tr>
  <tr id="opt_s">
    <td><strong>s</strong></td>
    <td>DotAll. Bewirkt, dass ein Punkt (.) mit allen Zeichen übereinstimmt, einschließlich Zeilenumbrüche (normalerweise stimmt er nicht mit Zeilenumbrüchen überein). Beachte: Wenn das Zeilenumbruchszeichen standardmäßig CRLF (`r`n) ist, sind zwei Punkte (statt einer) für eine Übereinstimmung erforderlich. Unabhängig von dieser Option stimmt eine negative Klasse wie [^a] immer mit Zeilenumbrüchen überein.</td>
  </tr>
  <tr id="opt_x">
    <td><strong>x</strong></td>
    <td>Ignoriert Leerraumzeichen im Muster, solange sie nicht mit einem Escapezeichen versehen sind oder sich in einer Zeichenklasse befinden. Die Zeichen `n und `t dazwischen werden ignoriert, weil sie, sobald sie PCRE erreichen, bereits unbearbeitete/normale Leerraumzeichen sind (dagegen werden \n und \t nicht ignoriert, weil sie PCRE-Escapesequenzen sind). Die <strong>x</strong>-Option ignoriert zudem Zeichen zwischen einem #-Zeichen (ohne versehenem Escapezeichen und außerhalb einer Zeichenklasse) und dem nächsten Zeilenumbruchszeichen. Dadurch können Kommentare innerhalb eines komplizierten Musters eingefügt werden. Dies gilt jedoch nur für Datenzeichen; Leerraumzeichen dürfen nicht in speziellen Zeichenfolgen erscheinen, wie in (?(, das einen bedingten Teilmuster startet.</td>
  </tr>
  <tr id="opt_A">
    <td><strong>A</strong></td>
    <td>Erzwingt die Verankerung des Musters; das heißt, dass das Muster nur am Anfang des <em>Heuhaufens</em> eine Übereinstimmung haben kann. In den meisten Fällen ist es das gleiche wie, als würde man das Muster z. B. mithilfe von "^" explizit verankern.</td>
  </tr>
  <tr id="opt_D">
    <td><strong>D</strong></td>
    <td>Zwingt das Dollar-Zeichen ($) dazu, eine Übereinstimmung mit dem Ende des <em>Heuhaufens</em> zu haben, selbst wenn das letzte Zeichen im <em>Heuhaufen</em> ein Zeilenumbruch ist. Wenn diese Option nicht vorhanden ist, hat das $ direkt vor dem letzten Zeilenumbruch eine Übereinstimmung (falls vorhanden). Hinweis: Diese Option wird ignoriert, wenn "m" vorhanden ist.</td>
  </tr>
  <tr id="opt_J">
    <td><strong>J</strong></td>
    <td>Erlaubt es, dass <a href="../commands/RegExMatch.htm#NamedSubPat">benannte Teilmuster</a> mehrmals vorkommen dürfen. Dies kann für Muster nützlich sein, in denen nur einer von mehreren gleichnamigen Teilmustern eine Übereinstimmung haben kann. Hinweis: Wenn mehrere Instanzen eines bestimmten Namens mit etwas übereinstimmen, wird nur die Instanz ganz links gespeichert. Darüber hinaus unterscheiden Variablennamen nicht zwischen Groß- und Kleinschreibung.</td>
  </tr>
  <tr id="opt_U">
    <td><strong>U</strong></td>
    <td>Ungreedy (nicht gierig). Bringt die Quantoren *+?{} dazu, nur Zeichen zu verbrauchen, die absolut notwendig sind, um eine Übereinstimmung zu ermöglichen. Die restlichen noch verfügbaren Zeichen gelten für den nächsten Teil des Musters. Erfolgt bei deaktivierter U-Option unmittelbar nach einem einzelnen Quantor ein Fragezeichen, macht man ihn ungreedy. Bei <em>aktivierter</em> U-Option bewirkt das Fragezeichen genau das Gegenteil - es macht einen einzelnen Quantor greedy.</td>
  </tr>
  <tr id="opt_extra">
    <td><strong>X</strong></td>
    <td>PCRE_EXTRA. Aktiviert PCRE-Features, die mit Perl nicht kompatibel sind. Das derzeit einzige Feature davon ist, dass jeder umgekehrter Schrägstrich in einem Muster, gefolgt von einem Buchstaben ohne besondere Bedeutung, eine Übereinstimmung fehlschlagen lässt und ErrorLevel demzufolge setzt. Diese Option ist nützlich, um ungenutzte Backslash-Sequenzen dieser Art für die zukünftige Verwendung zu reservieren. Ist diese Option nicht vorhanden, wird ein umgekehrter Schrägstrich, gefolgt von einem Buchstaben ohne besondere Bedeutung, als gewöhnlich angesehen (das heißt beispielsweise, dass \g und g als gewöhnliches g erkannt werden). Unabhängig von dieser Option werden nicht-alphabetische Backslash-Sequenzen ohne besondere Bedeutung immer als gewöhnlich angesehen (das heißt beispielsweise, dass \/ und / als gewöhnlicher Schrägstrich erkannt werden).</td>
  </tr>
  <tr id="opt_P">
    <td><strong>P</strong></td>
    <td>Positionsmodus. Bewirkt, dass RegExMatch() die Position und Länge der Übereinstimmung und ihrer Teilmuster zurückgibt, anstatt die gefundenen Teilstrings. Für weitere Details, siehe <a href="../commands/RegExMatch.htm#PosMode">NichtZitierteAusgabeVar</a>.</td>
  </tr>
  <tr>
    <td><strong>S</strong></td>
    <td><a name="Study"></a>Untersucht, ob die Performance des Musters verbessert werden kann. Dies ist nützlich, wenn ein bestimmtes (besonders komplexes) Muster sehr oft ausgeführt wird. Wenn PCRE einen Weg findet, die Performance zu verbessern, wird die Entdeckung zusammen mit dem Muster zwischengespeichert, so dass nachfolgende Muster gleicher Art davon profitieren können (diese Muster sollten die S-Option auch enthalten, weil das Finden einer Übereinstimmung innerhalb des Caches voraussetzt, dass die Optionsbuchstaben exakt übereinstimmen, einschließlich ihrer Reihenfolge).</td>
  </tr>
  <tr id="opt_Callout">
    <td><strong>C</strong></td>
    <td>Aktiviert den Auto-Callout-Modus. Siehe <a href="../misc/RegExCallout.htm#auto">Callouts in regulären Ausdrücken</a> für weitere Informationen.</td>
  </tr>
  <tr id="opt_esc_n">
    <td><strong>`n</strong></td>
    <td>Verwendet anstelle des voreingestellten Unterbrechungszeichens (`r`n) ein einzelnes LF-Zeichen (`n), das üblicherweise auf UNIX-Systemen als Unterbrechungszeichen gilt. Das ausgewählte Unterbrechungszeichen beeinflusst das Verhalten von <a href="../misc/RegEx-QuickRef.htm#anchor">Verankerungen (^ und $)</a> und <a href="../misc/RegEx-QuickRef.htm#dot">Muster mit Punkten</a>.</td>
  </tr>
  <tr id="opt_esc_r">
    <td><strong>`r</strong></td>
    <td>Verwendet anstelle des voreingestellten Unterbrechungszeichens (`r`n) ein einzelnes CR-Zeichen (`r).</td>
  </tr>
  <tr>
    <td><strong>`a</strong></td>
    <td><a name="NEWLINE_ANY"></a>Seit v1.0.46.06 kann mit `a jeder Zeilenumbruchstyp erkannt werden: `r, `n, `r`n, `v/VT/vertical tab/chr(0xB), `f/FF/formfeed/chr(0xC) und NEL/next-line/chr(0x85). Seit v1.0.47.05 kann man (*ANYCRLF) in Großbuchstaben und am Anfang eines Musters (nach den Optionen) angeben, um Zeilenumbrüche nur auf CR, LF und CRLF zu beschränken; zum Beispiel: <code>im)(*ANYCRLF)^abc$</code>.</td>
  </tr>
</table>
<p>Hinweis: Es ist möglich, die Optionen mit Leer- und Tabulatorzeichen voneinander zu trennen.</p>

<h2 id="Common">Häufig verwendete Symbole und Syntax</h2>
<table class="info">
	<tr>
		<td align="center"><strong>.</strong></td>
		<td><a name="dot"></a>Standardmäßig stimmt ein Punkt mit einem einzelnen Zeichen überein, das nicht zu einer Zeilenumbruchssequenz (`r`n) gehört. Dieses Verhalten kann aber mit den Optionen <a href="#opt_s">DotAll (s)</a>, <a href="#opt_esc_n">LF (`n)</a>, <a href="#opt_esc_r">CR (`r)</a>, <a href="#NEWLINE_ANY">`a oder (*ANYCRLF)</a> geändert werden. Zum Beispiel würde <span class="regex">ab.</span> mit <span class="subj">abc</span> und <span class="subj">abz</span> und <span class="subj">ab_</span> übereinstimmen.</td>
	</tr>
	<tr>
		<td align="center"><strong>*</strong></td>
		<td><p>Ein Sternchen findet 0 oder mehrere Vorkommen des voranstehenden Elements (Zeichen, <a href="#class">Klasse</a> oder <a href="#subpat">Teilausdruck</a>). Zum Beispiel würde <span class="regex">a*</span> mit <span class="subj">a</span>b und <span class="subj">aaa</span>b übereinstimmen. Dieser reguläre Ausdruck würde auch mit dem Anfang eines beliebigen Strings ohne "a" übereinstimmen.</p>
	      <p><strong>Platzhalter</strong>: Das Punkt-Sternchen-Muster <span class="regex">.*</span> ist eines der tolerantesten Muster, weil es 0 oder mehrere Vorkommen eines <em>beliebigen</em> Zeichens finden kann (außer Zeilenumbruch: `r und `n). Zum Beispiel würde <span class="regex">abc.*123</span> mit <span class="subj">abcAnything123</span> sowie mit <span class="subj">abc123</span> übereinstimmen.</p>		  </td>
	</tr>
	<tr>
	  <td align="center"><strong>?</strong></td>
	  <td>Ein Fragezeichen findet 0 oder 1 Vorkommen des voranstehenden Elements (Zeichen, <a href="#set">Klasse</a> oder <a href="#subpat">Teilausdruck</a>). Oder auch: "Das voranstehende Element ist optional". Zum Beispiel würde <span class="regex">colou?r</span> sowohl mit <span class="subj">color</span> als auch mit <span class="subj">colour</span> übereinstimmen, weil das "u" optional ist.</td>
  </tr>
	<tr>
	  <td align="center"><strong>+</strong></td>
	  <td>Ein Pluszeichen findet 1 oder mehrere Vorkommen des voranstehenden Elements (Zeichen, <a href="#class">Klasse</a> oder <a href="#subpat">Teilausdruck</a>). Zum Beispiel würde <span class="regex">a+</span> mit <span class="subj">a</span>b und <span class="subj">aaa</span>b übereinstimmen. Aber im Gegensatz zu <span class="regex">a*</span> und <span class="regex">a?</span> würde das Muster <span class="regex">a+</span> nicht mit dem Anfang eines Strings ohne "a" übereinstimmen.</td>
  </tr>
	<tr>
	  <td align="center">{min,max}</td>
	  <td><p>Findet <em>min</em> bis <em>max</em> Vorkommen des voranstehenden Elements (Zeichen, <a href="#set">Klasse</a> oder <a href="#subpat">Teilausdruck</a>). Zum Beispiel würde <span class="regex">a{1,2}</span> mit <span class="subj">a</span>b übereinstimmen, als auch die ersten zwei a's mit <span class="subj">aa</span>ab.</p>
        <p>Zudem würde {3} genau 3 Vorkommen finden, und {3<strong>,</strong>} 3 oder mehrere Vorkommen. Hinweis: Die angegebenen Zahlen müssen kleiner als 65536 sein. Außerdem muss der erste Wert entweder kleiner oder genauso groß wie der zweite Wert sein.</p></td>
  </tr>
	<tr>
	  <td align="center"><strong>[...]</strong></td>
	  <td><p><a name="set"></a><a name="class"></a><strong>Zeichenklassen</strong>: Die eckigen Klammern umschließen eine Liste oder einen Bereich von Zeichen (oder beides). Zum Beispiel bedeutet <span class="regex">[abc]</span>: "jedes Zeichen, das entweder ein a, b oder c ist". Mit einem Bindestrich kann ein Bereich dargestellt werden; zum Beispiel bedeutet <span class="regex">[a-z]</span>: "jedes Zeichen von a bis z". Listen und Bereiche können kombiniert werden; zum Beispiel bedeutet <span class="regex">[a-zA-Z0-9_]</span>: "jedes Zeichen, das alphanumerisch oder ein Unterstrich ist".</p>
	    <p>Nach einer Zeichenklasse kann *, ?, + oder {min,max} erfolgen. <span class="regex">[0-9]+</span> würde beispielsweise 1 oder mehrere Vorkommen von beliebigen Ziffern finden; somit würde es mit xyz<span class="subj">123</span> übereinstimmen, aber nicht mit abcxyz.</p>            
        <p>Desweiteren kann man benannte Zeichenbereiche (POSIX) in Form von [[:xxx:]] angeben; xxx ist dabei eines der folgenden Wörter: alnum, alpha, ascii (0-127), blank (Leerzeichen oder Tabulator), cntrl (Steuerzeichen), digit (0-9), xdigit (hexadezimale Ziffern), print, graph (print ohne space), punct, lower, upper, space (Leerraum), word (das gleiche wie <a href="#word">\w</a>).</p>
        <p>Innerhalb einer Zeichenklasse müssen die Zeichen nicht mit einem Escapezeichen versehen werden, sofern sie keine besondere Bedeutung in der Klasse haben; z. B. <span class="regex">[\^a]</span>, <span class="regex">[a\-b]</span>, <span class="regex">[a\]]</span> und <span class="regex">[\\a]</span>.</p></td>
  </tr>
	<tr>
	  <td align="center"><strong>[^...]</strong></td>
	  <td>Findet jedes einzelne Zeichen, das <strong>nicht</strong> in der Klasse vorkommt. <span class="regex">[^/]*</span> würde beispielsweise 0 oder mehrere Vorkommen von beliebigen Zeichen finden, das <em>kein</em> Schrägstrich ist, wie z. B. <span class="subj">http:</span>//. Ebenso würde <span class="regex">[^0-9xyz]</span> jedes Zeichen finden, das weder eine Ziffer noch der Buchstabe x, y oder z ist.</td>
  </tr>
	<tr>
	  <td align="center"><strong>\d</strong></td>
	  <td>Findet jede einzelne Ziffer (entspricht der Klasse <span class="regex">[0-9]</span>). Ein großgeschriebenes \D würde hingegen bedeuten, dass jedes Zeichen gefunden wird, das <em>keine</em> Ziffer ist. Diese und die anderen zwei Escapesequenzen darunter können innerhalb einer <a href="#set">Klasse</a> verwendet werden; zum Beispiel bedeutet <span class="regex">[\d.-]</span>: "jede Ziffer, jeder Punkt oder jedes Minuszeichen".</td>
  </tr>
	<tr>
	  <td align="center"><strong>\s</strong></td>
	  <td>Findet jedes einzelne Leerraumzeichen wie z. B. Leerzeichen, Tabulatoren und Zeilenumbrüche (`r und `n). Ein großgeschriebenes \S würde hingegen bedeuten, dass jedes Zeichen gefunden wird, das <em>kein</em> Leerraumzeichen ist.</td>
  </tr>
	<tr>
	  <td align="center"><strong>\w</strong></td>
	  <td><a name="word"></a>Findet jedes einzelne Wortzeichen, das alphanumerisch oder ein Unterstrich ist. Das ist das gleiche wie <span class="regex">[a-zA-Z0-9_]</span>. Ein großgeschriebenes \W würde hingegen bedeuten, dass jedes Zeichen gefunden wird, das <em>kein</em> Wortzeichen ist.</td>
  </tr>
	<tr>
	  <td align="center"><strong>^<br>
        
        $</strong></td>
	  <td><p><a name="anchor" id="anchor"></a>Zirkumflex (^) und Dollar-Zeichen ($) werden <em>Anker</em> genannt. Sie verbrauchen keine Zeichen, sondern binden das Muster an den Anfang oder Ende des zu durchsuchenden Strings.</p>
	    <p><span class="regex">^</span> kann am Anfang eines Musters stehen, um die Übereinstimmung direkt am Anfang einer Zeile zu erzwingen. Zum Beispiel würde <span class="regex">^abc</span> mit <span class="subj">abc</span>123 übereinstimmen, aber nicht mit 123abc.</p>
	    <p><span class="regex">$</span> kann am Ende eines Musters stehen, um die Übereinstimmung direkt am Ende einer Zeile zu erzwingen. Zum Beispiel würde <span class="regex">abc$</span> mit 123<span class="subj">abc</span> übereinstimmen, aber nicht mit abc123.</p>
      <p>Die beiden Anker können kombiniert werden. Zum Beispiel würde <span class="regex">^abc$</span> nur mit <span class="subj">abc</span> übereinstimmen (das heißt, dass sich keine Zeichen davor oder dahinter befinden).</p>
      <p>Wenn der zu durchsuchende Text mehrere Zeilen enthält, können die Anker mit der <a href="#Multiline">m-Option</a> dazu gebracht werden, für jede Zeile zu gelten, anstatt für den gesamten Text. Zum Beispiel würde <span class="regex">m)^abc$</span> mit 123`r`n<span class="subj">abc</span>`r`n789 übereinstimmen. Aber ohne die m-Option würde es nicht übereinstimmen.</p></td>
  </tr>
	<tr>
	  <td align="center"><strong>\b</strong></td>
	  <td>\b dient als Abgrenzung eines Wortes. Es ist wie ein Anker, weil es keine Zeichen verbraucht. Es setzt voraus, dass das aktuelle Zeichen, welches ein <a href="#word">Wortzeichen (\w)</a> sein muss, das Gegenteil des vorherigen Zeichens ist. Diese Escapesequenz wird normalerweise verwendet, um zu vermeiden, dass das gesuchte Wort innerhalb eines anderen Wortes versehentlich zu finden ist. Zum Beispiel würde <span class="regex">\bcat\b</span> nicht mit catfish, sondern mit <span class="subj">cat</span> übereinstimmen, egal welche Interpunktionen oder Leerraumzeichen sich daneben befinden. Ein großgeschriebenes \B bewirkt das Gegenteil: Es setzt voraus, dass das aktuelle Zeichen sich <em>nicht</em> neben einer Wortabgrenzung befindet.</td>
  </tr>
	<tr>
	  <td align="center"><strong>|</strong></td>
	  <td>Der senkrechte Strich trennt zwei oder mehr Alternativen. Eine Übereinstimmung erfolgt, wenn <em>eine</em> der Alternativen zutrifft. Zum Beispiel würde <span class="regex">gray|grey</span> sowohl mit <span class="subj">gray</span> als auch mit <span class="subj">grey</span> übereinstimmen. Mithilfe der unten beschriebenen Klammern kann das Muster <span class="regex">gr(a|e)y</span> das gleiche bewirken.</td>
  </tr>
	<tr>
	  <td align="center"><strong>(...)</strong></td>
	  <td><p><a name="subpat"></a>Elemente, die in Klammern gesetzt sind, werden häufig verwendet, ...:</p>
	    <ul>
	      <li>... um die Reihenfolge der Auswertung zu bestimmen. Zum Beispiel würde <span class="regex">(Sonn|Mon|Diens|Donners|Frei|Sams)tag|Mittwoch</span> den Namen jeden Tages finden.</li>
	      <li>... um <span class="regex">*</span>, <span class="regex">?</span>, <span class="regex">+</span> oder <span class="regex">{min,max}</span> auf <em>mehrere</em> Zeichen anzuwenden. <span class="regex">(abc)+</span> würde beispielsweise 1 oder mehrere Vorkommen von "abc" finden; somit würde es mit <span class="subj">abcabc</span>123 übereinstimmen, aber nicht mit ab123 oder bc123.</li>
          <li><a name="capture"></a>... um einen Teilmuster zu erfassen, wie das Punkt-Stern-Muster in <span class="regex">abc<span class="red">(.*)</span>xyz</span>. Zum Beispiel würde die <a href="../commands/RegExMatch.htm">RegExMatch()</a>-Funktion den Teilstring, der mit jedem Teilmuster übereinstimmt, in ihren <a href="../commands/RegExMatch.htm#Array">Ausgabe-Array</a> speichern. Ebenso würde die <a href="../commands/RegExReplace.htm">RegExReplace()</a>-Funktion erlauben, dass der Teilstring, der mit jedem Teilmuster übereinstimmt, per <a href="../commands/RegExReplace.htm#BackRef">Rückreferenz</a> wie z. B. $1 wieder in das Ergebnis eingefügt werden kann. Schreibe <span class="regex">?:</span> direkt nach der öffnenden Klammer, um zu verhindern, dass der Teilstring erfasst wird; zum Beispiel: <span class="regex">(<span class="red">?:</span>.*)</span></li>
	      <li>... um <a href="#Options">Optionen</a> spontan zu ändern. Zum Beispiel würde <span class="regex">(?im)</span> die Optionen "zeichenungenau" und "mehrzeilig" für den Rest des Musters (oder Teilmusters) einschalten. <span class="regex">(?-im)</span> würde hingegen beide Optionen ausschalten. Es werden alle Optionen außer DPS`r`n`a unterstützt.</li>
	    </ul></td>
  </tr>
	<tr>
	  <td align="center"><strong>\t<br>
  
  \r<br>
  usw.</strong></td>
	  <td><p>Diese Escapesequenzen stehen für spezielle Zeichen. Die am häufigsten verwendeten Sequenzen sind <span class="regex">\t</span> (Tabulator), <span class="regex">\r</span> (CR-Zeichen) und <span class="regex">\n</span> (LF-Zeichen). In solchen Fällen kann optional ein umgekehrtes Häkchen (`) anstelle des umgekehrten Schrägstrichs verwendet werden. Escapesequenzen in Form von \xhh werden ebenfalls unterstützt; <em>hh</em> ist dabei der hexadezimale Code eines beliebigen ANSI-Zeichens zwischen 00 und FF.</p>
      <p>Seit v1.0.46.06 bedeutet <span class="regex">\R</span>: "jeder Zeilenumbruch beliebiger Art". Die betroffenen Zeilenumbrüche sind bei <a href="#NEWLINE_ANY">`a-Option</a> aufgelistet (innerhalb einer <a href="#class">Zeichenklasse</a> ist \R lediglich ein normales "R"). Seit v1.0.47.05 kann <span class="regex">\R</span> auf CR, LF, und CRLF beschränkt werden, indem man (*BSR_ANYCRLF) in Großbuchstaben am Anfang eines Musters (nach den Optionen) angibt; zum Beispiel: <span class="regex">im)(*BSR_ANYCRLF)abc\Rxyz</span></p></td>
  </tr>
  <tr id="slashP">
    <td align="center"><strong>\p{xx}<br>\P{xx}<br>\X</strong></td>
    <td><p><span class="ver">[AHK_L 61+]:</span> Eigenschaften von Unicode-Zeichen. Diese Sequenzen werden nicht in ANSI-Builds unterstützt. <span class="regex">\p{xx}</span> würde ein Zeichen anhand der xx-Eigenschaft finden, während <span class="regex">\P{xx}</span> ein beliebiges Zeichen <i>ohne</i> die xx-Eigenschaft finden würde. Zum Beispiel würde <span class="regex">\pL</span> einen beliebigen Buchstaben und <span class="regex">\p{Lu}</span> einen beliebigen Großbuchstaben finden. <span class="regex">\X</span> würde eine beliebige Anzahl an Zeichen finden, die eine erweiterte Unicode-Sequenz darstellen.</p>
    <p>Suche nach "\p{xx}" auf <a href="http://www.pcre.org/pcre.txt">www.pcre.org/pcre.txt</a>, um eine vollständige Liste der unterstützten Eigenschaftsnamen zu erhalten, sowie für weitere Details.</p></td>
  </tr>
  <tr id="UCP">
    <td><strong>(*UCP)</strong></td>
    <td><p><span class="ver">[AHK_L 61+]:</span> Aus Performance-Gründen können die Escapesequenzen \d, \D, \s, \S, \w, \W, \b und \B nur ASCII-Zeichen erkennen, auch in Unicode-Builds. Beginnt das Muster mit <span class="regex">(*UCP)</span>, werden Unicode-Eigenschaften verwendet, um zu bestimmen, welche Zeichen gefunden werden. Zum Beispiel wäre dadurch \w das gleiche wie <span class="regex">[\p{L}\p{N}_]</span> und \d das gleiche wie <span class="regex">\p{Nd}</span>.</p>
    </td>
  </tr>
</table>
<p><strong>Greed (Gier)</strong>: Standardmäßig sind <span class="regex">*</span>, <span class="regex">?</span>, <span class="regex">+</span>, und <span class="regex">{min,max}</span> greedy, weil sie alle Zeichen bis zum <em>letztmöglichen</em> Zeichen, das zum Muster noch passt, verbrauchen. Wenn sie beim <em>erstmöglichen</em> Zeichen enden sollen, muss nach ihnen ein Fragezeichen erfolgen. Zum Beispiel hätte das Muster <span class="regex">&lt;.+&gt;</span> (wo ein Fragezeichen fehlt) die folgende Bedeutung: "suche nach einem &lt;, gefolgt von 1 oder mehreren Zeichen, gefolgt von einem &gt;". Um das Muster daran zu hindern, den <em>ganzen</em> String <span class="subj"><span class="red"><strong>&lt;</strong></span>em&gt;text&lt;/em<span class="red"><strong>&gt;</strong></span></span> zu finden, muss nach dem Pluszeichen ein Fragezeichen erfolgen: <span class="regex">&lt;.+<span class="red">?</span>&gt;</span>. Dies bewirkt, dass die Übereinstimmung beim ersten '&gt;' stoppt und daher nur der erste HTML-Tag <span class="subj"><span class="red"><strong>&lt;</strong></span>em<span class="red"><strong>&gt;</strong></span></span> gefunden wird.</p>
<p><strong>Vorausschauende und zurückschauende Behauptungen</strong>: Die Gruppen <span class="regex">(?=...)</span>, <span class="regex">(?!...)</span>, <span class="regex">(?&lt;=...)</span> und <span class="regex">(?&lt;!...)</span> werden <em>Behauptungen</em> genannt, weil sie eine Bedingung erfüllt sehen wollen, aber keine Zeichen verbrauchen. Zum Beispiel wäre <span class="regex">abc(?=.*xyz)</span> eine vorausschauende Behauptung, die voraussetzt, dass der String xyz irgendwo auf der rechten Seite des Strings abc vorkommt (ist er dort nicht, wird das gesamte Muster nicht als Übereinstimmung angesehen). <span class="regex">(?=...)</span> nennt sich <em>positives</em> Vorausschauen, weil es voraussetzt, dass das angegebene Muster existiert. <span class="regex">(?!...)</span>  nennt sich hingegen <em>negatives</em> Vorausschauen, weil es voraussetzt, dass das angegebene Muster <em>nicht</em> existiert. Im Vergleich dazu ist <span class="regex">(?&lt;=...)</span> und <span class="regex">(?&lt;!...)</span> positives und negatives <em>Zurückschauen</em>, weil sie die <em>linke</em> statt rechte Seite der aktuellen Position untersuchen. Zurückschauende Behauptungen haben mehr Einschränkungen als vorausschauende Behauptungen, weil sie keine Quantoren mit variierbarer Größe unterstützen, wie z. B. <span class="regex">*</span>, <span class="regex">?</span> und <span class="regex">+</span>. Die Escapesequenz \K ist ungefähr das gleiche wie eine zurückschauende Behauptung, weil sie bewirkt, dass alle zuvor gefundenen Zeichen im Endergebnis wegfallen. Zum Beispiel würde <span class="regex">foo\Kbar</span> mit "foobar" übereinstimmen, aber melden, dass es nur "bar" gefunden hat.</p>
<p><strong>Siehe auch</strong>: Reguläre Ausdrücke werden von <a href="../commands/RegExMatch.htm">RegExMatch()</a>, <a href="../commands/RegExReplace.htm">RegExReplace()</a> und <a href="../commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> unterstützt.</p>
<p><strong>Schlussbemerkung</strong>: Diese Seite beschreibt die am häufigsten verwendeten RegEx-Funktionen. Allerdings gibt es noch ein paar andere Features, die du dir vielleicht anschauen willst, wie z. B. bedingte Teilmuster. Das komplette Handbuch zu PCRE findest du auf <a href="http://www.pcre.org/pcre.txt">www.pcre.org/pcre.txt</a>.</p>
<p>&nbsp;</p>
</body>
</html>
