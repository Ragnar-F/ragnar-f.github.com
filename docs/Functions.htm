<!DOCTYPE HTML>
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/jquery.js" type="text/javascript"></script>
<script src="static/tree.jquery.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Rückgabewerte an den Aufrufer</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion</a></li>
  <li><a href="#ShortCircuit">Logische Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Subroutinen innerhalb einer Funktion verwenden</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</a></li>
  <li><a href="#lib">Funktionsbibliotheken: Standard- und Benutzerbibliothek</a></li>
  <li><a href="#BuiltIn">Integrierte Funktionen</a></li>
</ul>
<h2><a name="intro" id="intro"></a>Einführung und einfache Beispiele</h2>
<p><a name="define"></a>Eine Funktion ist mit einer Subroutine (<a href="commands/Gosub.htm">GoSub</a>) vergleichbar, die zusätzlich noch Parameter (Eingaben) von ihrem Aufrufer entgegennehmen kann. Bei Bedarf kann eine Funktion dem Aufrufer einen Wert zurückgeben. Betrachte die folgende einfache Funktion, die zwei Zahlen akzeptiert und deren Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    Return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
<p>Das obere Beispiel nennt sich <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (unabhängig von Groß- und Kleinschreibung) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, sollte ihr Ergebnis per <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operator</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) in eine Variable gespeichert werden. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Eine Funktion kann auch aufgerufen werden, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)</pre>
<p>In diesem Fall wird der Rückgabewert der Funktion jedoch verworfen; solange die Funktion nicht noch etwas anderes als ihren Rückgabewert erzeugt, würde der Aufruf folglich keinen Sinn machen.</p>
<p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten Variablennamen in ihrer Parameterliste nicht von Prozentzeichen umschlossen sein. Literale Strings sollten hingegen in Anführungszeichen gesetzt werden. Zum Beispiel:</p>
<pre>If <a href="#InStr">InStr</a>(MeineVar, "fox")
    MsgBox Die Variable MeineVar enthält das Wort fox.</pre>
<p>Letztendlich können Funktionen in den Parametern von jedem Befehl aufgerufen werden (außer EingabeVar und AusgabeVar-Parametern, wie die von <a href="commands/StringLen.htm">StringLen</a>). Allerdings müssen Parameter, die keine <a href="Variables.htm#Expressions">Ausdrücke</a> unterstützen, den "%"-Präfix wie folgt verwenden:</p>
<pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
<p>Das "%"-Präfix ist auch in Parametern zulässig, die bereits Ausdrücke unterstützen, allerdings wird es einfach ignoriert.</p>
<h2><a name="param" id="param"></a>Parameter</h2>
<p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in Klammern aufgelistet (es dürfen sich keine Leerzeichen zwischen den Namen und der öffnenden Klammer befinden). Wenn eine Funktion keine Parameter entgegennehmen soll, musst der Inhalt zwischen den Klammern leer gelassen werden; zum Beispiel: <code>GetCurrentTimestamp()</code>.</p>
<p><a name="ByRef"></a><strong>ByRef-Parameter</strong>: Vom Standpunkt der Funktion aus gesehen, sind Parameter grundsätzlich das gleiche wie <a href="#Locals">lokale Variablen</a>, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Im oberen Beispiel bewirkt <em>ByRef</em>, dass jeder Parameter zum Pseudonym der Variable wird, die vom Aufrufer übergeben wurde. Das heißt, dass sich der Parameter und die Aufrufer-Variable auf den gleichen Inhalt im Arbeitsspeicher beziehen. Dadurch kann die Tauschen-Funktion die Aufrufer-Variable ändern, indem sie den Inhalt von <em>Links</em> in <em>Rechts</em> verschiebt und umgekehrt.</p>
<p>Ohne <em>ByRef</em> würden <em>Links</em> und <em>Rechts</em> nur Kopien von den Aufrufer-Variablen sein, wodurch die Tauschen-Funktion keine externe Auswirkung haben würde.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zurückgeben kann, ist <em>ByRef</em> gut dafür geeignet, zusätzliche Ergebnisse zurückzugeben. Das erreicht man, wenn der Aufrufer dazu gebracht wird, eine Variable zu übergeben (üblicherweise leer), in der die Funktion ein Wert speichern kann.</p>
<p>Bei der Übergabe langer Strings an eine Funktion kann <em>ByRef</em> die Performance erhöhen und Speicherplatz sparen, da keine Kopie des Strings gemacht werden muss. Die Verwendung von <em>ByRef</em> zum Zurückgeben eines langen Strings ist üblicherweise leistungsfähiger als <code>Return LangerString</code>.</p>
<p><span class="ver">[AHK_L 60+]:</span> Falls eine unveränderliche Variable an einen ByRef-Parameter übergeben wird, verhält sich die Funktion so, als wäre das Schlüsselwort "ByRef" nicht vorhanden. Zum Beispiel würde <code>Tauschen(A_Index, i)</code> der Wert von <i>A_Index</i> in <i>i</i> speichern, aber den zugewiesene Wert in <i>Links</i> verwerfen, sobald die <i>Tauschen</i>-Funktion einen Wert zurückgibt.</p>
<p><span class="ver">[v1.1.01+]:</span> Die <a href="#IsByRef">IsByRef()</a>-Funktion kann feststellen, ob der Aufrufer eine Variable für einen ByRef-Parameter übergeben hat.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Objektfelder berücksichtigen nicht Variablen mit <em>ByRef</em>. Übergibt man beispielsweise <code>foo.bar</code> an einen ByRef-Parameter, wird <em>ByRef</em> einfach ignoriert.</li>
  <li>Es ist nicht möglich, die <a href="misc/Clipboard.htm">Zwischenablage</a>, <a href="Variables.htm#BuiltIn">integrierte Variablen</a> oder <a href="Variables.htm#env">Umgebungsvariablen</a> an einen <em>ByRef</em>-Parameter einer Funktion zu übergeben, egal ob <a href="commands/_NoEnv.htm">#NoEnv</a> im Script vorhanden ist oder nicht.</li>
  <li><a name="recurse"></a>Auch wenn eine Funktion sich selbst rekursiv aufrufen könnte, sobald sie eine ihrer eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter mittels <em>ByRef</em> an sich selbst übergibt, verweist der <em>ByRef</em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit selben Namen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter übergibt.</li>
  <li>Wenn bei einem Funktionsaufruf ein Parameter in eine Variable aufgelöst wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), kann sich diese Variable durch links und rechts befindliche Parameter noch ändern, bevor sie an die Funktion übergeben wird. Zum Beispiel würde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 übergeben, wenn <em>Var</em> anfangs 0 ist, selbst wenn der erste Parameter der Funktion kein <em>ByRef</em> ist. Dieses unvorteilhafte Verhalten wird möglicherweise in einer zukünftigen Version geändert.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Beim Definieren einer Funktion können beliebig viele Parameter als optional gekennzeichnet werden. Dazu muss ein Gleichheitszeichen (oder seit v1.1.09 <code>:=</code>) gefolgt von einem Standardwert angefügt werden. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Addieren(X, Y, Z:=0) {
    Return X + Y + Z
}</pre>
<p>Seit v1.1.09 wird sowohl <code>=</code> als auch <code>:=</code> unterstützt. Das Letztere ist aus Gründen der Vereinheitlichung von Ausdruckszuweisungen und Kompatibilität mit zukünftigen Versionen von AutoHotkey empfohlen.</p>
<p>Übergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Falls der Aufrufer allerdings nur <strong>zwei</strong> Parameter übergibt, wird in Z automatisch der Wert 0 gespeichert.</p>
<p id="missing">Es ist nicht möglich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das heißt, dass alle Parameter, die sich rechts vom ersten optionalen Parameter befinden, auch als optional gekennzeichnet werden müssen. <span class="ver">[AHK_L 31+]:</span> Optionale Parameter können beim Funktionsaufruf in der Mitte der Parameterliste weggelassen werden, wie unten gezeigt. Für dynamische Funktionsaufrufe und Methodenaufrufe wird v1.1.12+ benötigt.</p>
<pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p><a name="OptionalByRef"></a>Seit v1.0.46.13 unterstützen <a href="#ByRef">ByRef-Parameter</a> auch Standardwerte; zum Beispiel: <code>Funktion(ByRef p1 = "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter weglässt, erstellt die Funktion eine lokale Variable, die den Standardwert enthält; das heißt, dass die Funktion sich so verhält, als würde das Schlüsselwort "ByRef" fehlen.</p>
<p>Für den Standardwert eines Parameters sind folgende Werte zulässig: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Fließkommazahl oder ein literaler String wie "fox" oder "" (Strings vor v1.0.46.13 unterstützen nur "").</p>
<h2 id="return">Rückgabewerte an den Aufrufer</h2>
<p>Wie oben bereits in der <a href="#intro">Einführung</a> beschrieben, kann eine Funktion wahlweise per <a href="commands/Return.htm">Return</a> einen Wert an ihren Aufrufer zurückgeben.</p>
<pre>
Test := returnTest()
MsgBox % Test

returnTest() {
  return 123
}
</pre>
<p>Wenn noch mehr Ergebnisse von einer Funktion zurückgegeben werden sollen, kann man auch <a href="#ByRef">ByRef</a> verwenden:</p>
<pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
  val1 := "A"
  val2 := 100
  val3 := 1.1
  return
}
</pre>
<p><span class="ver">[v1.0.97+]:</span> Es können <a href="Objects.htm#Usage_Objects">Objekte</a> und <a href="Objects.htm#Usage_Simple_Arrays">Arrays</a> verwendet werden, um mehrere Werte oder sogar benannte Werte zurückzugeben:</p>
<pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen <span class="ver">[AHK_L 60+]</span></h2>
<p>Beim Definieren einer Funktion kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, wodurch sie eine beliebige Anzahl an Parametern akzeptiert:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    Return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Beim Aufrufen einer variadischen Funktion können überschüssige Parameter mithilfe eines Objekts abgerufen werden, das im letzten Parameter der Funktion gespeichert ist. Der erste überschüssige Parameter ist <code><i>params</i>[1]</code>, der Zweite ist <code><i>params</i>[2]</code> und so weiter. Wie bei jedem anderen Standardobjekt auch, kann <code><i>params</i>.MaxIndex()</code> verwendet werden, um den höchsten numerischen Index zu ermitteln (in diesem Fall die Anzahl an Parametern). Sind allerdings keine Parameter vorhanden, gibt MaxIndex einen leeren String zurück.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann sich nur am Ende der formalen Parameterliste befinden.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> können nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> übergeben überschüssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Während variadische Funktionen eine beliebige Anzahl an Parametern <i>akzeptieren</i> können, kann ein Array mit Parametern an <i>jeder</i> Funktion übergeben werden, wenn die gleiche Syntax beim Funktionsaufruf angewendet wird:</p>
<pre>substrings := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">substrings*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Innerhalb des Quell-Arrays beginnt die Nummerierung der Parameter bei 1.</li>
  <li>Optionale Parameter können im Array ganz weggelassen werden.</li>
  <li>Das Array mit Parametern kann benannte Elemente enthalten, wenn eine benutzerdefinierte Funktion aufgerufen wird; in allen anderen Fällen werden benannte Elemente nicht unterstützt.</li>
  <li>Die Zielfunktion kann auch variadisch sein. In diesem Fall werden benannte Elemente auch dann kopiert, wenn sie keinen entsprechenden formalen Parameter haben.</li>
  <li>Diese Syntax kann auch für den Aufruf einer Methode oder für das Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>. Seit v1.1.12 kann sie auch zum Setzen von Eigenschaften verwendet werden.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterstützt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Es dürfen keine Leerraumzeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste vorkommen.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen</h2>
<h3>Lokale Variablen</h3>
<p>Alle Variablen innerhalb einer Funktion sind standardmäßig <em>lokal</em> (außer <a href="#SuperGlobal">superglobale</a> Variablen und integrierte Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Der Inhalt jeder lokalen Variable ist nur für Zeilen sichtbar, die sich innerhalb der Funktion befinden. Daher kann eine lokale Variable den gleichen Namen einer globalen Variable haben, aber mit unterschiedlichem Inhalt. Außerdem sind alle lokalen Variablen bei jedem Funktionsaufruf zu Beginn leer.</p>
<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor man sie verwendet. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    global LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert außerhalb dieser Funktion zugewiesen.</em>
    FileAppend, %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="AssumeGlobal"></a><strong>Modus für die globale Ansicht</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihr Variablen (außer ihre Parameter) als global ansieht. Dazu muss in der ersten Zeile entweder das Wort "global" stehen oder die Deklaration einer lokalen Variable vorkommen. Zum Beispiel:</p>
<pre>StandardwerteSetzen()
{
    global  <em>; Kann weggelassen werden, wenn die ersten Zeile so etwas wie "local MeineVar" ist.</em>
    MeineGlobal := 33  <em>; Speichert 33 in eine globale Variable, die vorher erstellt wird, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen müssen in diesem Modus deklariert werden, weil sie sonst als global angesehen werden.</em>
}</pre>
<p>Dieser Modus für die globale Ansicht kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Array</a> zu erstellen - wie bei einer Schleife, die Werte per <code>Array%A_Index%</code> zuweist.</p>
<p id="SuperGlobal"><strong>Superglobale Variablen</strong> <span class="ver">[v1.1.05+]:</span> Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen. Dadurch wird verhindert, dass die Variablen jedesmal in einer Funktion neu deklariert werden müssen. Hat die Funktion allerdings bereits einen Parameter oder eine lokale Variable mit dem gleichen Namen, wird diese Vorrang vor der globalen Variable haben. Variablen, die mit dem Schlüsselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind immer indirekt lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl = 0
    Zeilenanzahl += 1  <em>; Behandelt einen Zähler lokal (ihr Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend, %Zeilenanzahl%: %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="InitStatic"></a><strong>Statische Initialisierungen</strong>: In den Versionen vor v1.0.46 waren alle statischen Variablen zu Beginn leer; daher war der einzige Weg, die erste Verwendung so einer Variable zu erkennen, zu überprüfen, ob sie leer ist. Seit v1.0.46 können statische Variablen mit einem beliebigen Wert initialisiert werden (vorher war nur <code>""</code> möglich), wenn <code>:=</code> oder <code>=</code> gefolgt von einem folgenden Wert angefügt wird: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Fließkommazahl oder ein literaler String wie <code>"fox"</code>. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Jede statische Variable wird nur einmal initialisiert (bevor das Script ausgeführt wird).</p>
<p><span class="ver">[AHK_L 58+]:</span> <code>Static Var := Ausdruck</code> wird unterstützt. Solche Ausdrücke werden unmittelbar vor dem automatischen Ausführungsbereich ausgewertet - in der Reihenfolge, wie sie im Script vorkommen.</p>
<p><a name="AssumeStatic"></a><strong>Modus für statische Ansicht</strong> <span class="ver">[v1.0.48+]:</span> Eine Funktion kann so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) als statisch ansieht. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
<pre>StatischesArrayAbrufen(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird weiterhin nur einmal ausgeführt (beim Start).</em>
    If ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    Return StatischesArray%Elementnummer%
}</pre>
<p>Im Modus für die statische Ansicht muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Es können mehrere Variablen in einer Zeile deklariert werden, indem sie wie im folgenden Beispiel durch Kommas getrennt werden:</p>
<pre>global LogDateiname, MaxWiederholungen := 5
static GesamtVersuche = 0, VorherErgebnis</pre>
<p><a name="DeclareInit"></a>Seit v1.0.46 kann eine lokale oder globale Variable auf der gleichen Zeile als Deklaration initialisiert werden, wenn ein <code>:=</code> oder <code>=</code> gefolgt von einem <a href="Variables.htm#Expressions">Ausdruck</a> angefügt wird (der Operator <code>=</code> verhält sich in Deklarationen wie <code>:=</code>). Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgeführt, sofern sie von der Ablaufsteuerung erreicht werden. Das heißt, dass eine Zeile wie <code>local x = 0</code> den gleichen Effekt hat wie das Schreiben von zwei getrennten Zeilen: <code>local x</code>, gefolgt von <code>x = 0</code>.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Start des Scripts verarbeitet werden, kann eine Variable nicht per <a href="commands/IfExpression.htm">IF-Anweisung</a> bedingt deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> für alle Zeilen zwischen der Deklaration und der schließenden Funktionsklammer bedingungslos wirksam wird. Beachte zudem, dass es zurzeit nicht möglich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>
<p>Bei Befehlen, die <a href="misc/Arrays.htm">Arrays</a> erstellen (z. B. <a href="commands/StringSplit.htm">StringSplit</a>), ist das resultierende Array lokal, solange der <a href="#AssumeGlobal">Modus für die globale Ansicht</a> nicht aktiv ist oder das erste Array-Element als lokale Variable deklariert wurde (das gilt auch bei der Übergabe eines Funktionsparameters, selbst wenn dieser Parameter ein <a href="#ByRef">ByRef</a> ist, da Parameter mit lokalen Variablen vergleichbar sind). Wurde das erste Element hingegen <a href="#Global">global deklariert</a>, wird ein globales Array erstellt. Allerdings gilt die unten genannte <i>Oft auftretende Verwechslungsgefahr</i> auch in solchen Fällen. Das erste Element bei <a href="commands/StringSplit.htm">StringSplit</a> ist ArrayName0. Bei anderen array-erstellenden Befehlen wie <a href="commands/WinGet.htm">WinGet List</a> ist das erste Element ArrayName (also ohne die Nummer).</p>
<p><a name="DynVar"></a><a name="Dynamic" id="Dynamic"></a>Innerhalb einer Funktion wird jeder dynamische Variablenverweis wie <code>Array%i%</code> immer in eine lokale Variable aufgelöst, sofern eine Variable mit diesem Namen existiert. Ist das nicht der Fall, wird eine globale Variable verwendet, falls vorhanden. Wenn sie weder existiert noch bei ihrer Verwendung die Variable erstellt werden muss, wird sie als eine lokale Variable erstellt, solange der <a href="#AssumeGlobal">Modus für die globale Ansicht</a> nicht aktiv ist. Daher kann eine Funktion ein globales <a href="misc/Arrays.htm">Array</a> nur manuell erstellen (z. B. mithilfe von <code>Array%i% := A_Index</code>), wenn in der Funktion der <a href="#AssumeGlobal">Modus für die globale Ansicht</a> definiert wurde.</p>
<p><strong>Oft auftretende Verwechslungsgefahr</strong>: Jeder <em>nicht</em>-dynamische Verweis auf eine Variable erstellt diese Variable, wenn das Script gestartet wird. Zum Beispiel: Außerhalb einer Funktion würde <code>MsgBox %Array1%</code> die Array1-Variable als globale Variable erstellen, sobald das Script gestartet wird. Innerhalb einer Funktion würde <code>MsgBox %Array1%</code> die Array1-Variable als lokale Variable erstellen, sobald das Script gestartet wird (solange der <a href="#AssumeGlobal">Modus für die globale Ansicht</a> nicht aktiv ist), selbst wenn Array und Array0 als global deklariert sind.</p>
<h2 id="DynCall"><a name="dynamic"></a>Dynamisches Aufrufen einer Funktion</h2>
<p>Seit v1.0.47.06 kann eine Funktion (auch eine <a href="#BuiltIn">integrierte Funktion</a>) mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel würde <code>%Var%(x, "fox")</code> die Funktion aufrufen, deren Name sich in <em>Var</em>befindet. Ebenso würde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abhängig vom aktuellen Wert in A_Index.</p>
<p>Seit v1.1.07.00 kann <em>Var</em> in <code>%Var%()</code> einen Funktionsnamen, ein <a href="objects/Func.htm">Funktionsverweis</a> oder eine <a href="Objects.htm#Objects_as_Functions">Objektnachahmung einer Funktion</a> enthalten. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen.</p>
<p>Kann die Funktion aufgrund einer der unten genannten Gründe nicht aufgerufen werden, stoppt die Auswertung des Ausdrucks mit dem Aufruf unauffällig und frühzeitig, was möglicherweise zu widersprüchlichen Ergebnissen führen kann:</p>
<ul>
  <li>Aufruf einer nicht vorhandenen Funktion, dass mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">integrierte Funktionen</a>) muss direkt im Script vorhanden sein. Zum Beispiel per <a href="commands/_Include.htm">#Include</a> oder nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>.</li>
  <li>Übergabe von zu wenigen Parametern, dass mittels Überprüfung des Rückgabewertes von <a href="#IsFunc">IsFunc()</a> verhindert werden kann (das ist die Anzahl an vorgeschriebenen Parametern plus 1). Hinweis: Seit v1.0.48 wird die Übergabe von zu vielen Parametern toleriert; jeder zusätzliche Parameter wird vollständig ausgewertet (einschließlich aller Funktionsaufrufe) und dann verworfen.</li>
</ul>
<p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor die Ausführung des Scripts beginnt.</p>
<h2 id="ShortCircuit">Logische Kurzschlussauswertung</h2>
<p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, werden sie kurzgeschlossen, um die Performance zu steigern (unabhängig davon, ob Funktionsaufrufe vorhanden sind). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Um das Konzept näher zubringen, schaue dir folgendes Beispiel an:</p>
<pre>If (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
<p>Im oberen Beispiel wird die Funktion FindeFarbe() nie aufgerufen, wenn die <em>FarbeName</em>-Variable leer ist. Das liegt daran, dass die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass Nebeneffekte von einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachte außerdem, dass die Kurzschlussauswertung stufenweise verschachtelte <em>AND</em>s und <em>OR</em>s durchgeht. Im Ausdruck des folgenden Beispiels wird nur der Vergleich ganz links durchgeführt, wenn <em>FarbName</em> leer ist. Die linke Seite würde ausreichen, um das Endergebnis zu bestimmen:</p>
<pre>If (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie aus dem oberen Beispiel ersichtlich wird, sollten aufwendige Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erhöhen. Diese Technik kann auch dazu genutzt werden, einen Funktionsaufruf zu verhindern, wenn ein ungeeigneter Wert an einen Parameter übergeben wird, wie z. B. ein leerer String.</p>
<p>Seit v1.0.46 wird der <a href="Variables.htm#ternary">ternäre Bedingungsoperator (?:)</a> auch kurzgeschlossen, indem die verlierende Abzweigung nicht ausgewertet wird.</p>
<h2 id="gosub">Subroutinen innerhalb einer Funktion verwenden</h2>
<p>Es ist möglich, Subroutinen innerhalb einer Funktion anzugeben; <a href="#define">Definitionen</a> von anderen Funktionen sind nicht möglich. Sie können, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> aufgerufen und per <a href="commands/Return.htm">Return</a> geschlossen werden (in diesem Fall gilt das Return für GoSub und nicht für die Funktion).</p>
<p>Bekannte Einschränkung: Momentan darf der Name jeder Subroutine (Label) nur einmal im ganzen Script vorkommen. Das Programm wird dich beim Start benachrichtigen, wenn Labels doppelt vorhanden sind.</p>
<p><a name="GosubPublic"></a>Verwendet eine Funktion den <a href="commands/Gosub.htm">GoSub</a>-Befehl zum Anspringen einer öffentlichen Subroutine (die sich außerhalb der Funktionsklammern befindet), sind alle äußeren Variablen global und die eigenen <a href="#Locals">lokalen Variablen</a> der Funktion erst zugänglich, wenn die Subroutine durchgeführt wurde. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
<p>Der <a href="commands/Goto.htm">Goto</a>-Befehl kann nicht verwendet werden, um innerhalb einer Funktion von innen nach außen zu springen. Allerdings ist es möglich, dass eine Funktion per <a href="commands/Gosub.htm">GoSub</a> eine externe/öffentliche Subroutine anspringen und von dort aus per Goto weiterspringen kann.</p>
<p>Auch wenn von <a href="commands/Goto.htm">Goto</a> generell abgeraten wird, kann er innerhalb einer Funktion nützlich sein, um in der gleichen Funktion von einer Position zu einer anderen zu springen. Das kann dabei helfen, komplexe Funktionen mit mehreren Rückgabepunkten zu vereinfachen, die einige Säuberungsaktionen machen müssen, bevor sie ausgeführt werden.</p>
<p>Eine Funktion kann extern-aufgerufene Subroutinen wie <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Menüpunkte</a> enthalten. Das wird normalerweise gemacht, um sie für die Verwendung mit <a href="commands/_Include.htm">#Include</a> in eine separate Datei zu hinterlegen, damit sie den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> nicht stören. Allerdings gelten folgende Einschränkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), immer wenn deren Funktionen normal aufgerufen werden. Der Grund ist, dass der <a href="misc/Threads.htm">Thread</a> einer Subroutine, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage wäre, die Werte von lokalen Variablen zu ändern, welche vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zurückkehrt, werden all ihre lokale Variablen leer gemacht, um deren Speicher freizugeben.</li>
  <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) als <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
  <li>Wenn eine Funktion von einem Subroutine-<a href="misc/Threads.htm">Thread</a> angesprungen wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschließlich Befehle, die Arrays erstellen).</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Erreicht der Ausführungsablauf innerhalb einer Funktion die schließende Funktionsklammer, ohne auf ein <a href="commands/Return.htm">Return</a> gestoßen zu sein, endet die Funktion und gibt ihren Aufrufer einen leeren String zurück. Ein leerer Wert wird auch zurückgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> ausdrücklich weggelassen wird.</p>
<p>Beendet eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> per <a href="commands/Exit.htm">Exit</a>-Befehl, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Zum Beispiel würde die Anweisung <code>Var := Addieren(2, 3)</code> <code>Var</code> unverändert lassen, wenn <code>Add()</code> beendet wird. Das Gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausführen</a> einer nicht vorhandenen Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> ändern, um einen zusätzlichen Wert zurückzugeben, der sich leicht merken lässt.</p>
<p>Um eine Funktion mit einem oder mehreren leeren Strings aufzurufen, verwende zwei Anführungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
<p>Da ein Funktionsaufruf keinen neuen <a href="misc/Threads.htm">Thread</a> startet, gelten alle von der Funktion durchgeführten Änderungen an den Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer.</p>
<p>Der Aufrufer kann der Funktion nicht vorhandene Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente übergeben. Das ist besonders nützlich, wenn die Funktion vom entsprechenden Parameter erwartet, ein <a href="#ByRef">ByRef</a> zu sein. Zum Beispiel würde <code>GetNextLine(LeeresArray%i%)</code> die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellen (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">Modus für die globale Ansicht</a> wirksam ist).</p>
<p>Innerhalb einer Funktion zeigt <a href="commands/ListVars.htm">ListVars</a> deren <a href="#Locals">lokalen Variablen</a> mit Inhalt an. Das kann dabei helfen, ein Script zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Komplexe Funktionen können besser lesbar und verwaltbar gemacht werden, wenn deren Variablen eindeutige Präfixe angefügt werden. Durch Hinzufügen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    Return x + y
<strong>}</strong></pre>
<h2 id="include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Scripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
<p>Erklärung: Erreicht der Ausführungsablauf des Scripts eine Funktionsdefinition, wird sie übersprungen (verwendet eine sofortige Methode) und setzt die Ausführung bei der Zeile nach der schließenden Klammer fort. Folglich kann die Ausführung nie in eine Funktion geraten, noch beeinflussen eine oder mehrere Funktionen am Anfang des Scripts den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a>.</p>
<h2><a name="lib" id="lib"></a>Funktionsbibliotheken: Standard- und Benutzerbibliothek <span class="ver">[v1.0.47+]</span></h2>
<p>Ein Script kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> zu verwenden. Damit das funktioniert, muss eine Datei mit gleichem Namen in einem der folgenden Bibliotheksverzeichnissen vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Lokale Bibliothek - benötigt AHK_L 42+.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; Benutzerbibliothek.</em>
Pfad-der-laufenden-AutoHotkey.exe\Lib\  <em>; Standardbibliothek.</em></pre>
<p>Ruft ein Script beispielsweise eine nicht vorhandene Funktion <code>MeineFunktion()</code> auf, sucht das Programm nach einer Datei namens "MeineFunktion.ahk" in der Benutzerbibliothek. Ergibt die Suche keine Treffer, wird die Standardbibliothek durchsucht. Falls sie immer noch nicht gefunden wird und der Funktionsname ein Unterstrich enthält (z. B. <code>MeinPräfix_MeineFunktion</code>), durchsucht das Programm beide Bibliotheken nach einer Datei namens <code>MeinPräfix.ahk</code> und lädt sie, falls sie existiert. Dadurch kann <code>MeinPräfix.ahk</code> sowohl die Funktion <code>MeinPräfix_MeineFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>MeinPräfix_</code> beginnen.</p>
<p><span class="ver">[AHK_L 42+]:</span> Die lokale Bibliothek wird unterstützt, welche ab sofort als erste Bibliothek durchsucht wird.</p>
<p>In der Regel kann eine Bibliotheksdatei nur eine Funktion enthalten, die den Namen der Datei hat. Allerdings kann sie auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum vorhanden sind; das heißt, dass sie von überall im Script aufgerufen werden können.</p>
<p>Verwendet eine Bibliotheksdatei <a href="commands/_Include.htm">#Include</a>, ist das Arbeitsverzeichnis für #Include das Verzeichnis der Bibliotheksdatei. Dadurch ist es möglich, eine Umleitung zu einer größeren Bibliotheksdatei zu erstellen, die diese Funktion und Ähnliches enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Script-Compiler (ahk2exe)</a> unterstützt auch Bibliotheksfunktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Sollte AutoHotkey.exe fehlen, wird der Compiler weiterhin funktionieren, jedoch werden die Bibliotheksfunktionen nicht mehr automatisch eingefügt.</p>
<p>Funktionen, die von einer Bibliothek eingefügt worden sind, funktionieren genauso gut wie andere Funktionen, da sie geladen werden, bevor das Script ausgeführt wird.</p>
<h2 id="BuiltIn">Integrierte Funktionen</h2>
<p>Jeder optionale Parameter, der am Ende der Parameterliste einer integrierten Funktion vorkommt, kann vollständig weggelassen werden. Zum Beispiel ist <code>WinExist("Unbenannt - Editor")</code> gültig, weil die anderen drei Parameter als leer angesehen werden.</p>
<p>Eine integrierte Funktion kann überschrieben werden, indem man eine eigene Funktion mit dem gleichen Namen definiert. Zum Beispiel könnte man anstelle der normalen WinExist()-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können per <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
<h3>Häufig verwendete Funktionen</h3>
<p><strong><a name="FileExist"></a>FileExist(Dateimuster)</strong>: Gibt einen leeren String zurück, wenn <em>Dateimuster</em> nicht existiert (<em>Dateimuster</em> befindet sich im <a href="Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist). Ansonsten wird ein <a href="commands/FileGetAttrib.htm#attrib">String mit Attributen</a> (eine Teilmenge von "RASHNDOCT") von der ersten gefundenen Datei oder des ersten gefundenen Ordners zurückgegeben. Hat die Datei keine Attribute (was sehr selten ist), wird "X" zurückgegeben. <em>Dateimuster</em> kann der exakte Name einer Datei oder eines Ordners sein, oder Platzhalter (* oder ?) enthalten. Da ein leerer String als "falsch" angesehen wird, kann der Rückgabewert der Funktion immer als logischer Scheinwert verwendet werden. Zum Beispiel würde die Anweisung <code>If FileExist("C:\Meine Datei.txt")</code> als wahr angesehen werden, wenn die Datei vorhanden ist. Ebenso würde die Anweisung <code>If InStr(FileExist("C:\Meine Ordner"), "D")</code> nur als wahr angesehen werden, wenn die Datei existiert <em>und</em> ein Verzeichnis ist. Dazugehörige Befehle: <a href="commands/IfExist.htm">IfExist</a> und <a href="commands/FileGetAttrib.htm">FileGetAttrib</a>.</p>
<p><strong><a name="GetKeyState"></a>GetKeyState(<a href="KeyList.htm">Tastenname</a> [, "P"</strong> oder <strong>"T"])</strong>: Im Gegensatz zum <a href="commands/GetKeyState.htm">GetKeyState-Befehl</a> (der D für unten und U für oben zurückgibt) wird diese Funktion wahr (1) zurückgeben, wenn die Taste unten ist, und falsch (0), wenn sie oben ist. Ist der <em><a href="KeyList.htm">Tastenname</a></em> ungültig, wird ein leerer String zurückgegeben. Siehe <a href="commands/GetKeyState.htm">GetKeyState</a> für weitere Rückgabewerte und zusätzliche Informationen zur Verwendung.</p>
<p><strong><a name="InStr"></a>InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</strong>: Gibt die Position des Strings <em>Nadel</em> zurück, der im String <em>Heuhaufen</em> vorkommt. Im Gegensatz zu <a href="commands/StringGetPos.htm">StringGetPos</a> beginnt hier das erste Zeichen bei Position 1; das liegt daran, dass 0 das Synonym für "falsch" ist, was sich gut als "nicht gefunden" eignet. Ist der <em>Zeichengenauigkeit</em>-Parameter nicht vorhanden oder "falsch", unterscheidet die Suche nicht zwischen Groß- und Kleinschreibung (die Unterscheidung hängt von <a href="commands/StringCaseSense.htm">StringCaseSense</a> ab); ansonsten muss die Groß- und Kleinschreibung exakt übereinstimmen. Ist <em>Startposition</em> nicht vorhanden, gilt standardmäßig 1 (der Anfang von <em>Heuhaufen</em>). Ansonsten kann man eine 2 angeben, um die Suche im <em>Heuhaufen</em> beim zweiten Zeichen zu beginnen, eine 3, um beim dritten Zeichen zu beginnen, und so weiter. Überschreitet <em>Startposition</em> die Länge von <em>Heuhaufen</em>, wird eine 0 zurückgegeben. Wenn <em>Startposition</em> eine 0 oder negativ ist, erfolgt die Suche in umgekehrter Reihenfolge (von rechts nach links), beginnend beim Offset am Ende. Ungeachtet des Wertes in <em>Startposition</em> bezieht sich der Rückgabewert immer auf das erste Zeichen von <em>Heuhaufen</em>. Zum Beispiel wäre die Position von "abc" in "123abc789" immer 4. Schreibe eine 2 in <i>Vorkommen</i>, um die Position der zweiten Übereinstimmung zurückzugeben, eine 3 für die dritte Übereinstimmung und so weiter. Verwandte Elemente: <a href="commands/RegExMatch.htm">RegExMatch()</a>, <a href="commands/IfInString.htm">IfInString</a> und <a href="commands/StringGetPos.htm">StringGetPos</a>.</p>
<p><strong>RegExMatch(Heuhaufen, NadelRegEx [, AusgabeVar = "", Startposition = 1])</strong>: Überprüft, ob ein Muster (regulärer Ausdruck) im String vorkommt. Siehe <a href="commands/RegExMatch.htm">RegExMatch()</a> für Details.</p>
<p><strong>RegExReplace(Heuhaufen, NadelRegEx [, Ersatz = "", AusgabeVarAnzahl = "", Limit = -1, Startposition = 1])</strong>: Ersetzt Vorkommen eines Musters (regulärer Ausdruck) innerhalb eines Strings. Siehe <a href="commands/RegExReplace.htm">RegExReplace()</a> für Details.</p>
<p><strong><a name="SubStr"></a>SubStr(String, Startposition [, Länge])</strong> <span class="ver">[v1.0.46+]:</span> Kopiert einen Teilstring vom <em>String</em>, beginnend bei <em>Startposition</em> von links nach rechts, bis die angegebene <em>Länge</em> erreicht wurde (falls <em>Länge</em> nicht vorhanden ist, gilt standardmäßig "alle Zeichen"). Für <em>Startposition</em> kann eine 1 angegeben werden, um beim ersten Zeichen zu beginnen, eine 2, um beim zweiten Zeichen zu beginnen, und so weiter (überschreitet <em>Startposition</em> die Länge von <em>String</em>, wird ein leerer String zurückgegeben). Ist <em>Startposition</em> kleiner als 1, wird es als Offset vom Ende des Strings angesehen. Zum Beispiel würde eine 0 das letzte Zeichen und -1 die letzten zwei Zeichen extrahieren (überschreitet <em>Startposition</em> aber das linke Ende des Strings, beginnt das Extrahieren beim ersten Zeichen). <em>Länge</em> ist die maximale Anzahl an Zeichen, die extrahiert werden sollen (es werden weniger Zeichen abgerufen, falls der verbleibende Teil des Strings zu kurz ist). Verwende eine negative <em>Länge</em>, um die Anzahl an Zeichen zu bestimmen, die vom Ende des zurückgegebenen Strings weggelassen werden sollen (es wird ein leerer String zurückgegeben, wenn alle oder zu viele Zeichen weggelassen worden sind). Verwandte Elemente: <a href="commands/RegExMatch.htm">RegExMatch()</a>, <a href="commands/StringMid.htm">StringMid</a>, <a href="commands/StringLeft.htm">StringLeft/Right</a>, <a href="commands/StringTrimLeft.htm">StringTrimLeft/Right</a>.</p>
<p><strong><a name="StrLen"></a>StrLen(String)</strong>: Gibt die Länge von <em>String</em> zurück. Siehe <a href="commands/StringLen.htm">StrLen()</a> für Details.</p>
<p><strong><a name="StrSplit"></a>StrSplit(String [, Trennzeichen, ZeichenAuslassen])</strong> <span class="ver">[v1.1.13+]:</span> Teilt einen String in mehrere Teilstrings auf, basierend auf die angegebenen Trennzeichen. Siehe <a href="commands/StringSplit.htm">StrSplit()</a> für Details.</p>
<p><strong><a name="WinActive"></a>WinActive([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des aktiven Fensters zurück, wenn die Übereinstimmung die angegebenen Kriterien erfüllt. Siehe <a href="commands/WinActive.htm">WinActive()</a> für Details.</p>
<p><strong><a name="WinExist"></a>WinExist([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des ersten übereinstimmenden Fensters zurück. Siehe <a href="commands/WinExist.htm">WinExist()</a> für Details.</p>
<h3>Verschiedene Funktionen</h3>
<p><strong><a name="Asc"></a>Asc(String)</strong>: Gibt den Zeichencode (bei ANSI-Builds eine Zahl zwischen 1 und 255, und bei Unicode-Builds eine Zahl zwischen 1 und 65535) für das erste Zeichen im <em>String</em> zurück. Ist <em>String</em> leer, wird 0 zurückgegeben.</p>
<p><strong><a name="Chr"></a>Chr(Zahl)</strong>: Gibt ein einzelnes Zeichen zurück, das zum angegebenen Zeichencode (<em>Zahl</em>) gehört. Liegt <em>Zahl</em> außerhalb des gültigen Bereichs der Zeichencodes, wird ein leerer String zurückgegeben. Häufig verwendete Zeichencodes sind 9 (Tabulator), 10 (LF), 13 (CR), 32 (Leerzeichen), 48-57 (die Zahlen von 0 bis 9), 65-90 (Großbuchstaben von A bis Z) und 97-122 (Kleinbuchstaben von a bis z).</p>
<p><strong>DllCall()</strong>: Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows. Siehe <a href="commands/DllCall.htm">DllCall()</a> für Details.</p>
<p><strong>FileOpen()</strong>: Ermöglicht eine objektorientierte Dateibearbeitung. Siehe <a href="commands/FileOpen.htm">FileOpen()</a> für Details.</p>
<p><strong><a name="Func"></a>Func(Funktionsname)</strong> <span class="ver">[v1.1.00+]:</span> Falls <em>Funktionsname</em> nicht direkt im Script vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>), wird Func() eine 0 zurückgeben. Ansonsten wird der <a href="Objects.htm#Function_References">Verweis auf die Funktion</a> zurückgegeben. Das kann man verwenden, um die Funktion aufzurufen oder <a href="objects/Func.htm">Informationen</a> abzurufen, wie beispielsweise die minimale und maximale Anzahl an Parametern.</p>
<p><strong><a name="GetKeyName"></a>GetKeyName(Taste), GetKeyVK(Taste), GetKeySC(Taste)</strong> <span class="ver">[v1.1.01+]:</span> Ermittelt den Namen/Text, virtuellen Tastencode oder Scancode einer Taste. <em>Taste</em> kann ein VK oder SC-Code, wie z. B. "vkA2" oder "sc01D", eine Kombination von beiden oder ein Tastenname sein. Zum Beispiel wird sowohl <code>GetKeyName("vk1B")</code> als auch <code>GetKeyName("Esc")</code> "Escape" zurückgeben, während <code>GetKeyVK("Esc")</code> eine 27 zurückgibt.</p>
<p><strong><a name="IsByRef"></a>IsByRef(Var)</strong> <span class="ver">[v1.1.01+]:</span> Gibt eine 1 zurück, falls <em>Var</em> ein ByRef-Parameter ist und der Aufrufer eine Variable übergibt; oder 0, falls <em>Var</em> ein anderer Variablentyp ist.</p>
<p><strong><a name="IsFunc"></a>IsFunc(Funktionsname)</strong> <span class="ver">[v1.0.48+]:</span> Falls <em>Funktionsname</em> nicht direkt im Script vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>), wird IsFunc() eine 0 zurückgeben. Ansonsten gibt sie die minimale Anzahl an Parametern zurück, addiert mit 1 (also 1 für eine Funktion ohne Parameter, 2 für eine Funktion mit einem Parameter und so weiter). Zum Beispiel würden die Anweisungen <code>If IsFunc("MeineFunktion")</code> und <code>If IsFunc(VariableMitFunktionsnamen)</code> als wahr angesehen werden, wenn die Funktion vorhanden ist. Seit v1.1.00 kann <i>Funktionsname</i> anstelle eines Namens auch ein Funktionsverweis sein. Siehe auch: <a href="#DynCall">Dynamischer Funktionsaufruf</a>, <a href="Variables.htm#ThisFunc">A_ThisFunc</a></p>
<p><strong><a name="IsLabel"></a>IsLabel(LabelName)</strong>: Gibt eine Zahl ungleich 0 zurück, wenn <em>Labelname</em> als <a href="commands/Gosub.htm">Subroutine</a>, <a href="Hotkeys.htm">Hotkey</a> oder <a href="Hotstrings.htm">Hotstring</a> im Script vorkommt (<em>Labelname</em> muss ohne den Doppelpunkten angegeben werden). Zum Beispiel würde die Anweisung <code>If IsLabel(VariableMitLabelnamen)</code> als wahr angesehen werden, wenn das Label vorhanden ist. Das ist nützlich, um Laufzeitfehler zu unterdrücken, wenn man ein dynamisches Label in Befehlen wie <a href="commands/Gosub.htm">Gosub</a>, <a href="commands/Hotkey.htm">Hotkey</a>, <a href="commands/Menu.htm">Menu</a> und <a href="commands/Gui.htm">Gui</a> angibt. Siehe auch: <a href="misc/Labels.htm">Label</a>.</p>
<p><strong><a name="IsObject"></a>IsObject()</strong> <span class="ver">[AHK_L 31+]:</span> Erkennt, ob ein Wert ein Objekt ist. Siehe auch: <a href="Objects.htm">Objekte</a>.</p>
<p><strong>ListView- und TreeView-Funktionen</strong>: Siehe <a href="commands/ListView.htm">ListView</a> und <a href="commands/TreeView.htm">TreeView</a> für Details.</p>
<p><strong><a name="NumGet"></a>NumGet(VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: Gibt die binäre Nummer zurück, die sich auf der Adresse + Offset befindet. Siehe <a href="commands/NumGet.htm">NumGet</a>, um mehr darüber zu erfahren.</p>
<p><strong><a name="NumPut"></a>NumPut(Nummer, VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: Speichert eine Nummer im Binärformat auf die angegebene Adresse + Offset. Siehe <a href="commands/NumPut.htm">NumPut</a>, um mehr darüber zu erfahren.</p>
<p><strong>OnMessage(Nachrichtennummer [, "Funktionsname"])</strong>: Überwacht eine Nachricht/ein Ereignis. Siehe <a href="commands/OnMessage.htm">OnMessage()</a> für weitere Details.</p>
<p><strong>StrGet(Adresse [, Länge] [, Kodierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert einen String von einer Speicheradresse und wandelt ihn optional in verschiedene Zeichensätze um. Siehe <a href="commands/StrPutGet.htm">StrGet()</a> für weitere Details.</p>
<p><strong>StrPut(String, Adresse [, Länge] [, Kodierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert einen String auf einer Speicheradresse und wandelt ihn optional in verschiedene Zeichensätze um. Siehe <a href="commands/StrPutGet.htm">StrPut()</a> für weitere Details.</p>
<p><strong>RegisterCallback()</strong>: Erstellt eine Maschinencode-Adresse, die beim Aufrufen den Aufruf zu einer Funktion im Script umleitet. Siehe <a href="commands/RegisterCallback.htm">RegisterCallback()</a> für Details.</p>
<p><strong>Trim()</strong> <span class="ver">[AHK_L 31+]:</span> Entfernt bestimmte Zeichen vom Anfang und/oder Ende eines Strings. Siehe <a href="commands/Trim.htm">Trim()</a> für Details.</p>
<p><strong>VarSetCapacity(VarName [, BenötigteKapazität, Füllbyte])</strong>: Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei. Siehe <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> für Details.</p>
<h3 id="Math">Allgemeine Mathematik</h3>
<p>Hinweis: Mathematische Funktionen geben generell einen leeren Wert (String) zurück, falls einer der eingehenden Parameter nicht numerisch ist.</p>
<p><strong><a name="Abs"></a>Abs(Zahl)</strong>: Gibt den absoluten Wert von <em>Zahl</em> zurück. Der Rückgabewert hat den gleichen Typ wie <em>Zahl</em> (Integer oder Fließkommazahl).</p>
<p><strong><a name="Ceil"></a>Ceil(Zahl)</strong>: Gibt <em>Zahl</em> zurück, aufgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Ceil(1.2)</code> gleich 2 und <code>Ceil(-1.2)</code> gleich -1.</p>
<p><strong><a name="Exp"></a>Exp(N)</strong>: Gibt <em>e</em> zurück (ungefähr 2.71828182845905), potenziert mit <em>N</em>. Der Parameter <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Um neben <em>e</em> noch andere Zahlen zu potenzieren, verwende den <a href="Variables.htm#pow">**-Operator</a>.</p>
<p><strong><a name="Floor"></a>Floor(Zahl)</strong>: Gibt <em>Zahl</em> zurück, abgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Floor(1.2)</code> gleich 1 und <code>Floor(-1.2)</code> gleich -2.</p>
<p><strong><a name="Log"></a>Log(Zahl)</strong>: Gibt den Logarithmus (Basis 10) von <em>Zahl</em> zurück. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Fließkommazahl</a>. Wenn <em>Zahl</em> negativ ist, wird ein leerer String zurückgegeben.</p>
<p><strong><a name="Ln"></a>Ln(Zahl)</strong>: Ermittelt den Logarithmus (Basis e) von <em>Zahl</em>. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Fließkommazahl</a>. Wenn <em>Zahl</em> negativ ist, wird ein leerer String zurückgegeben.</p>
<p><strong><a name="Mod"></a>Mod(Dividend, Divisor)</strong>: Modulo. Gibt den Rest zurück, wenn der <em>Dividend</em> durch den <em>Divisor</em> geteilt wird. Das Vorzeichen des Ergebnisses entspricht dem Vorzeichen des ersten Parameters. Zum Beispiel sind <code>Mod(5, 3)</code> und <code>Mod(5, -3)</code> gleich 2, aber <code>Mod(-5, 3)</code> und <code>Mod(-5, -3)</code> gleich -2. Wenn einer der beiden Parameter eine Fließkommazahl ist, wird das Ergebnis ebenfalls eine Fließkommazahl sein. Zum Beispiel ist <code>Mod(5.0, 3)</code> gleich 2.0 und <code>Mod(5, 3.5)</code> gleich 1.5. Ist der zweite Parameter eine 0, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="Round"></a>Round(Zahl [, N])</strong>: Ist <em>N</em> nicht vorhanden oder eine 0, wird <em>Zahl</em> auf den nächsten Integer gerundet. Ist <em>N</em> eine positive Zahl, wird <em>Zahl</em> auf <em>N</em> Dezimalstellen gerundet. Ist <em>N</em> negativ, wird <em>Zahl</em> auf <em>N</em> Stellen nach links gerundet. Zum Beispiel ist <code>Round(345, -1)</code> gleich 350 und <code>Round(345, -2)</code> gleich 300. Im Gegensatz zu <a href="commands/Transform.htm">Transform Round</a> hat das Ergebnis keinen .000-Suffix, wenn <em>N</em> weggelassen wird oder kleiner als 1 ist. Seit v1.0.44.01 zeigt ein Wert in <em>N</em>, der größer als 0 ist, genau <em>N</em> Dezimalstellen an, anstatt <a href="commands/SetFormat.htm">SetFormat</a> zu berücksichtigen. Man kann das verhindern, wenn man eine weitere mathematische Operation beim Rückgabewert von Round() durchführt; zum Beispiel: <code>Round(3.333, 1)<strong>+0</strong></code>.</p>
<p><strong><a name="Sqrt"></a>Sqrt(Zahl)</strong>: Gibt die Quadratwurzel von <em>Zahl</em> zurück. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Fließkommazahl</a>. Wenn <em>Zahl</em> negativ ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<h3>Trigonometrie</h3>
<p><strong><a name="Sin"></a><a name="Cos"></a><a name="Tan"></a>Sin(Zahl)</strong> | <strong>Cos(Zahl)</strong> | <strong>Tan(Zahl)</strong>: Gibt den trigonometrischen Sinus|Kosinus|Tangens von <em>Zahl</em> zurück. <em>Zahl</em> muss als Bogenmaß angegeben werden.</p>
<p><strong><a name="ASin"></a>ASin(Zahl)</strong>: Gibt den Arkussinus (die Zahl, deren Sinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="ACos"></a>ACos(Zahl)</strong>: Gibt den Arkuskosinus (die Zahl, deren Kosinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="ATan"></a>ATan(Zahl)</strong>: Gibt den Arkustangens (die Zahl, deren Tangens <em>Zahl</em> ist) als Bogenmaß zurück.</p>
<p><strong>Hinweis</strong>: Soll Bogenmaß in Grad umgewandelt werden, multipliziere es mit 180/pi (ungefähr 57.29578). Um ein Grad-Wert in Bogenmaß umzuwandeln, kann es mit pi/180 (ungefähr 0.01745329252) multipliziert werden. Der Wert von pi (ungefähr 3.141592653589793) ist viermal der Arkustangens von 1.</p>
<h3>Sonstige Funktionen</h3>
<p><a href="http://www.autohotkey.net/~polyethene/#functions">Befehlsfunktionen von Polyethene</a>: Bietet für jeden AutoHotkey-Befehl, der eine Ausgabevariable hat, eine aufrufbare Funktion. Diese Bibliothek kann per <a href="commands/_Include.htm">#Include</a> in jedem Script eingefügt werden.</p>
</body>
</html>
