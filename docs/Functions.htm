<!DOCTYPE HTML>
<html>
<head>
<title>Funktionen</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<link href="static/font.css" rel="stylesheet" type="text/css" />
<script src="static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="static/html5.js"></script>
<![endif]-->
<script src="navbar/NavScript.js" type="text/javascript"></script>
</head>

<body>
<script type="text/javascript">WriteHeader(0);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Funktionen</h1>
      <h2>Inhaltsverzeichnis</h2>
      <ul>
        <li><a href="#intro">Einf&uuml;hrung und einfache Beispiele</a></li>
        <li><a href="#param">Parameter</a></li>
        <li><a href="#optional">Optionale Parameter</a></li>
        <li><a href="#return">R&uuml;ckgabewerte an den Aufrufer</a></li>
        <li><a href="#Variadic">Variadische Funktionen</a></li>
        <li><a href="#Locals">Lokale Variablen</a></li>
        <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion </a></li>
        <li><a href="#ShortCircuit">Boolesche Kurzschlussauswertung</a></li>
        <li><a href="#gosub">Subroutinen innerhalb einer Funktion verwenden</a></li>
        <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
        <li><a href="#include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</a></li>
        <li><a href="#lib">Funktionsbibliotheken: Standard- und Benutzerbibliothek</a></li>
        <li><a href="#BuiltIn">Interne Funktionen</a></li>
      </ul>
      <h2 id="intro">Einf&uuml;hrung und einfache Beispiele</h2>
      <p id="define">Eine Funktion ist mit einer Subroutine (<a href="commands/Gosub.htm">GoSub</a>) vergleichbar, die zus&auml;tzlich noch Parameter (Eingaben) von ihrem Aufrufer entgegennehmen kann. Bei Bedarf kann eine Funktion dem Aufrufer einen Wert zur&uuml;ckgeben. Betrachte die folgende einfache Funktion, die zwei Zahlen akzeptiert und deren Summe zur&uuml;ckgibt:</p>
      <pre>Addieren(x, y)
{
    Return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
      <p>Das obere Beispiel nennt sich <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (unabh&auml;ngig von Gro&szlig;- und Kleinschreibung) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, sollte ihr Ergebnis per <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operator (<strong>:=</strong>)</a> in eine Variable gespeichert werden. Zum Beispiel:</p>
      <pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
      <p>Eine Funktion kann auch aufgerufen werden, ohne ihren R&uuml;ckgabewert speichern zu m&uuml;ssen:</p>
      <pre>Addieren(2, 3)</pre>
      <p>In diesem Fall wird der R&uuml;ckgabewert der Funktion jedoch verworfen; solange die Funktion nicht noch etwas anderes als ihren R&uuml;ckgabewert erzeugt, w&uuml;rde der Aufruf folglich keinen Sinn machen.</p>
      <p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten Variablennamen in ihrer Parameterliste nicht von Prozentzeichen umschlossen sein. Literale Strings sollten hingegen in Anf&uuml;hrungszeichen gesetzt werden. Zum Beispiel:</p>
      <pre>If <a href="#InStr">InStr</a>(EigeneVar, "fox")
    MsgBox Die Variable EigeneVar enth&auml;lt das Wort fox.</pre>
      <p>Letztendlich k&ouml;nnen Funktionen in den Parametern von jedem Befehl aufgerufen werden (au&szlig;er EingabeVar und AusgabeVar-Parametern, wie die von <a href="commands/StringLen.htm">StringLen</a>). Allerdings m&uuml;ssen Parameter, die keine <a href="Variables.htm#Expressions">Ausdr&uuml;cke</a> unterst&uuml;tzen, den "%"-Pr&auml;fix wie folgt verwenden:</p>
      <pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
      <p>Das "%"-Pr&auml;fix ist auch in Parametern zul&auml;ssig, die bereits Ausdr&uuml;cke unterst&uuml;tzen, allerdings wird es einfach ignoriert.</p>
      <h2 id="param">Parameter</h2>
      <p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in Klammern aufgelistet (es d&uuml;rfen sich keine Leerzeichen zwischen den Namen und der &ouml;ffnenden Klammer befinden). Soll eine Funktion keine Parameter entgegennehmen, musst du den Inhalt zwischen den Klammern leer lassen; zum Beispiel: <code>GetCurrentTimestamp()</code>.</p>
      <p id="ByRef"><strong>ByRef-Parameter</strong>: Vom Standpunkt der Funktion aus gesehen, sind Parameter grunds&auml;tzlich das gleiche wie <a href="#Locals">lokale Variablen</a>, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
      <pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
      <p>Im oberen Beispiel bewirkt <em>ByRef</em>, dass jeder Parameter zum Pseudonym der Variable wird, die vom Aufrufer &uuml;bergeben wurde. Das hei&szlig;t, dass sich der Parameter und die Aufrufer-Variable auf den gleichen Inhalt im Arbeitsspeicher beziehen. Dadurch kann die Tauschen-Funktion die Aufrufer-Variable &auml;ndern, indem sie den Inhalt von <em>Links</em> in <em>Rechts</em> verschiebt und umgekehrt.</p>
      <p>Ohne <em>ByRef</em> w&uuml;rden <em>Links</em> und <em>Rechts</em> nur Kopien von den Aufrufer-Variablen sein, wodurch die Tauschen-Funktion keine externe Auswirkung haben w&uuml;rde.</p>
      <p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zur&uuml;ckgeben kann, ist <em>ByRef</em> gut daf&uuml;r geeignet, zus&auml;tzliche Ergebnisse zur&uuml;ckzugeben. Das erreichst du, indem du den Aufrufer dazu bringst, eine Variable zu &uuml;bergeben (&uuml;blicherweise leer), in der die Funktion ein Wert speichern kann.</p>
      <p>Bei der &Uuml;bergabe langer Strings an eine Funktion kann <em>ByRef</em> die Performance erh&ouml;hen und Speicherplatz sparen, da keine Kopie des Strings gemacht werden muss. Die Verwendung von <em>ByRef</em> zum Zur&uuml;ckgeben eines langen Strings hat &uuml;blicherweise eine h&ouml;here Performance als <code>Return LangerString</code>.</p>
      <p><span class="ver">[AHK_L 60+]:</span> Falls eine unver&auml;nderliche Variable an einen ByRef-Parameter &uuml;bergeben wird, verh&auml;lt sich die Funktion so, als w&auml;re das Schl&uuml;sselwort "ByRef" nicht vorhanden. Zum Beispiel w&uuml;rde <code>Tauschen(A_Index, i)</code> der Wert von <i>A_Index</i> in <i>i</i> speichern, aber den zugewiesene Wert in <i>Links</i> verwerfen, sobald die <i>Tauschen</i>-Funktion einen Wert zur&uuml;ckgibt.</p>
      <p><span class="ver">[v1.1.01+]:</span> Die <a href="#IsByRef">IsByRef()</a>-Funktion kann feststellen, ob der Aufrufer eine Variable f&uuml;r einen ByRef-Parameter &uuml;bergeben hat.</p>
      <p>Bekannte Einschr&auml;nkungen:</p>
      <ul>
        <li>Objektfelder ber&uuml;cksichtigen nicht Variablen mit <em>ByRef</em>. &Uuml;bergibt man beispielsweise <code>foo.bar</code> an einen ByRef-Parameter, wird <em>ByRef</em> einfach ignoriert.</li>
        <li>Es ist nicht m&ouml;glich, die <a href="misc/Clipboard.htm">Zwischenablage</a>, <a href="Variables.htm#BuiltIn">interne Variablen</a> oder <a href="Variables.htm#env">Umgebungsvariablen</a> an einen <em>ByRef</em>-Parameter einer Funktion zu &uuml;bergeben, egal ob <a href="commands/_NoEnv.htm">#NoEnv</a> im Script vorhanden ist oder nicht.</li>
        <li id="recurse">Auch wenn eine Funktion sich selbst rekursiv aufrufen k&ouml;nnte, sobald sie eine ihrer eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter mittels <em>ByRef</em> an sich selbst &uuml;bergibt, verweist der <em>ByRef</em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit selben Namen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter &uuml;bergibt.</li>
        <li>Wenn bei einem Funktionsaufruf ein Parameter in eine Variable aufgel&ouml;st wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), kann sich diese Variable durch links und rechts befindliche Parameter noch &auml;ndern, bevor sie an die Funktion &uuml;bergeben wird. Zum Beispiel w&uuml;rde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 &uuml;bergeben, wenn <em>Var</em> anfangs 0 ist, selbst wenn der erste Parameter der Funktion kein <em>ByRef</em> ist. Dieses unvorteilhafte Verhalten wird m&ouml;glicherweise in einer zuk&uuml;nftigen Version ge&auml;ndert.</li>
      </ul>
      <h2 id="optional">Optionale Parameter</h2>
      <p>Beim Definieren einer Funktion k&ouml;nnen beliebig viele Parameter als optional gekennzeichnet werden. Dazu muss ein Gleichheitszeichen (oder seit v1.1.09 <code>:=</code>) gefolgt von einem Standardwert angef&uuml;gt werden. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
      <pre>Addieren(X, Y, Z:=0) {
    Return X + Y + Z
}</pre>
      <p>Seit v1.1.09 wird sowohl <code>=</code> als auch <code>:=</code> unterst&uuml;tzt. Das Letztere ist aus Gr&uuml;nden der Vereinheitlichung von Ausdruckszuweisungen und Kompatibilit&auml;t mit zuk&uuml;nftigen Versionen von AutoHotkey empfohlen.</p>
      <p>&Uuml;bergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Falls der Aufrufer allerdings nur <strong>zwei</strong> Parameter &uuml;bergibt, erh&auml;lt Z automatisch den Wert 0.</p>
      <p id="missing">Es ist nicht m&ouml;glich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das hei&szlig;t, dass alle Parameter, die sich rechts vom ersten optionalen Parameter befinden, auch als optional gekennzeichnet werden m&uuml;ssen. <span class="ver">[AHK_L 31+]:</span> Optionale Parameter k&ouml;nnen beim Funktionsaufruf in der Mitte der Parameterliste weggelassen werden, wie unten gezeigt. F&uuml;r dynamische Funktionsaufrufe und Methodenaufrufe wird v1.1.12+ ben&ouml;tigt. </p>
      <pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
      <p id="OptionalByRef">Seit v1.0.46.13 unterst&uuml;tzen <a href="#ByRef">ByRef-Parameter</a> auch Standardwerte; zum Beispiel: <code>Funktion(ByRef p1 = "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter wegl&auml;sst, erstellt die Funktion eine lokale Variable, die den Standardwert enth&auml;lt; das hei&szlig;t, dass die Funktion sich so verh&auml;lt, als w&uuml;rde das Schl&uuml;sselwort "ByRef" fehlen.</p>
      <p>F&uuml;r den Standardwert eines Parameters sind folgende Werte zul&auml;ssig: <code>True</code>, <code>False</code>, ein direkter Integer, eine direkte Flie&szlig;kommazahl oder ein direkter String wie "fox" oder "" (Strings vor v1.0.46.13 unterst&uuml;tzen nur "").</p>
      <h2 id="return">R&uuml;ckgabewerte an den Aufrufer</h2>
      <p>Wie oben bereits in der <a href="#intro">Einf&uuml;hrung</a> beschrieben, kann eine Funktion wahlweise einen Wert an ihren Aufrufer <a href="commands/Return.htm">zur&uuml;ckgeben</a>.</p>
      <pre>
Test := returnTest()
MsgBox % Test

returnTest() {
  return 123
}</pre>
      <p>M&ouml;chtest du weitere Ergebnisse von einer Funktion zur&uuml;ckgeben, kannst du auch <a href="#ByRef">ByRef</a> verwenden:</p>
      <pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
  val1 := "A"
  val2 := 100
  val3 := 1.1
  return
}</pre>
      <p><span class="ver">[v1.0.97+]:</span> Es k&ouml;nnen <a href="Objects.htm#Usage_Objects">Objekte</a> und <a href="Objects.htm#Usage_Simple_Arrays">Arrays</a> verwendet werden, um mehrere Werte oder sogar benannte Werte zur&uuml;ckzugeben:</p>
      <pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}</pre>
      <h2 id="Variadic">Variadische Funktionen <span class="ver">[AHK_L 60+]</span></h2>
      <p>Beim Definieren einer Funktion kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, wodurch sie eine beliebige Anzahl an Parametern akzeptiert:</p>
      <pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    Return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
      <p>Beim Aufrufen einer variadischen Funktion k&ouml;nnen &uuml;bersch&uuml;ssige Parameter mithilfe eines Objekts abgerufen werden, das im letzten Parameter der Funktion gespeichert ist. Der erste &uuml;bersch&uuml;ssige Parameter ist <code><i>params</i>[1]</code>, der Zweite ist <code><i>params</i>[2]</code> und so weiter. Wie bei jedem anderen Standardobjekt auch, kann <code><i>params</i>.MaxIndex()</code> verwendet werden, um den h&ouml;chsten numerischen Index zu ermitteln (in diesem Fall die Anzahl an Parametern). Sind allerdings keine Parameter vorhanden, gibt MaxIndex einen leeren String zur&uuml;ck.</p>
      <p>Hinweise:</p>
      <ul>
        <li>Der "variadische" Parameter kann sich nur am Ende der formalen Parameterliste befinden.</li>
        <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> k&ouml;nnen nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
        <li><a href="commands/RegisterCallback.htm">Callbacks</a> &uuml;bergeben &uuml;bersch&uuml;ssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
      </ul>
      <h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
      <p>W&auml;hrend variadische Funktionen eine beliebige Anzahl an Parametern <i>akzeptieren</i> k&ouml;nnen, kann ein Array mit Parametern an <i>jeder</i> Funktion &uuml;bergeben werden, wenn die gleiche Syntax beim Funktionsaufruf angewendet wird:</p>
      <pre>substrings := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">substrings*</b>)</pre>
      <p>Hinweise:</p>
      <ul>
        <li>Innerhalb des Quell-Arrays beginnt die Nummerierung der Parameter bei 1.</li>
        <li>Optionale Parameter k&ouml;nnen im Array ganz weggelassen werden.</li>
        <li>Das Array mit Parametern kann benannte Elemente enthalten, wenn eine benutzerdefinierte Funktion aufgerufen wird; in allen anderen F&auml;llen werden benannte Elemente nicht unterst&uuml;tzt.</li>
        <li>Die Zielfunktion kann auch variadisch sein. In diesem Fall werden benannte Elemente auch dann kopiert, wenn sie keinen entsprechenden formalen Parameter haben.</li>
        <li>Diese Syntax kann auch f&uuml;r den Aufruf einer Methode oder f&uuml;r das Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>. Seit v1.1.12 kann sie auch zum Setzen von Eigenschaften verwendet werden.</li>
      </ul>
      <p>Bekannte Einschr&auml;nkungen:</p>
      <ul>
        <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterst&uuml;tzt, aber nicht <code>Funktion(x*, y)</code>.</li>
        <li>Es d&uuml;rfen sich keine sichtbaren Zeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste befinden.</li>
      </ul>
      <h2 id="Locals">Lokale und globale Variablen</h2>
      <h3>Lokale Variablen</h3>
      <p>Alle Variablen innerhalb einer Funktion sind standardm&auml;&szlig;ig <em>lokal</em> (au&szlig;er <a href="#SuperGlobal">superglobale</a> Variablen und interne Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Der Inhalt jeder lokalen Variable ist nur f&uuml;r Zeilen sichtbar, die sich innerhalb der Funktion befinden. Daher kann eine lokale Variable den gleichen Namen einer globalen Variable haben, aber mit unterschiedlichem Inhalt. Au&szlig;erdem sind alle lokalen Variablen bei jedem Funktionsaufruf zu Beginn leer.</p>
      <h3 id="Global">Globale Variablen</h3>
      <p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor du sie verwendest. Zum Beispiel:</p>
      <pre>LogZuDatei(TextZuLog)
{
    global LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert au&szlig;erhalb dieser Funktion zugewiesen.</em>
    FileAppend, %TextZuLog%`n, %LogDateiname%
}</pre>
      <p id="AssumeGlobal"><strong>Modus f&uuml;r die globale Ansicht</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihr Variablen (au&szlig;er ihre Parameter) als global ansieht. Dazu muss in der ersten Zeile entweder das Wort &quot;global&quot; stehen oder die Deklaration einer lokalen Variable vorkommen. Zum Beispiel:</p>
      <pre>StandardwerteSetzen()
{
    global  <em>; Kann weggelassen werden, wenn die ersten Zeile so etwas wie "local EigeneVar" ist.</em>
    EigeneGlobal := 33  <em>; Speichert 33 in eine globale Variable, die vorher erstellt wird, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen m&uuml;ssen in diesem Modus deklariert werden, weil sie sonst als global angesehen werden.</em>
}</pre>
      <p>Dieser Modus f&uuml;r die globale Ansicht kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Array</a> zu erstellen - wie bei einer Schleife, die Werte per <code>Array%A_Index%</code> zuweist.</p>
      <p id="SuperGlobal"><strong>Superglobale Variablen</strong> <span class="ver">[v1.1.05+]</span>: Geschieht eine globale Deklaration au&szlig;erhalb einer Funktion, gilt sie standardm&auml;&szlig;ig f&uuml;r alle Funktionen. Dadurch wird verhindert, dass die Variablen jedesmal in einer Funktion neu deklariert werden m&uuml;ssen. Hat die Funktion allerdings bereits einen Parameter oder eine lokale Variable mit dem gleichen Namen, wird diese Vorrang vor der globalen Variable haben. Variablen, die mit dem Schl&uuml;sselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
      <h3 id="static">Statische Variablen</h3>
      <p>Statische Variablen sind immer indirekt lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
      <pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl = 0
    Zeilenanzahl += 1  <em>; Behandelt einen Z&auml;hler lokal (ihr Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend, %Zeilenanzahl%: %TextZuLog%`n, %LogDateiname%
}</pre>
      <p id="InitStatic"><strong>Statische Initialisierungen</strong>: In den Versionen vor v1.0.46 waren alle statischen Variablen zu Beginn leer; daher war der einzige Weg, die erste Verwendung so einer Variable zu erkennen, zu &uuml;berpr&uuml;fen, ob sie leer ist. Seit v1.0.46 k&ouml;nnen statische Variablen mit einem beliebigen Wert initialisiert werden (vorher war nur <code>""</code> m&ouml;glich), wenn <code>:=</code> oder <code>=</code> gefolgt von einem folgenden Wert angef&uuml;gt wird: <code>True</code>, <code>False</code>, ein direkter Integer, eine direkte Flie&szlig;kommazahl oder ein direkter String wie <code>"fox"</code>. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Jede statische Variable wird nur einmal initialisiert (bevor das Script ausgef&uuml;hrt wird).</p>
      <p><span class="ver">[AHK_L 58+]:</span> <code>Static Var := Ausdruck</code> wird unterst&uuml;tzt. Solche Ausdr&uuml;cke werden unmittelbar vor dem automatischen Ausf&uuml;hrungsbereich ausgewertet - in der Reihenfolge, wie sie im Script vorkommen.</p>
      <p id="AssumeStatic"><strong>Modus f&uuml;r statische Ansicht</strong> <span class="ver">[v1.0.48+]:</span> Eine Funktion kann so definiert werden, dass sie all ihre Variablen (au&szlig;er ihre Parameter) als statisch ansieht. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
      <pre>StatischesArrayAbrufen(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird weiterhin nur einmal ausgef&uuml;hrt (beim Start).</em>
    If ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    Return StatischesArray%Elementnummer%
}</pre>
      <p>Im Modus f&uuml;r die statische Ansicht muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
      <h3>Mehr &uuml;ber lokale und globale Variablen</h3>
      <p>Es k&ouml;nnen mehrere Variablen in einer Zeile deklariert werden, indem sie wie im folgenden Beispiel durch Kommas getrennt werden:</p>
      <pre>global LogDateiname, MaxWiederholungen := 5
static GesamtVersuche = 0, VorherErgebnis</pre>
      <p id="DeclareInit">Seit v1.0.46 kann eine lokale oder globale Variable auf der gleichen Zeile als Deklaration initialisiert werden, wenn ein <code>:=</code> oder <code>=</code> gefolgt von einem <a href="Variables.htm#Expressions">Ausdruck</a> angef&uuml;gt wird (der "<code>=</code>"-Operator verh&auml;lt sich in Deklarationen wie <code>:=</code>). Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgef&uuml;hrt, sofern sie von der Ablaufsteuerung erreicht werden. Das hei&szlig;t, dass eine Zeile wie <code>local x = 0</code> den gleichen Effekt hat wie das Schreiben von zwei getrennten Zeilen: <code>local x</code>, gefolgt von <code>x = 0</code>.</p>
      <p>Da die W&ouml;rter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Start des Scripts verarbeitet werden, kann eine Variable nicht per <a href="commands/IfExpression.htm">IF-Anweisung</a> bedingt deklariert werden. Das hei&szlig;t, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> f&uuml;r alle Zeilen zwischen der Deklaration und der schlie&szlig;enden Funktionsklammer bedingungslos wirksam wird. Beachte zudem, dass es zurzeit nicht m&ouml;glich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>
      <p>Bei Befehlen, die <a href="misc/Arrays.htm">Arrays</a> erstellen (z. B. <a href="commands/StringSplit.htm">StringSplit</a>), ist das resultierende Array lokal, solange der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> nicht aktiv ist oder das erste Array-Element als lokale Variable deklariert wurde (das gilt auch bei der &Uuml;bergabe eines Funktionsparameters, selbst wenn dieser Parameter ein <a href="#ByRef">ByRef</a> ist, da Parameter mit lokalen Variablen vergleichbar sind). Wurde das erste Element hingegen <a href="#Global">global deklariert</a>, wird ein globales Array erstellt. Allerdings gilt die unten genannte <i>h&auml;ufigste Ursache f&uuml;r Verwirrung</i> auch in solchen F&auml;llen. Das erste Element bei <a href="commands/StringSplit.htm">StringSplit</a> ist ArrayName0. Bei anderen array-erstellenden Befehlen wie <a href="commands/WinGet.htm">WinGet List</a> ist das erste Element ArrayName (also ohne die Nummer).</p>
      <p id="DynVar">Innerhalb einer Funktion wird jeder dynamische Variablenverweis wie <code>Array%i%</code> immer in eine lokale Variable aufgel&ouml;st, sofern eine Variable mit diesem Namen existiert. Ist das nicht der Fall, wird eine globale Variable verwendet, falls vorhanden. Wenn sie weder existiert noch bei ihrer Verwendung die Variable erstellt werden muss, wird sie als eine lokale Variable erstellt, solange der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> nicht aktiv ist. Daher kann eine Funktion ein globales <a href="misc/Arrays.htm">Array</a> nur manuell erstellen (z. B. mithilfe von <code>Array%i% := A_Index</code>), wenn in der Funktion der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> definiert wurde.</p>
      <p><strong>H&auml;ufigste Ursache f&uuml;r Verwirrung</strong>: Jeder <em>nicht</em>-dynamische Verweis auf eine Variable erstellt diese Variable, wenn das Script gestartet wird. Zum Beispiel: Au&szlig;erhalb einer Funktion w&uuml;rde <code>MsgBox %Array1%</code> die Array1-Variable als globale Variable erstellen, sobald das Script gestartet wird. Innerhalb einer Funktion w&uuml;rde <code>MsgBox %Array1%</code> die Array1-Variable als lokale Variable erstellen, sobald das Script gestartet wird (solange der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> nicht aktiv ist), selbst wenn Array und Array0 als global deklariert sind.</p>
      <h2 id="DynCall">Dynamisches Aufrufen einer Funktion </h2>
      <p>Seit v1.0.47.06 kann eine Funktion (auch eine <a href="#BuiltIn">interne Funktion</a>) mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel w&uuml;rde <code>%Var%(x, "fox")</code> die Funktion aufrufen, deren Name sich in <em>Var</em> befindet. Ebenso w&uuml;rde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abh&auml;ngig vom aktuellen Wert in A_Index.</p>
      <p>Seit v1.1.07.00 kann <em>Var</em> in <code>%Var%()</code> einen Funktionsnamen, ein <a href="objects/Func.htm">Funktionsverweis</a> oder eine <a href="Objects.htm#Objects_as_Functions">Objektnachahmung einer Funktion</a> enthalten. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen.</p>
      <p>Kann die Funktion aufgrund einer der unten genannten Gr&uuml;nde nicht aufgerufen werden, stoppt die Auswertung des Ausdrucks mit dem Aufruf unauff&auml;llig und fr&uuml;hzeitig, was m&ouml;glicherweise zu widerspr&uuml;chlichen Ergebnissen f&uuml;hren kann:</p>
      <ul>
        <li>Aufruf einer nicht vorhandenen Funktion, dass mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (au&szlig;er <a href="#BuiltIn">interne Funktionen</a>) muss direkt im Script vorhanden sein. Zum Beispiel per <a href="commands/_Include.htm">#Include</a> oder nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>.</li>
        <li>&Uuml;bergabe von zu wenigen Parametern, dass mittels &Uuml;berpr&uuml;fung des R&uuml;ckgabewertes von <a href="#IsFunc">IsFunc()</a> verhindert werden kann (das ist die Anzahl an vorgeschriebenen Parametern plus 1). Hinweis: Seit v1.0.48 wird die &Uuml;bergabe von zu vielen Parametern toleriert; jeder zus&auml;tzliche Parameter wird vollst&auml;ndig ausgewertet (einschlie&szlig;lich aller Funktionsaufrufe) und dann verworfen.</li>
      </ul>
      <p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgel&ouml;st (nachgeschlagen) werden, bevor die Ausf&uuml;hrung des Scripts beginnt.</p>
      <h2 id="ShortCircuit">Boolesche Kurzschlussauswertung</h2>
      <p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">tern&auml;re Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, werden sie kurzgeschlossen, um die Performance zu steigern (unabh&auml;ngig davon, ob Funktionsaufrufe vorhanden sind). Beim Kurzschlie&szlig;en werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Um das Konzept n&auml;her zubringen, schaue dir folgendes Beispiel an:</p>
      <pre>If (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
      <p>Im oberen Beispiel wird die Funktion FindeFarbe() nie aufgerufen, wenn die <em>FarbeName</em>-Variable leer ist. Das liegt daran, dass die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage w&auml;re, das Endergebnis auf <em>wahr</em> zu bringen.</p>
      <p>Dieses Verhalten f&uuml;hrt dazu, dass Nebeneffekte von einer Funktion (wie das &Auml;ndern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
      <p>Beachte au&szlig;erdem, dass die Kurzschlussauswertung stufenweise verschachtelte <em>AND</em>s und <em>OR</em>s durchgeht. Im Ausdruck des folgenden Beispiels wird nur der Vergleich ganz links durchgef&uuml;hrt, wenn <em>FarbName</em> leer ist. Die linke Seite w&uuml;rde ausreichen, um das Endergebnis zu bestimmen:</p>
      <pre>If (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder &Uuml;bereinstimmung gefunden.</em></pre>
      <p>Wie aus dem oberen Beispiel ersichtlich wird, sollten aufwendige Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erh&ouml;hen. Diese Technik kann auch dazu genutzt werden, einen Funktionsaufruf zu verhindern, wenn ein ungeeigneter Wert an einen Parameter &uuml;bergeben wird, wie z. B. ein leerer String.</p>
      <p>Seit v1.0.46 wird der <a href="Variables.htm#ternary">tern&auml;re Bedingungsoperator (?:)</a> auch kurzgeschlossen, indem die verlierende Abzweigung nicht ausgewertet wird.</p>
      <h2 id="gosub">Subroutinen innerhalb einer Funktion verwenden</h2>
      <p>Es ist m&ouml;glich, Subroutinen innerhalb einer Funktion anzugeben; <a href="#define">Definitionen</a> von anderen Funktionen sind nicht m&ouml;glich. Sie k&ouml;nnen, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> aufgerufen und per <a href="commands/Return.htm">Return</a> geschlossen werden (in diesem Fall gilt das Return f&uuml;r GoSub und nicht f&uuml;r die Funktion).</p>
      <p>Bekannte Einschr&auml;nkung: Momentan darf der Name jeder Subroutine (Label) nur einmal im ganzen Script vorkommen. Das Programm wird dich beim Start benachrichtigen, wenn Labels doppelt vorhanden sind.</p>
      <p id="GosubPublic">Verwendet eine Funktion den <a href="commands/Gosub.htm">GoSub</a>-Befehl zum Anspringen einer &ouml;ffentlichen Subroutine (die sich au&szlig;erhalb der Funktionsklammern befindet), sind alle &auml;u&szlig;eren Variablen global und die eigenen <a href="#Locals">lokalen Variablen</a> der Funktion erst zug&auml;nglich, wenn die Subroutine durchgef&uuml;hrt wurde. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
      <p>Der <a href="commands/Goto.htm">Goto</a>-Befehl kann nicht verwendet werden, um innerhalb einer Funktion von innen nach au&szlig;en zu springen. Allerdings ist es m&ouml;glich, dass eine Funktion per <a href="commands/Gosub.htm">GoSub</a> eine externe/&ouml;ffentliche Subroutine anspringen und von dort aus per Goto weiterspringen kann.</p>
      <p>Auch wenn von <a href="commands/Goto.htm">Goto</a> generell abgeraten wird, kann er innerhalb einer Funktion n&uuml;tzlich sein, um in der gleichen Funktion von einer Position zu einer anderen zu springen. Das kann dabei helfen, komplexe Funktionen mit mehreren R&uuml;ckgabepunkten zu vereinfachen, die einige S&auml;uberungsaktionen machen m&uuml;ssen, bevor sie ausgef&uuml;hrt werden.</p>
      <p>Eine Funktion kann extern-aufgerufene Subroutinen wie <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Men&uuml;punkte</a> enthalten. Das wird normalerweise gemacht, um sie f&uuml;r die Verwendung mit <a href="commands/_Include.htm">#Include</a> in eine separate Datei zu hinterlegen, damit sie den <a href="Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> nicht st&ouml;ren. Allerdings gelten folgende Einschr&auml;nkungen:</p>
      <ul>
        <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), immer wenn deren Funktionen normal aufgerufen werden. Der Grund ist, dass der <a href="misc/Threads.htm">Thread</a> einer Subroutine, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage w&auml;re, die Werte von lokalen Variablen zu &auml;ndern, welche vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zur&uuml;ckkehrt, werden all ihre lokale Variablen leer gemacht, um deren Speicher freizugeben.</li>
        <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) als <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
        <li>Wenn eine Funktion von einem Subroutine-<a href="misc/Threads.htm">Thread</a> angesprungen wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschlie&szlig;lich Befehle, die Arrays erstellen).</li>
      </ul>
      <h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
      <p>Erreicht der Ausf&uuml;hrungsablauf innerhalb einer Funktion die schlie&szlig;ende Funktionsklammer, ohne auf ein <a href="commands/Return.htm">Return</a> gesto&szlig;en zu sein, endet die Funktion und gibt ihren Aufrufer einen leeren String zur&uuml;ck. Ein leerer Wert wird auch zur&uuml;ckgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> ausdr&uuml;cklich weggelassen wird.</p>
      <p>Beendet eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> per <a href="commands/Exit.htm">Exit</a>-Befehl, erh&auml;lt ihr Aufrufer &uuml;berhaupt keinen R&uuml;ckgabewert. In so einem Fall w&uuml;rde beispielsweise <em>Var</em> bei der Anweisung <code>Var := Addieren(2, 3)</code> unver&auml;ndert bleiben. Das Gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausf&uuml;hren</a> einer nicht vorhandenen Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
      <p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> &auml;ndern, um einen zus&auml;tzlichen Wert zur&uuml;ckzugeben, der sich leicht merken l&auml;sst.</p>
      <p>Um eine Funktion mit einem oder mehreren leeren Strings aufzurufen, verwende zwei Anf&uuml;hrungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
      <p>Da ein Funktionsaufruf keinen neuen <a href="misc/Threads.htm">Thread</a> startet, gelten alle von der Funktion durchgef&uuml;hrten &Auml;nderungen an den Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch f&uuml;r den Aufrufer.</p>
      <p>Der Aufrufer kann der Funktion nicht vorhandene Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente &uuml;bergeben. Das ist besonders n&uuml;tzlich, wenn die Funktion vom entsprechenden Parameter erwartet, ein <a href="#ByRef">ByRef</a> zu sein. Zum Beispiel w&uuml;rde <code>GetNextLine(LeeresArray%i%)</code> die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellen (abh&auml;ngig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">Modus f&uuml;r die globale Ansicht</a> wirksam ist).</p>
      <p>Innerhalb einer Funktion zeigt <a href="commands/ListVars.htm">ListVars</a> deren <a href="#Locals">lokalen Variablen</a> mit Inhalt an, das zur Fehleranalyse verwendet werden kann.</p>
      <h2>Stil und Namenskonventionen</h2>
      <p>Komplexe Funktionen k&ouml;nnen besser lesbar und verwaltbar gemacht werden, wenn deren Variablen eindeutige Pr&auml;fixe angef&uuml;gt werden. Durch Hinzuf&uuml;gen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Pr&auml;fix "r" oder "r_" f&uuml;r <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" f&uuml;r <a href="#static">statische Variablen</a> verwendet werden.</p>
      <p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
      <pre>Addieren(x, y) <strong>{</strong>
    Return x + y
<strong>}</strong></pre>
      <h2 id="include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</h2>
      <p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Scripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
      <p>Erkl&auml;rung: Erreicht der Ausf&uuml;hrungsablauf des Scripts eine Funktionsdefinition, wird sie &uuml;bersprungen (verwendet eine sofortige Methode) und setzt die Ausf&uuml;hrung bei der Zeile nach der schlie&szlig;enden Klammer fort. Folglich kann die Ausf&uuml;hrung nie in eine Funktion geraten, noch beeinflussen eine oder mehrere Funktionen am Anfang des Scripts den <a href="Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a>.</p>
      <h2 id="lib">Funktionsbibliotheken: Standard- und Benutzerbibliothek <span class="ver">[v1.0.47+]</span> </h2>
      <p>Ein Script kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> zu verwenden. Damit das funktioniert, muss eine Datei mit gleichem Namen in einem der folgenden Bibliotheksverzeichnissen vorkommen:</p>
      <pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Lokale Bibliothek - ben&ouml;tigt AHK_L 42+.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; Benutzerbibliothek.</em>
Pfad-der-laufenden-AutoHotkey.exe\Lib\  <em>; Standardbibliothek.</em></pre>
      <p>Ruft ein Script beispielsweise eine nicht vorhandene Funktion <code>EigeneFunktion()</code> auf, sucht das Programm nach einer Datei namens &quot;EigeneFunktion.ahk&quot; in der Benutzerbibliothek. Ergibt die Suche keine Treffer, wird die Standardbibliothek durchsucht. Falls sie immer noch nicht gefunden wird und der Funktionsname ein Unterstrich enth&auml;lt (z. B. <code>EigenerPr&auml;fix_EigeneFunktion</code>), durchsucht das Programm beide Bibliotheken nach einer Datei namens &quot;EigenerPr&auml;fix.ahk&quot; und l&auml;dt sie, falls sie existiert. Dadurch kann &quot;EigenerPr&auml;fix.ahk&quot; sowohl die Funktion <code>EigenerPr&auml;fix_EigeneFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>EigenerPr&auml;fix_</code> beginnen.</p>
      <p><span class="ver">[AHK_L 42+]:</span> Die lokale Bibliothek wird unterst&uuml;tzt, welche ab sofort als erste Bibliothek durchsucht wird.</p>
      <p>In der Regel kann eine Bibliotheksdatei nur eine Funktion enthalten, die den Namen der Datei hat. Allerdings kann sie auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum vorhanden sind; das hei&szlig;t, dass sie von &uuml;berall im Script aufgerufen werden k&ouml;nnen.</p>
      <p>Verwendet eine Bibliotheksdatei <a href="commands/_Include.htm">#Include</a>, ist das Arbeitsverzeichnis f&uuml;r #Include das Verzeichnis der Bibliotheksdatei. Dadurch ist es m&ouml;glich, eine Umleitung zu einer gr&ouml;&szlig;eren Bibliotheksdatei zu erstellen, die diese Funktion und &Auml;hnliches enth&auml;lt.</p>
      <p>Der <a href="Scripts.htm#ahk2exe">Script-Compiler (ahk2exe)</a> unterst&uuml;tzt auch Bibliotheksfunktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Sollte AutoHotkey.exe fehlen, wird der Compiler weiterhin funktionieren, jedoch werden die Bibliotheksfunktionen nicht mehr automatisch eingef&uuml;gt.</p>
      <p>Funktionen, die von einer Bibliothek eingef&uuml;gt worden sind, funktionieren genauso gut wie andere Funktionen, da sie geladen werden, bevor das Script ausgef&uuml;hrt wird.</p>
      <h2 id="BuiltIn">Interne Funktionen</h2>
      <p>Jeder optionale Parameter, der am Ende der Parameterliste einer internen Funktion vorkommt, kann vollst&auml;ndig weggelassen werden. Zum Beispiel ist <code>WinExist("Unbenannt - Editor")</code> g&uuml;ltig, weil die anderen drei Parameter als leer angesehen werden.</p>
      <p>Eine interne Funktion kann &uuml;berschrieben werden, indem man eine eigene Funktion mit dem gleichen Namen definiert. Zum Beispiel k&ouml;nnte man anstelle der normalen WinExist()-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
      <p>Externe Funktionen, die sich in DLL-Dateien befinden, k&ouml;nnen per <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
      <h3>H&auml;ufig verwendete Funktionen</h3>
      <p id="FileExist"><strong>FileExist(Dateimuster)</strong>: Gibt einen leeren String zur&uuml;ck, wenn <em>Dateimuster</em> nicht existiert (<em>Dateimuster</em> befindet sich im <a href="Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist). Ansonsten wird ein <a href="commands/FileGetAttrib.htm#attrib">String mit Attributen</a> (eine Teilmenge von "RASHNDOCT") von der ersten gefundenen Datei oder des ersten gefundenen Ordners zur&uuml;ckgegeben. Hat die Datei keine Attribute (was sehr selten ist), wird "X" zur&uuml;ckgegeben. <em>Dateimuster</em> kann der exakte Name einer Datei oder eines Ordners sein, oder Platzhalter (* oder ?) enthalten. Da ein leerer String als "falsch" angesehen wird, kann der R&uuml;ckgabewert der Funktion immer als Boolscher Scheinwert verwendet werden. Zum Beispiel w&uuml;rde die Anweisung <code>If FileExist("C:\Eigene Datei.txt")</code> als wahr angesehen werden, wenn die Datei vorhanden ist. Ebenso w&uuml;rde die Anweisung <code>If InStr(FileExist("C:\Eigene Ordner"), "D")</code> nur als wahr angesehen werden, wenn die Datei existiert <em>und</em> ein Verzeichnis ist. Dazugeh&ouml;rige Befehle: <a href="commands/IfExist.htm">IfExist</a> und <a href="commands/FileGetAttrib.htm">FileGetAttrib</a>.</p>
      <p id="GetKeyState"><strong>GetKeyState(<a href="KeyList.htm">Tastenname</a> [, "P"</strong> oder <strong>"T"])</strong>: Im Gegensatz zum <a href="commands/GetKeyState.htm">GetKeyState</a>-Befehl (der D f&uuml;r unten und U f&uuml;r oben zur&uuml;ckgibt) wird diese Funktion wahr (1) zur&uuml;ckgeben, wenn die Taste unten ist, und falsch (0), wenn sie oben ist. Ist der <em><a href="KeyList.htm">Tastenname</a></em> ung&uuml;ltig, wird ein leerer String zur&uuml;ckgegeben. Siehe <a href="commands/GetKeyState.htm">GetKeyState</a> f&uuml;r weitere R&uuml;ckgabewerte und zus&auml;tzliche Informationen zur Verwendung.</p>
      <p id="InStr"><strong>InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</strong>: Gibt die Position des Strings <em>Nadel</em> zur&uuml;ck, der im String <em>Heuhaufen</em> vorkommt. Im Gegensatz zu <a href="commands/StringGetPos.htm">StringGetPos</a> beginnt hier das erste Zeichen bei Position 1; das liegt daran, dass 0 das Synonym f&uuml;r "falsch" ist, was sich gut als "nicht gefunden" eignet. Ist der <em>Zeichengenauigkeit</em>-Parameter nicht vorhanden oder "falsch", unterscheidet die Suche nicht zwischen Gro&szlig;- und Kleinschreibung (die Unterscheidung h&auml;ngt von <a href="commands/StringCaseSense.htm">StringCaseSense</a> ab); ansonsten muss die Gro&szlig;- und Kleinschreibung exakt &uuml;bereinstimmen. Ist <em>Startposition</em> nicht vorhanden, gilt standardm&auml;&szlig;ig 1 (der Anfang von <em>Heuhaufen</em>). Ansonsten kannst du eine 2 angeben, um die Suche im <em>Heuhaufen</em> beim zweiten Zeichen zu beginnen, eine 3, um beim dritten Zeichen zu beginnen, und so weiter. &Uuml;berschreitet <em>Startposition</em> die L&auml;nge von <em>Heuhaufen</em>, wird eine 0 zur&uuml;ckgegeben. Wenn <em>Startposition</em> eine 0 oder negativ ist, erfolgt die Suche in umgekehrter Reihenfolge (von rechts nach links), beginnend beim Offset am Ende. Ungeachtet des Wertes in <em>Startposition</em> bezieht sich der R&uuml;ckgabewert immer auf das erste Zeichen von <em>Heuhaufen</em>. Zum Beispiel w&uuml;rde die Position von "abc" innerhalb von "123abc789" immer 4 sein. Schreibe eine 2 in <i>Vorkommen</i>, um die Position der zweiten &Uuml;bereinstimmung zur&uuml;ckzugeben, eine 3 f&uuml;r die dritte &Uuml;bereinstimmung und so weiter. Verwandte Elemente: <a href="commands/RegExMatch.htm">RegExMatch()</a>, <a href="commands/IfInString.htm">IfInString</a> und <a href="commands/StringGetPos.htm">StringGetPos</a>.</p>
      <p><strong>RegExMatch(Heuhaufen, NadelRegEx [, Ausgabevariable = "", Startposition = 1])</strong>: &Uuml;berpr&uuml;ft, ob ein Muster (regul&auml;rer Ausdruck) im String vorkommt. Siehe <a href="commands/RegExMatch.htm">RegExMatch</a><a href="commands/RegExMatch.htm">()</a> f&uuml;r Details.</p>
      <p><strong>RegExReplace(Heuhaufen, NadelRegEx [, Ersatz = "", AusgabevariableAnzahl = "", Limit = -1, Startposition = 1])</strong>: Ersetzt ein Muster (regul&auml;rer Ausdruck), das innerhalb eines Strings vorkommt. Siehe <a href="commands/RegExReplace.htm">RegExReplace</a><a href="commands/RegExReplace.htm">()</a> f&uuml;r Details.</p>
      <p id="SubStr"><strong>SubStr(String, Startposition [, L&auml;nge])</strong> <span class="ver">[v1.0.46+]:</span> Kopiert einen Teilstring vom <em>String</em>, beginnend bei <em>Startposition</em> von links nach rechts, bis die angegebene <em>L&auml;nge</em> erreicht wurde (falls <em>L&auml;nge</em> nicht vorhanden ist, gilt standardm&auml;&szlig;ig "alle Zeichen"). F&uuml;r <em>Startposition</em> kann eine 1 angegeben werden, um beim ersten Zeichen zu beginnen, eine 2, um beim zweiten Zeichen zu beginnen, und so weiter (&uuml;berschreitet <em>Startposition</em> die L&auml;nge von <em>String</em>, wird ein leerer String zur&uuml;ckgegeben). Ist <em>Startposition</em> kleiner als 1, wird es als Offset vom Ende des Strings angesehen. Zum Beispiel w&uuml;rde eine 0 das letzte Zeichen und -1 die letzten zwei Zeichen extrahieren (&uuml;berschreitet <em>Startposition</em> aber das linke Ende des Strings, beginnt das Extrahieren beim ersten Zeichen). <em>L&auml;nge</em> ist die maximale Anzahl an Zeichen, die extrahiert werden sollen (es werden weniger Zeichen abgerufen, falls der verbleibende Teil des Strings zu kurz ist). Verwende eine negative <em>L&auml;nge</em>, um die Anzahl an Zeichen zu bestimmen, die vom Ende des zur&uuml;ckgegebenen Strings weggelassen werden sollen (es wird ein leerer String zur&uuml;ckgegeben, wenn alle oder zu viele Zeichen weggelassen worden sind). Verwandte Elemente: <a href="commands/RegExMatch.htm">RegExMatch()</a>, <a href="commands/StringMid.htm">StringMid</a>, <a href="commands/StringLeft.htm">StringLeft/Right</a>, <a href="commands/StringTrimLeft.htm">StringTrimLeft/Right</a>.</p>
      <p id="StrLen"><strong>StrLen(String)</strong>: Gibt die L&auml;nge von <em>String</em> zur&uuml;ck. Siehe <a href="commands/StringLen.htm">StrLen()</a> f&uuml;r Details.</p>
      <p id="StrSplit"><strong>StrSplit(String [, Trennzeichen, ZeichenAuslassen])</strong> <span class="ver">[v1.1.13+]:</span> Teilt einen String in mehrere Teilstrings auf, basierend auf die angegebenen   Trennzeichen. Siehe <a href="commands/StringSplit.htm">StrSplit()</a> f&uuml;r Details.</p>
      <p id="WinActive"><strong>WinActive([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des aktiven Fensters zur&uuml;ck, wenn die &Uuml;bereinstimmung die angegebenen Kriterien erf&uuml;llt. Ist das nicht der Fall, gibt die Funktion eine 0 zur&uuml;ck. Da alle Zahlen au&szlig;er 0 als "wahr" angesehen werden, gilt die Anweisung <code>If WinActive("Fenstertitel")</code> immer als wahr, wenn <em>Fenstertitel</em> aktiv ist. Der <em>Fenstertitel</em>-Parameter unterst&uuml;tzt ahk_id, ahk_class und andere spezielle Strings. Siehe <a href="commands/IfWinActive.htm">IfWinActive</a> f&uuml;r Details &uuml;ber diese und andere Aspekte der Fensteraktivierung. Hinweis: Die eindeutige ID des aktiven Fensters kann auch einfach mit <code>ActiveHwnd := WinExist("A")</code> abgerufen werden.</p>
      <p id="WinExist"><strong>WinExist([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des ersten &uuml;bereinstimmenden Fensters zur&uuml;ck. Siehe <a href="commands/IfWinExist.htm">IfWinExist</a> f&uuml;r Details.</p>
      <h3>Verschiedene Funktionen</h3>
      <p id="Asc"><strong>Asc(String)</strong>: Gibt den Zeichencode (bei ANSI-Versionen eine Zahl zwischen 1 und 255, und bei Unicode-Versionen eine Zahl zwischen 1 und 65535) f&uuml;r das erste Zeichen im <em>String</em> zur&uuml;ck. Ist <em>String</em> leer, wird 0 zur&uuml;ckgegeben.</p>
      <p id="Chr"><strong>Chr(Zahl)</strong>: Gibt ein einzelnes Zeichen zur&uuml;ck, das zum angegebenen Zeichencode (<em>Zahl</em>) geh&ouml;rt. Liegt <em>Zahl</em> au&szlig;erhalb des g&uuml;ltigen Bereichs der Zeichencodes, wird ein leerer String zur&uuml;ckgegeben. H&auml;ufig verwendete Zeichencodes sind 9 (Tabulator), 10 (LF), 13 (CR), 32 (Leerzeichen), 48-57 (die Zahlen von 0 bis 9), 65-90 (Gro&szlig;buchstaben von A bis Z) und 97-122 (Kleinbuchstaben von a bis z).</p>
      <p><strong>DllCall()</strong>: Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows. Siehe <a href="commands/DllCall.htm">DllCall()</a> f&uuml;r Details.</p>
      <p><strong>FileOpen()</strong>: Erm&ouml;glicht eine objektorientierte Dateibearbeitung. Siehe <a href="commands/FileOpen.htm">FileOpen()</a> f&uuml;r Details.
      <p id="Func"><strong>Func(Funktionsname)</strong> <span class="ver">[v1.1.00+]:</span> Falls <em>Funktionsname</em> nicht direkt im Script vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>), wird Func() eine 0 zur&uuml;ckgeben. Ansonsten wird der <a href="Objects.htm#Function_References">Verweis auf die Funktion</a> zur&uuml;ckgegeben. Das kannst du verwenden, um die Funktion aufzurufen oder <a href="objects/Func.htm">Informationen</a> abzurufen, wie beispielsweise die minimale und maximale Anzahl an Parametern.</p>
      <p id="GetKeyName"><strong>GetKeyName(Taste), GetKeyVK(Taste), GetKeySC(Taste)</strong> <span class="ver">[v1.1.01+]:</span> Ermittelt den Namen/Text, virtuellen Tastencode oder Scancode einer Taste. <em>Taste</em> kann ein VK oder SC-Code, wie z. B. "vkA2" oder "sc01D", eine Kombination von beiden oder ein Tastenname sein. Zum Beispiel wird sowohl <code>GetKeyName("vk1B")</code> als auch <code>GetKeyName("Esc")</code> "Escape" zur&uuml;ckgeben, w&auml;hrend <code>GetKeyVK("Esc")</code> eine 27 zur&uuml;ckgibt.</p>
      <p id="IsByRef"><strong>IsByRef(Var)</strong> <span class="ver">[v1.1.01+]:</span> Gibt eine 1 zur&uuml;ck, falls <em>Var</em> ein ByRef-Parameter ist und der Aufrufer eine Variable &uuml;bergibt; oder 0, falls <em>Var</em> ein anderer Variablentyp ist.</p>
      <p id="IsFunc"><strong>IsFunc(Funktionsname)</strong> <span class="ver">[v1.0.48+]:</span> Falls <em>Funktionsname</em> nicht direkt im Script vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>), wird IsFunc() eine 0 zur&uuml;ckgeben. Ansonsten gibt sie die minimale Anzahl an Parametern zur&uuml;ck, addiert mit 1 (also 1 f&uuml;r eine Funktion ohne Parameter, 2 f&uuml;r eine Funktion mit einem Parameter und so weiter). Zum Beispiel w&uuml;rden die Anweisungen <code>If IsFunc("EigeneFunktion")</code> und <code>If IsFunc(VariableMitFunktionsnamen)</code> als wahr angesehen werden, wenn die Funktion vorhanden ist. Seit v1.1.00 kann <i>Funktionsname</i> anstelle eines Namens auch ein Funktionsverweis sein. Siehe auch: <a href="#DynCall">Dynamischer Funktionsaufruf</a>, <a href="Variables.htm#ThisFunc">A_ThisFunc</a></p>
      <p id="IsLabel"><strong>IsLabel(Labelname)</strong>: Gibt eine Zahl ungleich 0 zur&uuml;ck, wenn <em>Labelname</em> als <a href="commands/Gosub.htm">Subroutine</a>, <a href="Hotkeys.htm">Hotkey</a> oder <a href="Hotstrings.htm">Hotstring</a> im Script vorkommt (<em>Labelname</em> muss ohne den Doppelpunkten angegeben werden). Zum Beispiel w&uuml;rde die Anweisung <code>If IsLabel(VariableMitLabelnamen)</code> als wahr angesehen werden, wenn das Label vorhanden ist. Das ist n&uuml;tzlich, um Laufzeitfehler zu unterdr&uuml;cken, wenn du ein dynamisches Label in Befehlen wie <a href="commands/Gosub.htm">Gosub</a>, <a href="commands/Hotkey.htm">Hotkey</a>, <a href="commands/Menu.htm">Menu</a> und <a href="commands/Gui.htm">Gui</a> angibst. Siehe auch: <a href="misc/Labels.htm">Label</a>.</p>
      <p id="IsObject"><strong>IsObject()</strong> <span class="ver">[AHK_L 31+]:</span> Erkennt, ob ein Wert ein Objekt ist. Siehe auch: <a href="Objects.htm">Objekte</a>.</p>
      <p><strong>ListView- und TreeView-Funktionen</strong>: Siehe <a href="commands/ListView.htm">ListView</a> und <a href="commands/TreeView.htm">TreeView</a> f&uuml;r Details.</p>
      <p id="NumGet"><strong>NumGet(VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong> <span class="ver">[v1.0.47+]:</span> Gibt die bin&auml;re Zahl zur&uuml;ck, die sich auf der Adresse + Offset befindet. Bei <em>VarOderAdresse</em> ist die &Uuml;bergabe von <code>EigeneVar</code> das gleiche wie, als w&uuml;rdest du <code>&amp;EigeneVar</code> &uuml;bergeben. Das Weglassen von "&amp;" f&uuml;hrt allerdings zur besseren Performance und stellt sicher, dass die Zieladresse <a href="commands/VarSetCapacity.htm">g&uuml;ltig</a> ist (ung&uuml;ltige Adressen geben "" zur&uuml;ck). &Uuml;bergibst du hingegen etwas in <em>VarOderAdresse</em>, das keine reine Variable ist, wird es als unbearbeitete Adresse behandelt. Folglich f&uuml;hrt die Angabe von <code>EigeneVar+0</code> dazu, dass die Zahl in EigeneVar verwendet wird, anstatt der Adresse von EigeneVar selbst. Bei <em>Typ</em> kann UInt, Int, Int64, Short, UShort, Char, UChar, Double, Float oder Ptr angegeben werden (die im Gegensatz zu DllCall jedoch in Anf&uuml;hrungszeichen gesetzt werden m&uuml;ssen, wenn sie als direkte Strings verwendet werden sollen); siehe <a href="commands/DllCall.htm#types">DllCall-Typen</a> f&uuml;r Details. <span class="ver">[AHK_L 57+]:</span><i>Offset</i> kann ganz weggelassen werden; z. B. ist <code>NumGet(Var, "Int")</code> g&uuml;ltig.</p>
      <p id="NumPut"><strong>NumPut(Zahl, VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong> <span class="ver">[v1.0.47+]:</span> Speichert <em>Zahl</em> im Bin&auml;rformat auf die angegebene Adresse + Offset und gibt die Adresse zur Rechten des Elements zur&uuml;ck, das gerade geschrieben wurde. Bei <em>VarOderAdresse</em> ist die &Uuml;bergabe von <code>EigeneVar</code> das gleiche wie, als w&uuml;rdest du <code>&amp;EigeneVar</code> &uuml;bergeben. Das Weglassen von "&amp;" f&uuml;hrt allerdings zur besseren Performance und stellt sicher, dass die Zieladresse <a href="commands/VarSetCapacity.htm">g&uuml;ltig</a> ist (ung&uuml;ltige Adressen geben "" zur&uuml;ck). &Uuml;bergibst du hingegen etwas in <em>VarOderAdresse</em>, das keine reine Variable ist, wird es als unbearbeitete Adresse behandelt. Folglich f&uuml;hrt die Angabe von <code>EigeneVar+0</code> dazu, dass die Zahl in EigeneVar verwendet wird, anstatt der Adresse von EigeneVar selbst. Bei <em>Typ</em> kann UInt, Int, Int64, Short, UShort, Char, UChar, Double, Float oder Ptr angegeben werden (die im Gegensatz zu DllCall jedoch in Anf&uuml;hrungszeichen gesetzt werden m&uuml;ssen, wenn sie als direkte Strings verwendet werden sollen) (seit v1.0.48 wird UInt64 unterst&uuml;tzt); siehe <a href="commands/DllCall.htm#types">DllCall-Typen</a> f&uuml;r Details. &Uuml;berschreitet ein Integer die Gr&ouml;&szlig;e des angegebenen <em>Typs</em>, werden seine h&ouml;chstwertigen Bytes ignoriert; z. B. w&uuml;rde <code>NumPut(257, Var, 0, "Char")</code> nur die Zahl 1 speichern. <span class="ver">[AHK_L 57+]:</span><i>Offset</i> kann ganz weggelassen werden; z. B. ist <code>NumPut(x, Var, "Int")</code> g&uuml;ltig.</p>
      <p><strong>OnMessage(Nachrichtennummer [, "Funktionsname"])</strong>: &Uuml;berwacht eine Nachricht/ein Ereignis. Siehe <a href="commands/OnMessage.htm">OnMessage()</a> f&uuml;r weitere Details.</p>
      <p><strong>StrGet(Adresse [, L&auml;nge] [, Kodierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert einen String von einer Speicheradresse und wandelt ihn optional in verschiedene Zeichens&auml;tze um. Siehe <a href="commands/StrPutGet.htm">StrGet()</a> f&uuml;r weitere Details.</p>
      <p><strong>StrPut(String, Adresse [, L&auml;nge] [, Kodierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert einen String auf einer Speicheradresse und wandelt ihn optional in verschiedene Zeichens&auml;tze um. Siehe <a href="commands/StrPutGet.htm">StrPut()</a> f&uuml;r weitere Details.</p>
      <p><strong>RegisterCallback()</strong>: Erstellt eine Maschinencode-Adresse, die beim Aufrufen den Aufruf zu einer Funktion im Script umleitet. Siehe <a href="commands/RegisterCallback.htm">RegisterCallback()</a> f&uuml;r Details.</p>
      <p><strong>Trim()</strong> <span class="ver">[AHK_L 31+]:</span> Entfernt bestimmte Zeichen vom Anfang und/oder Ende eines Strings. Siehe <a href="commands/Trim.htm">Trim()</a> f&uuml;r Details.</p>
      <p><strong>VarSetCapacity(Variablenname [, Ben&ouml;tigteKapazit&auml;t, F&uuml;llbyte])</strong>: Vergr&ouml;&szlig;ert die Aufnahmekapazit&auml;t einer Variable oder gibt deren Speicher frei. Siehe <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> f&uuml;r Details.</p>
      <h3 id="Math">Allgemeine Mathematik </h3>
      <p>Hinweis: Mathematische Funktionen geben generell einen leeren Wert (String) zur&uuml;ck, falls einer der eingehenden Parameter nicht numerisch ist.</p>
      <p id="Abs"><strong>Abs(Zahl)</strong>: Gibt den absoluten Wert von <em>Zahl</em> zur&uuml;ck. Der R&uuml;ckgabewert hat den gleichen Typ wie <em>Zahl</em> (Integer oder Flie&szlig;kommazahl).</p>
      <p id="Ceil"><strong>Ceil(Zahl)</strong>: Gibt <em>Zahl</em> zur&uuml;ck, aufgerundet auf den n&auml;chsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Ceil(1.2)</code> gleich 2 und <code>Ceil(-1.2)</code> gleich -1.</p>
      <p id="Exp"><strong>Exp(N)</strong>: Gibt <em>e</em> zur&uuml;ck (ungef&auml;hr 2.71828182845905), potenziert mit <em>N</em>. Der Parameter <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Um neben <em>e</em> noch andere Zahlen zu potenzieren, verwende den <a href="Variables.htm#pow">**-Operator</a>.</p>
      <p id="Floor"><strong>Floor(Zahl)</strong>: Gibt <em>Zahl</em> zur&uuml;ck, abgerundet auf den n&auml;chsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Floor(1.2)</code> gleich 1 und <code>Floor(-1.2)</code> gleich -2.</p>
      <p id="Log"><strong>Log(Zahl)</strong>: Gibt den Logarithmus (Basis 10) von <em>Zahl</em> zur&uuml;ck. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Flie&szlig;kommazahl</a>. Wenn <em>Zahl</em> negativ ist, wird ein leerer String zur&uuml;ckgegeben.</p>
      <p id="Ln"><strong>Ln(Zahl)</strong>: Ermittelt den Logarithmus (Basis e) von <em>Zahl</em>. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Flie&szlig;kommazahl</a>. Wenn <em>Zahl</em> negativ ist, wird ein leerer String zur&uuml;ckgegeben.</p>
      <p id="Mod"><strong>Mod(Dividend, Divisor)</strong>: Modulo. Gibt den Rest zur&uuml;ck, wenn der <em>Dividend</em> durch den <em>Divisor</em> geteilt wird. Das Vorzeichen des Ergebnisses entspricht dem Vorzeichen des ersten Parameters. Zum Beispiel sind <code>Mod(5, 3)</code> und <code>Mod(5, -3)</code> gleich 2, aber <code>Mod(-5, 3)</code> und <code>Mod(-5, -3)</code> gleich -2. Wenn einer der beiden Parameter eine Flie&szlig;kommazahl ist, wird das Ergebnis ebenfalls eine Flie&szlig;kommazahl sein. Zum Beispiel ist <code>Mod(5.0, 3)</code> gleich 2.0 und <code>Mod(5, 3.5)</code> gleich 1.5. Ist der zweite Parameter eine 0, gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
      <p id="Round"><strong>Round(Zahl [, N])</strong>: Ist <em>N</em> nicht vorhanden oder eine 0, wird <em>Zahl</em> auf den n&auml;chsten Integer gerundet. Ist <em>N</em> eine positive Zahl, wird <em>Zahl</em> auf <em>N</em> Dezimalstellen gerundet. Ist <em>N</em> negativ, wird <em>Zahl</em> auf <em>N</em> Stellen nach links gerundet. Zum Beispiel ist <code>Round(345, -1)</code> gleich 350 und <code>Round(345, -2)</code> gleich 300. Im Gegensatz zu <a href="commands/Transform.htm">Transform Round</a> hat das Ergebnis keinen .000-Suffix, wenn <em>N</em> weggelassen wird oder kleiner als 1 ist. Seit v1.0.44.01 zeigt ein Wert in <em>N</em>, der gr&ouml;&szlig;er als 0 ist, genau <em>N</em> Dezimalstellen an, anstatt <a href="commands/SetFormat.htm">SetFormat</a> zu ber&uuml;cksichtigen. Du kannst das verhindern, indem du eine weitere mathematische Operation beim R&uuml;ckgabewert von Round() durchf&uuml;hrst; zum Beispiel: <code>Round(3.333, 1)<strong>+0</strong></code>.</p>
      <p id="Sqrt"><strong>Sqrt(Zahl)</strong>: Gibt die Quadratwurzel von <em>Zahl</em> zur&uuml;ck. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Flie&szlig;kommazahl</a>. Wenn <em>Zahl</em> negativ ist, gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
      <h3>Trigonometrie</h3>
      <p><strong id="Sin">Sin(Zahl)</strong> | <strong id="Cos">Cos(Zahl)</strong> | <strong id="Tan">Tan(Zahl) </strong>: Gibt den trigonometrischen Sinus|Kosinus|Tangens von <em>Zahl</em> zur&uuml;ck. <em>Zahl</em> muss als Bogenma&szlig; angegeben werden.</p>
      <p id="ASin"><strong>ASin(Zahl)</strong>: Gibt den Arkussinus (die Zahl, deren Sinus <em>Zahl</em> ist) als Bogenma&szlig; zur&uuml;ck. Wenn <em>Zahl</em> kleiner als -1 oder gr&ouml;&szlig;er als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
      <p id="ACos"><strong>ACos(Zahl)</strong>: Gibt den Arkuskosinus (die Zahl, deren Kosinus <em>Zahl</em> ist) als Bogenma&szlig; zur&uuml;ck. Wenn die <em>Zahl</em> kleiner als -1 oder gr&ouml;&szlig;er als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zur&uuml;ck.</p>
      <p id="ATan"><strong>ATan(Zahl)</strong>: Gibt den Arkustangens (die Zahl, deren Tangens <em>Zahl</em> ist) als Bogenma&szlig; zur&uuml;ck.</p>
      <p><strong>Hinweis:</strong> Soll Bogenma&szlig; in Grad umgewandelt werden, multipliziere es mit 180/pi (ungef&auml;hr 57.29578). Soll Grad in Bogenma&szlig; umgewandelt werden, multipliziert es mit pi/180 (ungef&auml;hr 0.01745329252). Der Wert von pi (ungef&auml;hr 3.141592653589793) ist viermal der Arcustangens von 1.</p>
      <h3>Weitere Funktionen</h3>
      <p><a href="http://www.autohotkey.net/~polyethene/#functions">Befehlsfunktionen von Polyethene</a>: Bietet f&uuml;r jeden AutoHotkey-Befehl, der eine Ausgabevariable hat, eine aufrufbare Funktion. Diese Bibliothek kann per <a href="commands/_Include.htm">#Include</a> in jedem Script eingef&uuml;gt werden.</p>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(0);</script>
</body>
</html>