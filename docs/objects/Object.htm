<!DOCTYPE HTML>
<html>
<head>
<title>Object</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Object</h1>

<p>Alle integrierten Methoden von Objekten, die mit <a href="../Objects.htm#Arrays">Object()</a> oder <code>{}</code> erstellt wurden, können entweder als reguläre Funktionen oder als Methoden aufgerufen werden:</p>
<pre>Ergebnis := Object.Methode(Parameter)</pre>
<p>Mit so einem Methodenaufruf kann jedes Objekt sein eigenes Verhalten für diese Methode umsetzen. Wenn ein Objekt allerdings eine integrierte Methode überschreibt, muss das Objekt irgendwie auf die ursprüngliche Funktionalität zurückgreifen. Mithilfe der folgenden Funktionsform kann das erreicht werden:</p>
<pre>Ergebnis := ObjMethod(Objekt, Parameter)</pre>
<p>Der direkte Aufruf der Funktion ist ein wenig schneller, da der Name bei der Ladezeit aufgelöst wird, jedoch ist die Syntax nicht gerade intuitiv. Jedes implementierte benutzerdefinierte Verhalten vom Objekt wird umgangen, daher sollte diese Funktionen nur vom Objekt selbst verwendet werden.</p>

<div class="methodShort" id="Insert"><h2>Insert <span class="ver">[AHK_L 31+]</span></h2>
<p>Fügt Schlüssel-Wert-Paare in das Objekt ein und passt gegebenenfalls automatisch vorhandene Schlüssel an.</p>
<pre class="Syntax">Object.Insert(Index, Wert1 [, Wert2, ... ... Wert<i>N</i> ])
Object.Insert(Wert)
Object.Insert(Schlüssel, Wert)</pre>
<table class="info">
  <tr><td width="15%">Index</td><td width="85%">Ein Integer-Schlüssel, der bei Wert1 eingefügt wird. Nachfolgende Werte werden bei Index+1, Index+2 und so weiter eingefügt.<br>
  Falls weggelassen, gilt standardmäßig <code>MaxIndex()="" ? 1 : MaxIndex() + 1</code>.</td></tr>
  <tr><td>Schlüssel</td><td>Ein String oder Objektschlüssel. Wenn der Schlüssel bereits vorhanden ist, wird sein Wert überschrieben.</td></tr>
  <tr><td>Wert</td><td>Ein String, eine Zahl oder ein Objekt.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Der Wert ist bei Erfolg <i>wahr</i> oder bei Misserfolg ein leerer String, wenn das Script nicht genug Arbeitsspeicher hat.</td></tr>
</table>
<h3>Bemerkungen</h3>
<p>Beachtet, dass diese Methode den <a href="../Objects.htm#Meta_Functions">__Set</a>-Mechanismus und das Sonderverhalten des <a href="../Objects.htm#Custom_Objects">base</a>-Schlüssels umgeht. Zum Beispiel bewirkt <code>Object.Insert("base","")</code>, dass <code>Object.base</code> einen leeren String anstelle des echten base-Objekts zurückgibt, wobei andere Operationen nicht daran gehindert werden, die Meta-Funktionen des Objekts auszulösen.</p>
</div>

<div class="methodShort" id="Remove"><h2>Remove <span class="ver">[AHK_L 31+]</span></h2>
<p>Entfernt Schlüssel-Wert-Paare von einem Objekt.</p>
<pre class="Syntax">Object.Remove(ErsterSchlüssel, LetzterSchlüssel)</pre>
<table class="info">
  <tr><td width="15%">ErsterSchlüssel, LetzterSchlüssel</td><td width="85%">Eine Reihe von Integer- oder String-Schlüsseln, die entfernt werden. Wenn beide Schlüssel Integer sind, wird jeder Integer-Schlüssel größer als <i>LetzterSchlüssel</i> um <code>(LetzterSchlüssel - ErsterSchlüssel + 1)</code> verringert, um einen typischen numerisch indizierten Array zu emulieren. Beide Schlüssel müssen vom gleichen Typ sein (Integer oder String).</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die tatsächliche Anzahl von Schlüssel-Wert-Paaren, die erfolgreich entfernt wurden; eine 0, falls keine Schlüssel gefunden wurden; oder bei Misserfolg ein leerer String.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Remove(Schlüssel = <i>MaxIndex()</i>)</pre>
<table class="info">
  <tr><td width="15%">Schlüssel</td><td width="85%">Beliebiger gültiger Schlüssel. Falls weggelassen, gilt standardmäßig der höchste vorhandene Integer-Schlüssel; falls keine vorhanden sind, wird nichts entfernt. Vorhandene Schlüssel werden angepasst, als ob <code>Remove(Schlüssel, Schlüssel)</code> verwendet wurde.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Der entfernte Wert, ansonsten ein leerer String.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Remove(IntSchlüssel, "")</pre>
<p><span class="ver">[AHK_L 61+]:</span> Entfernt einen Integer-Schlüssel und gibt seinen Wert zurück, jedoch sind andere Integer-Schlüssel nicht davon betroffen.</p>
</div>

<div class="methodShort" id="MinMaxIndex"><h2>MinIndex / MaxIndex <span class="ver">[AHK_L 31+]</span></h2>
<pre class="Syntax">MinIndex := Object.MinIndex()
MaxIndex := Object.MaxIndex()</pre>
<p>Sobald mindestens ein Integer-Schlüssel vorhanden ist, wird MinIndex den niedrigsten und MaxIndex den höchsten Schlüssel zurückgeben. Ansonsten wird ein leerer String zurückgegeben.</p></div>

<div class="methodShort" id="SetCapacity"><h2>SetCapacity <span class="ver">[AHK_L 31+]</span></h2>
<p>Passt die Kapazität eines Objekts oder eins seiner Felder an.</p>
<pre class="Syntax">Object.SetCapacity(Elementmaximum)
Object.SetCapacity(Schlüssel, Bytegröße)</pre>
<table class="info">
  <tr><td width="15%">Elementmaximum</td><td width="85%">Die maximale Anzahl von Schlüssel-Wert-Paaren, die das Objekt aufnehmen kann, bevor es automatisch erweitert werden muss. Wenn dieser Parameterwert kleiner als die aktuelle Anzahl ist, wird das Objekt verkleinert, damit es passt.</td></tr>
  <tr><td>Schlüssel</td><td>Beliebiger gültiger Schlüssel.</td></tr>
  <tr><td>Bytegröße</td><td>Die neue String-Zwischenspeicher-Größe des Feldes in Bytes, ohne den 0-Terminator. Falls das Feld noch nicht vorhanden ist, wird es erstellt. Falls <i>Bytegröße</i> eine 0 ist, wird der Zwischenspeicher freigegeben, aber das leere Feld nicht entfernt. Wenn <i>Bytegröße</i> kleiner als die aktuelle Größe ist, werden überschüssige Daten gekürzt; ansonsten werden alle vorhandenen Daten beibehalten.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die neue Kapazität bei Erfolg, ansonsten ein leerer String.</td></tr>
</table></div>

<div class="methodShort" id="GetCapacity"><h2>GetCapacity <span class="ver">[AHK_L 31+]</span></h2>
<pre class="Syntax">Elementmaximum := Object.GetCapacity()
Bytegröße := Object.GetCapacity(Schlüssel)</pre>
<p>Gibt die Kapazität eines Objekts oder eins seiner Felder zurück.</p></div>

<div class="methodShort" id="GetAddress"><h2>GetAddress <span class="ver">[AHK_L 31+]</span></h2>
<pre class="Syntax">Ptr := Object.GetAddress(Schlüssel)</pre>
<p>Gibt die aktuelle String-Zwischenspeicher-Adresse des Feldes zurück, falls vorhanden.</p></div>

<div class="methodShort" id="NewEnum"><h2>NewEnum <span class="ver">[AHK_L 49+]</span></h2>
<pre class="Syntax">Enum := Object._NewEnum()</pre>
<p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zurück, um Schlüssel-Wert-Paare des Objekts zu enumerieren.</p></div>

<div class="methodShort" id="HasKey"><h2>HasKey <span class="ver">[AHK_L 53+]</span></h2>
<pre class="Syntax">Object.HasKey(Schlüssel)</pre>
<p>Gibt wahr zurück, wenn der <i>Schlüssel</i> einem Wert (auch "") innerhalb des <i>Objekts</i> zugeordnet ist, ansonsten falsch.</p></div>

<div class="methodShort" id="Clone"><h2>Clone <span class="ver">[AHK_L 60+]</span></h2>
<pre class="Syntax">Klon := Object.Clone()</pre>
<p>Gibt eine oberflächliche Kopie des Objekts zurück.</p></div>

</body>
</html>
