<!DOCTYPE HTML>
<html>
<head>
<title>Object</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Object</h1>

<p>In AutoHotkey ist der grundlegende Objektdatentyp ein assoziatives Array, dessen Verhalten <a href="../Objects.htm#Custom_Objects">individuell angepasst werden kann</a>. Standardmäßig unterstützen alle Objekte, die mit <code>{}</code>, <code>[]</code>, <code>Object()</code> und <code>Array()</code> erstellt wurden, folgende Methoden:</p>
<ul>
	<li><a href="#Insert">Insert</a></li>
	<li><a href="#Remove">Remove</a></li>
	<li><a href="#MinMaxIndex">MinIndex / MaxIndex</a></li>
	<li><a href="#SetCapacity">SetCapacity</a></li>
	<li><a href="#GetCapacity">GetCapacity</a></li>
	<li><a href="#GetAddress">GetAddress</a></li>
	<li><a href="#NewEnum">_NewEnum</a></li>
	<li><a href="#HasKey">HasKey</a></li>
	<li><a href="#Clone">Clone</a></li>
</ul>
<p>Jede Methode hat außerdem eine äquivalente Funktion, mit der jedes <a href="../Objects.htm#Custom_Objects">benutzerdefinierte Verhalten</a>, das vom Objekt implementiert wurde, umgangen werden kann. Diese Funktionen sollten nur für diesen Zweck verwendet werden. Um so eine Funktion aufzurufen, muss vor dem Methodennamen "Obj" angefügt und das Zielobjekt als erster Parameter übergeben werden. Zum Beispiel:</p>
<pre>array := [1, 2, 3]
MsgBox % ObjMaxIndex(array) " = " array.MaxIndex()</pre>
&nbsp;

<div class="methodShort" id="Insert"><h2>Insert <span class="ver">[AHK_L 31+]</span></h2>
<p>Fügt Key-Value-Paare in das Objekt ein und passt bei Bedarf vorhandene Keys automatisch an.</p>
<pre class="Syntax">Object.Insert(Index, Value1 [, Value2, ... Value<i>N</i> ])
Object.Insert(Value)
Object.Insert(Key, Value)</pre>
<table class="info">
  <tr><td width="15%">Index</td><td width="85%">Ein Integer-Key, bei dem Value1 eingefügt werden soll. Nachfolgende Values werden bei Index+1, Index+2 und so weiter eingefügt.<br>
  Fehlt dieser Parameter, gilt standardmäßig <code>MaxIndex()="" ? 1 : MaxIndex() + 1</code>.</td></tr>
  <tr><td>Key</td><td>Ein String oder Objekt-Key. Wenn der Key bereits vorhanden ist, wird sein Value überschrieben.</td></tr>
  <tr><td>Value</td><td>Ein String, eine Zahl oder ein Objekt.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Bei Erfolg ein <i>wahrer</i> Wert, oder ein leerer String, wenn das Script über nicht genügend Arbeitsspeicher verfügt.</td></tr>
</table>
<h3>Bemerkungen</h3>
<p>Beachte, dass diese Methode den <a href="../Objects.htm#Meta_Functions">__Set</a>-Mechanismus und das Sonderverhalten des <a href="../Objects.htm#Custom_Objects">base</a>-Keys umgeht. Zum Beispiel würde <code>Object.Insert("base","")</code> bewirken, dass <code>Object.base</code> nicht das echte base-Objekt sondern einen leeren String  zurückgibt, aber es verhindert nicht, dass andere Operationen die Meta-Funktionen des Objekts auslösen können.</p>
</div>

<div class="methodShort" id="Remove"><h2>Remove <span class="ver">[AHK_L 31+]</span></h2>
<p>Entfernt Key-Value-Paare von einem Objekt.</p>
<pre class="Syntax">Object.Remove(ErsterKey, LetzterKey)</pre>
<table class="info">
  <tr><td width="15%">ErsterKey, LetzterKey</td><td width="85%">Eine Reihe von Integer- oder String-Keys, die entfernt werden sollen. Enthalten beide Keys Integer-Werte, wird jeder Integer-Key größer als <i>LetzterKey</i> um <code>(LetzterKey - ErsterKey + 1)</code> verringert, um einen typischen numerisch indizierten Array zu emulieren. Beide Keys müssen vom gleichen Typ sein (Integer oder String).</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Bei Erfolg die tatsächliche Anzahl von entfernten Key-Value-Paaren; eine 0, wenn keine Keys auffindbar sind; oder bei Fehlschlag ein leerer String.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Remove(Key = <i>MaxIndex()</i>)</pre>
<table class="info">
  <tr><td width="15%">Key</td><td width="85%">Beliebiger gültiger Key. Fehlt dieser Parameter, gilt standardmäßig der höchste vorhandene Integer-Key; existiert überhaupt kein Key, wird nichts entfernt. Vorhandene Keys werden angepasst, als ob <code>Remove(Key, Key)</code> verwendet wurde.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Der entfernte Value, falls vorhanden; ansonsten ein leerer String.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Remove(IntKey, "")</pre>
<p><span class="ver">[AHK_L 61+]:</span> Entfernt einen Integer-Key und gibt seinen Value zurück, aber hat keinen Einfluss auf andere Integer-Keys.</p>
</div>

<div class="methodShort" id="MinMaxIndex"><h2>MinIndex / MaxIndex <span class="ver">[AHK_L 31+]</span></h2>
<pre class="Syntax">MinIndex := Object.MinIndex()
MaxIndex := Object.MaxIndex()</pre>
<p>Sofern Integer-Keys vorhanden sind, gibt MinIndex den niedrigsten und MaxIndex den höchsten Key zurück. Ansonsten wird ein leerer String zurückgegeben.</p></div>

<div class="methodShort" id="SetCapacity"><h2>SetCapacity <span class="ver">[AHK_L 31+]</span></h2>
<p>Passt die Kapazität eines Objekts oder eines seiner Felder an.</p>
<pre class="Syntax">Object.SetCapacity(MaxElemente)
Object.SetCapacity(Key, Bytegröße)</pre>
<table class="info">
  <tr><td width="15%">MaxElemente</td><td width="85%">Die maximale Anzahl an Key-Value-Paaren, die das Objekt beinhalten soll, bevor es automatisch erweitert werden muss. Ist dieser Parameter kleiner als die aktuelle Anzahl an Key-Value-Paaren, wird stattdessen dieser Wert verwendet und ungenutzter Speicher freigegeben.</td></tr>
  <tr><td>Key</td><td>Beliebiger gültiger Key.</td></tr>
  <tr><td>Bytegröße</td><td>Die neue Größe in Bytes für den String-Zwischenspeicher des Feldes, ohne den 0-Terminator. Wenn das Feld nicht vorhanden ist, wird es erstellt. Ist <i>Bytegröße</i> eine 0, wird der Zwischenspeicher freigegeben, aber das leere Feld nicht entfernt. Ist <i>Bytegröße</i> kleiner als die aktuelle Größe, werden überschüssige Daten gekürzt; ansonsten werden alle vorhandenen Daten beibehalten.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Bei Erfolg die neue Kapazität, ansonsten ein leerer String.</td></tr>
</table></div>

<div class="methodShort" id="GetCapacity"><h2>GetCapacity <span class="ver">[AHK_L 31+]</span></h2>
<pre class="Syntax">MaxElemente := Object.GetCapacity()
Bytegröße := Object.GetCapacity(Key)</pre>
<p>Gibt die Kapazität eines Objekts oder eines seiner Felder zurück.</p></div>

<div class="methodShort" id="GetAddress"><h2>GetAddress <span class="ver">[AHK_L 31+]</span></h2>
<pre class="Syntax">Ptr := Object.GetAddress(Key)</pre>
<p>Gibt die aktuelle Adresse vom String-Zwischenspeicher des Feldes zurück, wenn es einen hat.</p></div>

<div class="methodShort" id="NewEnum"><h2>NewEnum <span class="ver">[AHK_L 49+]</span></h2>
<pre class="Syntax">Enum := Object._NewEnum()</pre>
<p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zurück, um Key-Value-Paare des Objekts zu enumerieren. Diese Methode wird in der Regel nicht direkt, sondern über die <a href="../commands/For.htm">For-Schleife</a> aufgerufen.</p></div>

<div class="methodShort" id="HasKey"><h2>HasKey <span class="ver">[AHK_L 53+]</span></h2>
<pre class="Syntax">Object.HasKey(Key)</pre>
<p>Gibt wahr zurück, wenn <i>Key</i> mit einem Value (auch "") innerhalb des <i>Objekts</i> verbunden ist, ansonsten falsch.</p></div>

<div class="methodShort" id="Clone"><h2>Clone <span class="ver">[AHK_L 60+]</span></h2>
<pre class="Syntax">Klon := Object.Clone()</pre>
<p>Gibt eine flache Kopie des Objekts zurück.</p></div>

</body>
</html>
