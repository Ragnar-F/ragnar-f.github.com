<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Script-Kompatibilit&auml;t</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<script src="navbar/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>


<h1>Script-Kompatibilit&auml;t</h1>

<p>Durch grundlegende Unterschiede zwischen AutoHotkey Basic und AutoHotkey_L (insbesondere Unicode- und x64-Versionen) funktionieren m&ouml;glicherweise einige AutoHotkey-Scripts nicht wie erwartet mit AutoHotkey_L. Dieses Dokument beschreibt bekannte Kompatibilit&auml;tsprobleme und -l&ouml;sungen.</p>

<h2 id="Format">Unicode und ANSI</h2>
<p>Alle erwarteten oder zur&uuml;ckgegebenen Strings von internen Befehlen, Funktionen und Operatoren haben ein bestimmtes Bin&auml;rformat im Speicher, bekannt als das <i>urspr&uuml;ngliche Format</i>. Diese Art des Formats ist von der AutoHotkey-Version abh&auml;ngig: <i>Unicode</i> oder <i>ANSI</i>. Scripts, die nur ein bestimmtes Format ber&uuml;cksichtigen, werden oft mit Problemen konfrontiert, wenn sie mit der falschen Version von AutoHotkey laufen. Wenn man sich nicht sicher ist, welche Version zurzeit l&auml;uft, verwendet folgendes Script:</p>
<pre>MsgBox % A_IsUnicode ? "Unicode" : "ANSI"</pre>
<p><b>ANSI:</b> Strings werden wie auch in AutoHotkey Basic im Standard-ANSI-Zeichensatz des Betriebssystems gespeichert. Jedes Zeichen ist ein Byte gro&szlig; (8 Bit).</p>
<p><b>Unicode:</b> Strings werden im <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>-Format gespeichert, bei dem jedes Zeichen zwei Bytes gro&szlig; ist (16 Bit).</p>
<p>Technisch gesehen sind einige Unicode-Zeichen durch <i>zwei</i> 16-Bit-Code-Einheiten vertreten, auch allgemein bekannt als "Ersatzzeichenpaar" (surrogate pair). Ebenso enthalten einige <a href="http://msdn.microsoft.com/en-us/library/dd317752.aspx">ANSI-Zeichens&auml;tze</a> (allgemein bekannt als <a href="http://msdn.microsoft.com/en-us/library/dd317794.aspx">Doppel-Byte-Zeichens&auml;tze</a>)  einige Doppel-Byte-Zeichen. Allerdings werden sie normalerweise einfach als zwei einzelne "Zeichen" behandelt.</p>

<h3>Script-Dateien</h3>
<p>Beachtet, dass obwohl jede Version von AutoHotkey nur ein bestimmtes Format f&uuml;r Strings im Speicher unterst&uuml;tzt, eine Reihe von verschiedenen Kodierungen f&uuml;r Script-Quelldateien verwendet werden k&ouml;nnen. Wenn ein Script Nicht-ASCII-Zeichen in der falschen Kodierung enth&auml;lt, dann werden sie falsch geladen. Ahk2Exe und Unicode-Versionen von AutoHotkey_L erwarten standardm&auml;&szlig;ig <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, w&auml;hrend Scripts mit der ANSI-Version ANSI erwarten. Weitere Informationen k&ouml;nnen in "<a href="Scripts.htm#cp">Zeichensatz einer Script-Datei</a>" gefunden werden.</p>

<h3 id="VarSetCapacity">VarSetCapacity</h3>
<p>VarSetCapacity bestimmt die Kapazit&auml;t einer Variable <i>in Bytes</i>.  Da die Zeichengr&ouml;&szlig;e je nach Stringformat variiert, sind m&ouml;glicherweise einige Berechnungen notwendig:</p>
<pre>VarSetCapacity(ansi_var, size_in_chars)
VarSetCapacity(unicode_var, size_in_chars * 2)
VarSetCapacity(native_var,  size_in_chars * (A_IsUnicode ? 2 : 1))
VarSetCapacity(native_var, t_size(size_in_chars))  <em>; siehe <a href="#NumPutGet">unten</a></em>
</pre>
<p>VarSetCapacity wird intern ein <i>Zeichen</i> zur Kapazit&auml;t hinzuf&uuml;gen, damit die Variable zur Sicherheit 0-terminiert wird.  Allerdings sollte <code>size_in_chars</code> den 0-Terminator aus Konsistenzgr&uuml;nden bereits enthalten, wenn ein String, der nicht im <i>urspr&uuml;nglichen Format</i> ist, in die Variable gespeichert wird.</p>

<h3 id="DllCall">DllCall</h3>
<p>Beim Verwenden des "Str"-Typs ist der String im urspr&uuml;nglichen Format der aktuellen Version. Da einige Funktionen m&ouml;glicherweise Strings in einem bestimmten Format ben&ouml;tigen oder zur&uuml;ckgeben, stehen die folgenden Stringtypen zur Verf&uuml;gung:</p>
<table class="info">
  <tr><th></th><th>Zeichengr&ouml;&szlig;e</th><th>C / Win32-Typen</th><th>Kodierung</th></tr>
  <tr><td class="Syntax" style="text-align:center">WStr</td><td style="text-align:center">16-Bit</td><td>wchar_t*, WCHAR*, LPWSTR, LPCWSTR</td><td>UTF-16</td></tr>
  <tr><td class="Syntax" style="text-align:center">AStr</td><td style="text-align:center">8-Bit</td><td>char*, CHAR*, LPSTR, LPCSTR</td><td>ANSI (der Standard-ANSI-Zeichensatz des Systems)</td></tr>
  <tr><td class="Syntax" style="text-align:center">Str</td><td style="text-align:center">--</td><td>TCHAR*, LPTSTR, LPCTSTR</td><td>Entspricht <b>WStr</b> in Unicode-Versionen und <b>Astr</b> in ANSI-Versionen.</td></tr>
</table>
<br>
<p>Wenn "Str" oder das Gegenst&uuml;ck der aktuellen Version als ein Parameter verwendet wird, dann wird die Adresse des Strings oder der Variable an die Funktion &uuml;bergeben, ansonsten wird stattdessen eine tempor&auml;re Kopie des Strings im gew&uuml;nschten Format erstellt und &uuml;bergeben. Funktionen k&ouml;nnen eine tempor&auml;re Kopie &auml;ndern, <b>d&uuml;rfen aber nicht</b> auf der rechten Seite des 0-Terminators schreiben. Allgemein gilt, dass "AStr" und "WStr" nicht f&uuml;r Ausgabeparameter verwendet werden sollten.</p>
<p><b>Hinweis:</b> "AStr" und "WStr" sind f&uuml;r Parameter und R&uuml;ckgabewerte von Funktionen gleichberechtigt.</p>
<p>Wenn ein Script eine Funktion mithilfe von DllCall aufruft, die einen String als Parameter akzeptiert, dann muss einer der folgenden Ans&auml;tze ber&uuml;cksichtigt werden:</p>
<ol>
  <li>Falls sowohl die Unicode- (W) als auch ANSI-Version (A) von der Funktion verf&uuml;gbar sind, dann ruft jeweils die passende Funktion f&uuml;r die aktuelle Version auf. Im folgenden Beispiel ist "DeleteFile" intern als "DeleteFileA" oder "DeleteFileW" bekannt. Da "DeleteFile" selbst nicht wirklich existiert, versucht DllCall automatisch, "A" oder "W" f&uuml;r die aktuelle Version zu setzen:
  <pre>DllCall("DeleteFile", "Ptr", &amp;Dateiname)
DllCall("DeleteFile", "Str", Dateiname)</pre>
  <p>In diesem Beispiel wird <code>&amp;Dateiname</code> die Adresse des Strings wie sie ist &uuml;bergeben, damit die Funktion einen String im gleichen Format wie der "Str"-Typ erwarten muss. Beachtet, dass "UInt" anstelle von "Ptr" in AutoHotkey Basic verwendet werden muss, jedoch der resultierende Code m&ouml;glicherweise nicht 64-Bit-kompatibel ist.
  <p><b>Hinweis:</b> Wenn die Funktion nicht wie angegeben zu finden ist, dann wird AutoHotkey_L das "A"- oder "W"-Suffix unabh&auml;ngig von der DLL anf&uuml;gen. AutoHotkey Basic wird allerdings den "A"-Suffix nur f&uuml;r Funktionen von User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll anf&uuml;gen.</p></li>
  <li>Wenn die Funktion nur einen bestimmten Stringtyp als Eingabevariable akzeptiert, dann kann das Script den entsprechenden Stringtypen verwenden:
  <pre>DllCall("DeleteFileA", "AStr", Dateiname)
DllCall("DeleteFileW", "WStr", Dateiname)</pre></li>
  <li>Wenn die Funktion einen String &auml;ndern muss (in einem nicht urspr&uuml;nglichen Format), dann muss das Script einen Zwischenspeicher wie <a href="#VarSetCapacity">oben</a> beschrieben bereitstellen und dessen Adresse an die Funktion &uuml;bergeben. Wenn der Parameter eine Eingabevariable akzeptiert, dann muss das Script den Eingabestring in das entsprechende Format mithilfe von <a href="commands/StrPutGet.htm">StrPut</a> umwandeln.</li>
</ol>

<h3 id="NumPutGet">NumPut / NumGet</h3>
<p>Wenn NumPut oder NumGet mit Strings verwendet werden, dann muss der Offset und Typ f&uuml;r den angegeben Typ korrekt sein. Das folgende Beispiel dient als Veranschaulichung:</p>
<pre><em>; 8-Bit/ANSI   Strings:  size_of_char=1  type_of_char="Char"
; 16-Bit/UTF-16 Strings:  size_of_char=2  type_of_char="UShort"</em>
<i>n</i>th_char := NumGet(Variable, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)
NumPut(<i>n</i>th_char, Variable, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)</pre>
<p>Wenn die <code>Variable</code> einen String im urspr&uuml;nglichen Format enth&auml;lt, dann k&ouml;nnen die entsprechenden Werte in Bezug auf <code>A_IsUnicode</code> bestimmt werden:</p>
<pre><i>n</i>th_char := NumGet(Variable, t_size(<i>n</i>-1), t_char())
NumPut(<i>n</i>th_char, Variable, t_size(<i>n</i>-1), t_char())

<em>; Funktionen der Einfachheit und Deutlichkeit halber definieren:</em>
t_char() {
    Return A_IsUnicode ? "UShort" : "Char"
}
t_size(char_count=1) {
    Return A_IsUnicode ? char_count : char_count*2
}</pre>

<h2 id="ptr">Pointer-Gr&ouml;&szlig;e</h2>
<p>Pointer haben eine Gr&ouml;&szlig;e von 4 Bytes in 32-Bit-Versionen (einschlie&szlig;lich AutoHotkey Basic) und 8 Bytes in 64-Bit-Versionen. Scripts mit Strukturen oder DllCalls m&uuml;ssen diese m&ouml;glicherweise ber&uuml;cksichtigen, damit sie auf beiden Plattformen richtig funktionieren. Bestimmte Bereiche, die auch betroffen sind:</p>
<ul>
  <li>Offset-Berechnung f&uuml;r Strukturfelder, die beliebig viele Pointer enthalten.</li>
  <li>Gr&ouml;&szlig;enberechnung f&uuml;r Strukturen mit beliebig vielen Pointern.</li>
  <li>Typennamen, die mit <a href="commands/DllCall.htm">DllCall</a>, <a href="Functions.htm#NumPut">NumPut</a> oder <a href="Functions.htm#NumGet">NumGet</a> verwendet werden.</li>
</ul>
<p>Verwendet f&uuml;r Gr&ouml;&szlig;e- und Offset-Berechnungen <a href="Variables.htm#PtrSize">A_PtrSize</a>. Verwendet f&uuml;r DllCall, NumPut und NumGet je nach Bedarf den <a href="commands/DllCall.htm">Ptr</a>-Typ.</p>
<p>Denkt daran, dass der Offset eines Felds in der Regel die Gesamtgr&ouml;&szlig;e aller vorherigen Felder ist. Beachtet zudem, dass Handles (auch Typen wie HWND und HBITMAP) haupts&auml;chlich Pointer-Typen sind.</p>
<pre><em>/*
  typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Ptr
    HANDLE hThread;
    DWORD  dwProcessId; // UInt (4 bytes)
    DWORD  dwThreadId;
  } <a href="http://msdn.microsoft.com/en-us/library/ms684873.aspx">PROCESS_INFORMATION</a>, *LPPROCESS_INFORMATION;
*/</em>
VarSetCapacity(pi, A_PtrSize*2 + 8) <em>; Ptr + Ptr + UInt + UInt</em>
DllCall("<a href="http://msdn.microsoft.com/en-us/library/ms682425.aspx">CreateProcess</a>", <span class="dull">&lt;der K&uuml;rze halber weggelassen&gt;</span>, "Ptr", &amp;pi, <span class="dull">&lt;weggelassen&gt;</span>)
hProcess    := NumGet(pi, 0)         <em>; Standardm&auml;&szlig;ig "Ptr".</em>
hThread     := NumGet(pi, A_PtrSize) <em>; </em>
dwProcessId := NumGet(pi, A_PtrSize*2,     "UInt")
dwProcessId := NumGet(pi, A_PtrSize*2 + 4, "UInt")

</pre>

<h2 id="Other">Weitere &Auml;nderungen</h2>

<h3>Standard-Script</h3>
<p>Falls AutoHotkey_L ohne Angabe eines Scripts gestartet wird, dann entspricht der Dateiname des Standard-Scripts dem Namen der ausf&uuml;hrbaren Datei, aber mit "ahk"-Erweiterung. Weitere Details k&ouml;nnen in "<a href="Scripts.htm#cmd">Befehlszeilenparameter an ein Script &uuml;bergeben</a>" gefunden werden.</p>

<h3 id="Names">Variablen- und Funktionsnamen</h3>
<p>Die Zeichen [ ] und ? sind nicht l&auml;nger in Variablennamen g&uuml;ltig. Folglich ben&ouml;tigt ? (wird in tern&auml;ren Operationen verwendet) nicht l&auml;nger ein Leerzeichen auf jeder Seite.  Siehe auch <a href="Objects.htm#Syntax">Objektsyntax</a>.</p>

<h3 id="Validation">Syntaxvalidierung</h3>
<p>Befehlsnamen m&uuml;ssen mit einem Leerzeichen, Tabulator oder Komma terminiert werden.  Im Gegensatz zu AutoHotkey Basic umgehen die folgenden Zeichen nicht diese Anforderung: <code>&lt;&gt;:+-*/!~&amp;|^[]</code>. Folglich werden Syntaxfehler wie <code>MsgBox< foo</code> und <code>If!foo</code>, w&auml;hrend der Ladezeit abgefangen und nicht als <code>MsgBox,< foo</code> oder <code>If !foo</code> interpretiert.</p>

<h3 id="Transform">Transform</h3>
<p>Einige Unterbefehle von <i>Transform</i> wurden in der <b>Unicode</b>-Version ge&auml;ndert:</p>
<ul>
  <li><span class="Syntax">Unicode</span> ist nicht mehr verf&uuml;gbar. Um der Zwischenablage ein Unicode-Text zuzuweisen, verwendet eine normale Zuweisung. Siehe auch: <a href="commands/StrPutGet.htm">StrPut/StrGet</a>.</li>
  <li><span class="Syntax">HTML</span> unterst&uuml;tzt <a href="commands/Transform.htm#HTML">zus&auml;tzliche Funktionen</a>.</li>
</ul>


<h3 id="IfIs">If Variable is</h3>
<p>Dieser Befehl ignoriert das Gebietsschema des Betriebssystems, es sei denn, <i>StringCaseSense, Locale</i> wurde verwendet.</p>

<h3 id="FileRead">FileRead</h3>
<p><a href="commands/FileRead.htm#Binary">FileRead</a> wandelt den Zeichensatz des Textes in bestimmten F&auml;llen um, wodurch unbrauchbare Bin&auml;rdaten entstehen k&ouml;nnen.</p>

<h3 id="ControlZ">Steuerung+Z</h3>
<p><a href="commands/LoopReadFile.htm">Loop Read</a> und <a href="commands/FileReadLine.htm">FileReadLine</a> interpretieren das Zeichen Steuerung+Z (0x1A) nicht als Zeilenumbruchszeichen. Somit wird jedes Steuerung+Z als normales Zeichen behandelt, selbst wenn es am Ende einer Datei vorkommt. <a href="commands/FileRead.htm">FileRead</a> verh&auml;lt sich bereits auf diese Weise.</p>

<h3 id="SetFormat">SetFormat, Integer[Fast], H</h3>
<p>Bei einem gro&szlig;geschriebenen H sind die hexadezimale Zeichen A-F auch in Gro&szlig;buchstaben. AutoHotkey Basic verwendet hingegen immer kleingeschriebene Zeichen. Siehe <a href="commands/SetFormat.htm">SetFormat</a>.</p>

<h3>Kompatibilit&auml;tsmodus</h3>
<p>Wenn der <a href="http://de.wikipedia.org/wiki/Kompatibilit&auml;tsmodus">Kompatibilit&auml;tsmodus</a> in den Eigenschaften der EXE-Datei auf Windows 95, NT4 oder 98/ME gesetzt wird, um das Script auszuf&uuml;hren, dann verh&auml;lt sich das Script m&ouml;glicherweise nicht korrekt. Denn der Kompatibilit&auml;tsmodus bewirkt, dass eine bestimmte Windows-Version der Anwendung gemeldet wird, die jedoch von den vorgefertigten Bin&auml;rdateien nicht unterst&uuml;tzt wird. Wenn der Kompatibilit&auml;tsmodus zum Beispiel auf Windows 95 oder 98/ME gesetzt wird, dann meldet <code>MsgBox %A_OSVersion%</code> den R&uuml;ckgabewert <code>WIN_NT4</code>.</p>

<h3 id="Run">Run / RunWait <span class="ver">[AHK_L 57+]</span></h3>
<p>Zus&auml;tzlich zu den benutzerdefinierten Verben (<code>Run *Verb Datei</code>) wurde das Verfahren ge&auml;ndert, wie die Aktion und ihre Parameter aus dem <i>Ziel</i>-Parameter extrahiert werden. Im Einzelnen:</p>
<ul>
  <li>Wenn das <i>Ziel</i> mit einem Anf&uuml;hrungszeichen beginnt, dann wird alles nach dem Anf&uuml;hrungszeichen als Aktion angesehen.</li>
  <li>Ansonsten wird der erste Teilstring, der mit einem Leerzeichen endet und weder eine vorhandene Datei ist noch mit .exe, .bat, .com, .cmd oder .hta endet, als Aktion angesehen. Dadurch k&ouml;nnen Dateitypen wie .ahk, .vbs oder .lnk auch Parameter akzeptieren, w&auml;hrend "bekannte" ausf&uuml;hrbare Dateien wie wordpad.exe weiterhin ohne absoluten Pfad ausgef&uuml;hrt werden k&ouml;nnen.</li>
</ul>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>