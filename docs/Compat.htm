<!DOCTYPE HTML>
<html>
<head>
<title>Script-Kompatibilit&auml;t</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<link href="static/font.css" rel="stylesheet" type="text/css" />
<script src="static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="static/html5.js"></script>
<![endif]-->
<script src="navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(0);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Script-Kompatibilit&auml;t</h1>
      <p>Normalerweise m&uuml;ssen viele Scripts, die f&uuml;r AutoHotkey 1.0 geschrieben wurden, nicht ge&auml;ndert werden, um auch f&uuml;r AutoHotkey 1.1 lauff&auml;hig zu sein. Allerdings kann es aufgrund von notwendigen Unterschieden zwischen den beiden Versionen passieren, dass einige davon nicht richtig funktionieren. Die meisten Benutzer m&uuml;ssen sich keine Sorgen machen, da die besonders problematischen Unterschiede nur auf erweiterte Funktionalit&auml;ten wie DllCall zutreffen.</p>
	  <p>AutoHotkey 1.1 ist auch unter den Namen "AutoHotkey_L" bekannt, w&auml;hrend AutoHotkey 1.0 r&uuml;ckwirkend als "AutoHotkey Basic" bezeichnet wurde. Einige &auml;ltere Versionen von AutoHotkey_L verwenden als Versionsnummer 1.0.*, daher werden die zwei Entwicklungszweige von AutoHotkey der Klarheit halber per Namen genannt, anstatt per Versionsnummer.</p>
      <p class="note"><strong>Hinweis:</strong> Einige typische Probleme werden durch &Auml;nderungen bzgl. der Unterst&uuml;tzung f&uuml;r Unicode-Text verursacht und k&ouml;nnen verhindert werden, indem einfach die ANSI-Version von AutoHotkey_L verwendet wird.</p>
      <h3>Grundlagen</h3>
      <p>Hohe Auswirkung:</p>
      <ul>
        <li><a href="#Syntax_Errors">Bestimmte Syntaxfehler werden nicht l&auml;nger toleriert</a></li>
        <li><a href="#FileRead">FileRead k&ouml;nnte besch&auml;digte Bin&auml;rdaten zur&uuml;ckgeben</a></li>
        <li><a href="#Names">Variablen- und Funktionsnamen k&ouml;nnen nicht mehr [, ] oder ? enthalten</a></li>
      </ul>
      <p>Mittlere Auswirkung:</p>
      <ul>
        <li><a href="#Transform">Der <em>Unicode</em>-Unterbefehl von Transform ist in Unicode-Versionen nicht verf&uuml;gbar</a></li>
        <li><a href="#Default_Script">AutoHotkey.ahk wird anstelle von AutoHotkey.ini ausgef&uuml;hrt</a></li>
        <li><a href="#SetFormat">SetFormat, Integer, <strong>H</strong> unterscheidet zwischen Gro&szlig;- und Kleinschreibung</a></li>
        <li><a href="#LastError">A_LastError wird von noch mehr Befehlen ge&auml;ndert</a></li>
        <li><a href="#MsgBox">MsgBox behandelt Kommas konsequenter</a></li>
      </ul>
      <p>Niedrige Auswirkung:</p>
      <ul>
        <li><a href="#IfIs">If <em>Var</em> is <em>Typ</em> ignoriert standardm&auml;&szlig;ig das Gebietsschema des Betriebssystems</a></li>
        <li><a href="#Window_Groups">GroupActivate setzt ErrorLevel and das <em>Label</em> von GroupAdd funktioniert anders</a></li>
        <li><a href="#Run">Run und RunWait interpretieren das <em>Ziel</em> anders</a></li>
        <li><a href="#ControlZ">Steuerung-Z wird nicht als End-of-File interpretiert</a></li>
        <li><a href="#Compatibility_Mode">Der Kompatibilit&auml;tsmodus k&ouml;nnte Verwirrung stiften</a></li>
        <li><a href="#IsCompiled">A_IsCompiled ist immer schreibgesch&uuml;tzt</a></li>
        <li><a href="#Escaped_Whitespace">F&uuml;hrende und nachfolgende `t-Sequenzen werden nicht l&auml;nger verworfen</a></li>
      </ul>
      <h3>Erweitert</h3>
      <ul>
        <li><a href="#Format">Unicode vs. ANSI</a>
          <ul>
            <li><a href="#VarSetCapacity">VarSetCapacity</a></li>
            <li><a href="#DllCall">DllCall</a></li>
            <li><a href="#NumPutGet">NumPut / NumGet</a></li>
          </ul>
        </li>
        <li><a href="#ptr">Pointer-Gr&ouml;&szlig;e</a></li>
      </ul>
      <h2 id="Basic">Grundlagen</h2>
      <h3 id="Syntax_Errors">Syntaxfehler</h3>
      <p>Bestimmte Syntaxfehler, die in AutoHotkey Basic toleriert wurden, werden in AutoHotkey_L nicht l&auml;nger toleriert. Viele solcher Fehler k&ouml;nnen einfach korrigiert werden, sobald sie identifiziert werden. Die folgenden Fehler werden beim Starten eines Scripts in AutoHotkey_L sofort erkannt, und m&uuml;ssen korrigiert werden, bevor das Script ausgef&uuml;hrt werden kann:</p>
      <ul>
        <li>Zwischen jedem Befehl und dessen Parametern ist ein Leerzeichen, Tabulatorzeichen oder Komma notwendig. Zum Beispiel werden <code>MsgBox&lt; foo</code> und <code>If!foo</code> nicht toleriert.</li>
        <li><code>Hotkey, If<i>Irgendetwas</i></code>, bei dem <i>Irgendetwas</i> ung&uuml;ltig ist, wird nicht toleriert.</li>
      </ul>
      <p>Andere Syntaxfehler werden beim Ausf&uuml;hren des Scripts erkannt. Solche Fehler bewirken, dass eine Fehlermeldung angezeigt wird, bevor der aktuelle Thread endet:</p>
      <ul>
        <li><strong>H&auml;ufig:</strong> Unbekannte oder schlecht formatierte Optionen innerhalb von <a href="commands/Gui.htm#Options">Gui</a>, <a href="commands/Gui.htm#Show">Gui Show</a> oder <a href="commands/GuiControl.htm">GuiControl</a>.</li>
        <li>GroupAdd mit einem leeren Gruppennamen. Vorher bewirkte dieser Fehler, dass der Thread <em>automatisch</em> beendet wurde.</li>
        <li>Die Gui-Option <a href="commands/Gui.htm#LastFoundExist">+LastFoundExist</a> darf nicht mit einer anderen Option kombiniert werden, weil das dazu f&uuml;hren w&uuml;rde, dass diese sich wie <a href="commands/Gui.htm#LastFound">+LastFound</a> verh&auml;lt.</li>
      </ul>
      <p>Andere Syntaxfehler werden zurzeit nicht erkannt, k&ouml;nnen aber Probleme mit AutoHotkey_L verursachen:</p>
      <ul>
        <li><a href="Variables.htm#concat">Auto-Verkettung</a> mit <code>(</code> ist selektiver, folglich werden einige Ausdr&uuml;cke wie <code>12(34)</code> nicht l&auml;nger funktionieren.</li>
      </ul>
      <h3 id="FileRead">FileRead</h3>
      <p><a href="commands/FileRead.htm#Binary">FileRead</a> wandelt den Zeichensatz des Textes in bestimmten F&auml;llen um, wodurch unbrauchbare Bin&auml;rdaten entstehen k&ouml;nnen. Um das zu verhindern, kann die <code>*c</code>-Option hinzugef&uuml;gt oder stattdessen <a href="commands/FileOpen.htm">FileOpen</a> verwendet werden.</p>
      <h3 id="Names">Variablen- und Funktionsnamen</h3>
      <p>Die Zeichen <code>[</code>, <code>]</code> und <code>?</code> sind f&uuml;r <a href="Variables.htm#Expressions">Ausdr&uuml;cke</a> reserviert und daher nicht l&auml;nger in Variablennamen g&uuml;ltig. Folglich ben&ouml;tigt <code>?</code> (das f&uuml;r tern&auml;ren Operationen gilt) nicht l&auml;nger ein Leerzeichen auf jeder Seite. Siehe auch <a href="Objects.htm#Usage">Objektsyntax</a>.</p>
      <p>Fehler k&ouml;nnen oder k&ouml;nnen nicht automatisch erkannt werden:</p>
      <ul>
        <li>Falls ein Script solche Zeichen in Variablennamen innerhalb eines Ausdrucks verwendet, wird das Script ohne Fehlermeldung ausgef&uuml;hrt, aber sich falsch verhalten, da diese Zeichen als Operatoren interpretiert werden, anstatt als Teil eines Variablennamens.
          </p>
        </li>
        <li>Falls diese Zeichen in einer <a href="Variables.htm#ref">Doppelderefenzierung</a> verwendet werden (z. B. <code>Array%n%</code>, bei der <em>n</em> eins der oben genannten Zeichen enth&auml;lt), wird eine Fehlermeldung angezeigt, sobald die Doppeldereferenzierung beim Ausf&uuml;hren des Scripts ausgewertet wird.</li>
        <li>Falls diese Zeichen in einem anderen Kontext verwendet werden (zum Beispiel auf der linken Seite einer Zuweisung, im Namen der Eingabe-/Ausgabevariable eines Befehls oder zwischen %Prozentzeichen%), wird eine Fehlermeldung angezeigt und der Start des Scripts verhindert.</li>
      </ul>
      <h3 id="Transform">Transform</h3>
      <p>In den Unicode-Versionen von AutoHotkey_L wurden einige Unterbefehle von <i>Transform</i> ge&auml;ndert oder entfernt:</p>
      <ul>
        <li><a href="commands/Transform.htm#Unicode">Transform, Unicode</a> ist nicht mehr verf&uuml;gbar. Um der Zwischenablage ein Unicode-Text zuzuweisen, sollte eine normale Zuweisung verwendet werden. Siehe auch: <a href="commands/StrPutGet.htm">StrPut/StrGet</a>.</li>
        <li><a href="commands/Transform.htm#HTML">Transform, HTML</a> unterst&uuml;tzt <a href="commands/Transform.htm#HTML">zus&auml;tzliche Features</a>.</li>
      </ul>
      <h3 id="Default_Script">Standard-Script</h3>
      <p>Falls AutoHotkey_L gestart wird, ohne dass ein Script angegeben wurde, wird standardm&auml;&szlig;ig eine .ahk-Datei geladen, anstatt eine .ini-Datei. Der Name dieser Datei beruht auf dem Dateinamen der aktuell ausf&uuml;hrbaren Datei. Weitere Details k&ouml;nnen in "<a href="Scripts.htm#cmd">Befehlszeilenparameter an ein Script &uuml;bergeben</a>" gefunden werden.</p>
      <h3 id="SetFormat">SetFormat, Integer[Fast], H</h3>
      <p>Sobald ein gro&szlig;geschriebenes H verwendet wird, sind die hexadezimale Zeichen A-F auch in Gro&szlig;buchstaben. AutoHotkey Basic verwendet hingegen immer kleingeschriebene Zeichen. Siehe <a href="commands/SetFormat.htm">SetFormat</a>.</p>
      <h3 id="LastError">A_LastError</h3>
      <p>Die folgenden Befehle setzen nun <a href="Variables.htm#LastError">A_LastError</a>, um das Debuggen zu unterst&uuml;tzen: FileAppend, FileRead, FileReadLine, FileDelete, FileCopy, FileMove, FileGetAttrib/Time/Size/Version, FileSetAttrib/Time, FileCreateDir, RegRead, RegWrite, RegDelete. Das Verwenden einer dieser Befehle bewirkt, dass der vorherige Wert von A_LastError &uuml;berschrieben wird.</p>
      <h3 id="MsgBox">MsgBox</h3>
      <p>Die intelligente Kommahandhabung der <a href="commands/MsgBox.htm">MsgBox</a> wurde ge&auml;ndert, um die Flexibilit&auml;t und Konsistenz mit allen anderen Befehlen zu verbessern. In den meisten F&auml;llen verh&auml;lt sich die MsgBox wie erwartet. In einigen seltenen F&auml;llen sind bei Scripts, die auf das alte fehlerbehaftete Verhalten basieren, &Auml;nderungen bzgl. des Verhaltens festzustellen. Zum Beispiel:</p>
      <pre><em>; Das folgende wird nun als Ausdruck (Optionen) gefolgt von Text (Titel) interpretiert,
; anstatt als einzelner Ausdruck (Text) mit mehreren <a href="Variables.htm#comma">Teilausdr&uuml;cken</a>:</em>
MsgBox % x, y
<em>; Runde Klammern k&ouml;nnen hinzugef&uuml;gt werden, um die alte Interpretation zu erzwingen:</em>
MsgBox % (x, y)

<em>; Das folgende zeigt nun ein leeres Dialogfenster an, anstatt den Text "0, Titel":</em>
MsgBox 0, Titel
<em>; Das folgende verh&auml;lt sich sowohl in AutoHotkey_L als auch in AutoHotkey Basic wie erwartet:</em>
MsgBox 0, Titel, % ""   <em>; Zeigt ein leeres Dialogfenster</em>
MsgBox 0`, Titel        <em>; Zeigt den Text "0, Titel"</em>

<em>; Das folgende zeigt nun ein leeres Dialogfenster an, anstatt den Text ", Titel":</em>
MsgBox,, Titel
	</pre>
      <h3 id="IfIs">If <em>Var</em> is <em>Typ</em></h3>
      <p><a href="commands/IfIs.htm">If <em>Var</em> is <em>Typ</em></a> ignoriert das Gebietsschema des Betriebssystems, sofern <code><a href="commands/StringCaseSense.htm">StringCaseSense, Locale</a></code> nicht verwendet wird.</p>
      <h3 id="Window_Groups">Fenstergruppen</h3>
      <p><a href="commands/GroupActivate.htm">GroupActivate</a> setzt ErrorLevel auf 1, falls kein Fenster zum Aktivieren gefunden wurde, ansonsten auf 0. Vorher wurde ErrorLevel nicht gesetzt.</p>
      <p>Die Parameter des <a href="commands/GroupAdd.htm">GroupAdd</a>-<em>Labels</em> gelten f&uuml;r die Fenstergruppe als Ganzes, anstatt f&uuml;r eine bestimmte Fensterspezifikation innerhalb der Gruppe. Eine Diskussion zu dieser &Auml;nderung kann <a href="http://www.autohotkey.com/community/viewtopic.php?t=61362">im Forum</a> gefunden werden. Allerdings ist dieser Parameter <strong>nicht zu empfehlen</strong>; stattdessen sollte ErrorLevel nach dem Aufruf von GroupActivate &uuml;berpr&uuml;ft werden.</p>
      <h3 id="Run">Run / RunWait</h3>
      <p>AutoHotkey_L beinhaltet einige Verbesserungen in der Hinsicht, wie die Befehle <a href="commands/Run.htm">Run</a> und <a href="commands/Run.htm">RunWait</a> den <em>Ziel</em>-Parameter interpretieren. Dadurch werden Dinge erm&ouml;glich, die zuvor nicht m&ouml;glich waren, aber in einigen seltenen F&auml;llen dazu f&uuml;hren k&ouml;nnen, Scripts zu beeinflussen, die bereits in AutoHotkey Basic funktionierten. Das neue Verhalten ist wie folgt:</p>
      <ul>
        <li>Wenn <i>Ziel</i> mit einem Anf&uuml;hrungszeichen beginnt, wird alles nach dem Anf&uuml;hrungszeichen als Aktion angesehen.</li>
        <li>Ansonsten wird der erste Teilstring, der mit einem Leerzeichen endet und weder eine vorhandene Datei ist noch mit .exe, .bat, .com, .cmd oder .hta endet, als Aktion angesehen. Dadurch k&ouml;nnen Dateitypen wie .ahk, .vbs oder .lnk auch Parameter akzeptieren, w&auml;hrend "bekannte" ausf&uuml;hrbare Dateien wie wordpad.exe weiterhin ohne absoluten Pfad ausgef&uuml;hrt werden k&ouml;nnen.</li>
      </ul>
      <h3 id="ControlZ">Steuerung-Z</h3>
      <p><a href="commands/LoopReadFile.htm">Loop Read</a> und <a href="commands/FileReadLine.htm">FileReadLine</a> interpretieren das Zeichen Steuerung-Z (0x1A) nicht l&auml;nger als Dateiendemarke (end-of-file marker). Jedes Steuerung-Z (auch das, dass am Ende der Datei vorkommt), wird so geladen, wie es ist. <a href="commands/FileRead.htm">FileRead</a> ignoriert bereits dieses Zeichen und ist deshalb von diesem Problem nicht betroffen.</p>
      <h3 id="Compatibility_Mode">Kompatibilit&auml;tsmodus</h3>
      <p>Es ist m&ouml;glich, dass sich das Script nicht richtig verh&auml;lt, wenn der <a href="http://de.wikipedia.org/wiki/Kompatibilit&auml;tsmodus">Kompatibilit&auml;tsmodus</a> in den Eigenschaften der EXE-Datei auf Windows 95, NT4 oder 98/ME gesetzt wird. Das liegt daran, dass der Kompatibilit&auml;tsmodus der Anwendung eine bestimmte Windows-Version meldet, die von AutoHotkey_L nicht unterst&uuml;tzt wird. Zum Beispiel bewirkt das Setzen des Kompatibilit&auml;tsmodus auf Windows 95 oder 98/ME, dass <code>MsgBox %A_OSVersion%</code> den String <code>WIN_NT4</code> melden wird.</p>
      <h3 id="IsCompiled">A_IsCompiled</h3>
      <p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> enth&auml;lt einen leeren String, wenn das Script nicht kompiliert wurde. Vorher wurde es nicht definiert, dass zur Folge hatte, dass Zuweisungen wie <code>A_IsCompiled := 1</code> g&uuml;ltig waren, wenn das Script nicht kompiliert wurde. Jetzt wird es in jeder Hinsicht als schreibgesch&uuml;tzte interne Variable behandelt.</p>
      <h3 id="Escaped_Whitespace">Gesch&uuml;tzte unsichtbare Zeichen</h3>
      <p>Gesch&uuml;tzte unsichtbare Zeichen wie <code>`t</code> und <code>` </code>&nbsp;werden nicht l&auml;nger am Anfang oder am Ende eines Arguments verworfen. Zum Beispiel ist <code>StringReplace s, s, `t</code> nun g&uuml;ltig und wird alle Tabulatorzeichen in <em>s</em> entfernen.</p>
      <h2 id="Format">Unicode vs. ANSI</h2>
      <p>Jeder Textwert, der vom Script bearbeitet wird, wird als Zeichenfolge bzw. <em>String</em> gespeichert. Der numerische Wert und die Gr&ouml;&szlig;e eines Zeichens ist abh&auml;ngig davon, welche Version von AutoHotkey zurzeit verwendet wird: <i>Unicode</i> oder <i>ANSI</i>. Solche Details sind normalerweise f&uuml;r Scripts wichtig, die folgendes machen:</p>
      <ul>
        <li>Strings mithilfe von <a href="#DllCall">DllCall</a> an externe Funktionen &uuml;bergeben.</li>
        <li>Strings mithilfe von <a href="commands/PostMessage.htm">PostMessage/SendMessage</a> &uuml;bergeben.</li>
        <li>Strings direkt mit <a href="#NumPutGet">NumPut/NumGet</a> manipulieren.</li>
        <li><a href="#VarSetCapacity">VarSetCapacity</a> verwenden, um sicherzustellen, dass eine Variable eine bestimmte Anzahl an Zeichen enthalten kann.</li>
      </ul>
      <p>Scripts, die nur f&uuml;r ein bestimmtes Format gedacht waren, werden oft auf Probleme sto&szlig;en, wenn diese mit der falschen AutoHotkey-Version laufen. Zum Beispiel werden einige Scripts, die f&uuml;r AutoHotkey Basic geschrieben wurden, korrekt mit der ANSI-Version von AutoHotkey_L funktionieren, aber mit den Unicode-Versionen jedoch nicht. Wenn du dir nicht sicher bist, welche Version zurzeit verwendet wird, kannst du folgenden Script ausf&uuml;hren:</p>
      <pre>MsgBox % <a href="Variables.htm#IsUnicode">A_IsUnicode</a> ? "Unicode" : "ANSI"</pre>
      <p><strong>ANSI:</strong> Jedes Zeichen ist <strong>ein Byte</strong> gro&szlig; (8 Bits). Zeichencodes &uuml;ber 127 sind von den Spracheinstellungen deines Systems abh&auml;ngig.</p>
      <p><strong>Unicode:</strong> Jedes Zeichen ist <strong>zwei Bytes</strong> gro&szlig; (16 Bits). Zeichencodes sind die vom <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>-Format.</p>
      <p class="Indent"><em>Semantischer Hinweis:</em> Technisch gesehen sind einige Unicode-Zeichen durch <i>zwei</i> 16-Bit-Code-Einheiten vertreten, auch allgemein bekannt als "Ersatzzeichenpaar" (surrogate pair). Ebenso enthalten einige <a href="http://msdn.microsoft.com/en-us/library/dd317752.aspx">ANSI-Zeichens&auml;tze</a> (allgemein bekannt als <a href="http://msdn.microsoft.com/en-us/library/dd317794.aspx">Doppel-Byte-Zeichens&auml;tze</a>) einige Doppel-Byte-Zeichen. Allerdings werden solche aus praktischen Gr&uuml;nden fast immer als zwei einzelne Einheiten (bzw. Zeichen) behandelt.</p>
      <h3 id="VarSetCapacity">VarSetCapacity</h3>
      <p>VarSetCapacity bestimmt die Kapazit&auml;t einer Variable <i>in Bytes</i>. Um die Kapazit&auml;t einer Variable in Bezug auf die Zeichenanzahl zu setzen, muss die Gr&ouml;&szlig;e eines Zeichens ber&uuml;cksichtigt werden. Zum Beispiel:</p>
      <pre>VarSetCapacity(ansi_var,    capacity_in_chars)
VarSetCapacity(unicode_var, capacity_in_chars * 2)
VarSetCapacity(native_var,  capacity_in_chars * (A_IsUnicode ? 2 : 1))
VarSetCapacity(native_var,  t_size(capacity_in_chars))  <em>; siehe <a href="#NumPutGet">unten</a></em>
</pre>
      <p>Es gibt zwei Anwendungsm&ouml;glichkeiten f&uuml;r VarSetCapacity:</p>
      <ol>
        <li>Eine Variable auf eine ungef&auml;hre Anzahl an Zeichen erweitern, um die Performance bei der schrittweisen Verkettung eines Strings zu verbessern. Zum Beispiel kann mit <code>VarSetCapacity(var, 1000)</code> 1000 Bytes erm&ouml;glicht werden, das in den Unicode-Versionen von AutoHotkey_L nur 500 Zeichen sind. Das k&ouml;nnte Einfluss auf die Performance haben, aber das Script selbst sollte weiterhin normal funktionieren.</li>
        <li>Die Gr&ouml;&szlig;e einer Variable f&uuml;r eine Bin&auml;rstruktur anpassen. Falls die Struktur direkt Text enth&auml;lt, muss das Format des Textes ber&uuml;cksichtigt werden. Das ist abh&auml;ngig von der Struktur - manchmal wird ANSI-Text verwendet, auch in einer Unicode-Version von AutoHotkey_L. Wenn die Variable zu klein ist, kann es passieren, dass das Script abst&uuml;rzt oder sich ansonsten unvorhersehbar verh&auml;lt (abh&auml;ngig davon, wie die Struktur verwendet wird).</li>
      </ol>
      <h3 id="DllCall">DllCall</h3>
      <p>Der "Str"-Typ, falls vorhanden, kennzeichnet einen String im urspr&uuml;nglichen Format der aktuellen Version. Da einige Funktionen m&ouml;glicherweise Strings in einem bestimmten Format ben&ouml;tigen oder zur&uuml;ckgeben, stehen folgende Stringtypen zur Verf&uuml;gung:</p>
      <table class="info">
        <tr>
          <th></th>
          <th>Zeichengr&ouml;&szlig;e</th>
          <th>C / Win32-Typen</th>
          <th>Kodierung</th>
        </tr>
        <tr>
          <td class="Syntax" style="text-align:center">WStr</td>
          <td style="text-align:center">16-Bit</td>
          <td>wchar_t*, WCHAR*, LPWSTR, LPCWSTR</td>
          <td>UTF-16</td>
        </tr>
        <tr>
          <td class="Syntax" style="text-align:center">AStr</td>
          <td style="text-align:center">8-Bit</td>
          <td>char*, CHAR*, LPSTR, LPCSTR</td>
          <td>ANSI (der Standard-ANSI-Zeichensatz des Systems)</td>
        </tr>
        <tr>
          <td class="Syntax" style="text-align:center">Str</td>
          <td style="text-align:center">--</td>
          <td>TCHAR*, LPTSTR, LPCTSTR</td>
          <td>Entspricht <b>WStr</b> in Unicode-Versionen und <b>Astr</b> in ANSI-Versionen.</td>
        </tr>
      </table>
      <br>
      <p>Sobald "Str" oder das Gegenst&uuml;ck der aktuellen Version als Parameter verwendet wird, wird die Adresse des Strings oder der Variable an die Funktion &uuml;bergeben, ansonsten wird stattdessen eine tempor&auml;re Kopie des Strings im gew&uuml;nschten Format erstellt und &uuml;bergeben. Als allgemeine Regel gilt, dass "AStr" und "WStr" nicht verwendet werden sollten, wenn die Funktion einen Wert in diesen Parameter schreibt.</p>
      <p><b>Hinweis:</b> "AStr" und "WStr" gelten sowohl f&uuml;r Parameter als auch f&uuml;r den R&uuml;ckgabewert einer Funktion.</p>
      <p>Wenn ein Script &uuml;ber DllCall eine Funktion aufruft, die einen String als Parameter akzeptiert, muss eins der folgenden Ans&auml;tze ber&uuml;cksichtigt werden:</p>
      <ol>
        <li>Existiert sowohl eine Unicode- (W) als auch ANSI-Version (A) von der Funktion, sollte die jeweils aufgerufen werden, die zur aktuellen AutoHotkey_L-Version passt. Im folgenden Beispiel ist "DeleteFile" intern als "DeleteFileA" oder "DeleteFileW" bekannt. Da "DeleteFile" selbst nicht wirklich existiert, versucht DllCall automatisch, "A" oder "W" je nach aktuelle Version zu setzen:
          <pre>DllCall("DeleteFile", "Ptr", &amp;Dateiname)
DllCall("DeleteFile", "Str", Dateiname)</pre>
          <p>In diesem Beispiel wird <code>&amp;Dateiname</code> die Adresse des Strings so &uuml;bergeben, wie sie ist, damit die Funktion einen String im gleichen Format wie der "Str"-Typ erwarten muss. Beachte, dass in AutoHotkey Basic "UInt" anstelle von "Ptr" verwendet werden muss, aber der resultierende Code m&ouml;glicherweise nicht 64-Bit-kompatibel ist.
          
          <p><b>Hinweis:</b> Wenn die angegebene Funktion nicht sofort gefunden werden kann, wird AutoHotkey_L das "A"- oder "W"-Suffix anf&uuml;gen, unabh&auml;ngig davon, welche DLL angegeben wurde. AutoHotkey Basic hingegen wird den "A"-Suffix nur bei Funktionen anf&uuml;gen, die in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll vorkommen.</p>
        </li>
        <li>Wenn die Funktion nur einen bestimmten Stringtyp als Eingabevariable akzeptiert, k&ouml;nnte das Script jeweils den passenden Stringtyp verwenden:
          <pre>DllCall("DeleteFileA", "AStr", Dateiname)
DllCall("DeleteFileW", "WStr", Dateiname)</pre>
        </li>
        <li>Wenn die Funktion einen String modifizieren muss (in einem nicht-nativen Format), muss das Script einen Puffer wie <a href="#VarSetCapacity">oben</a> beschrieben bereitstellen und dessen Adresse an die Funktion &uuml;bergeben. Wenn der Parameter eine Eingabevariable akzeptiert, muss das Script den Eingabestring zudem in das passende Format umwandeln - mithilfe von <a href="commands/StrPutGet.htm">StrPut</a>.</li>
      </ol>
      <h3 id="NumPutGet">NumPut / NumGet</h3>
      <p>Wenn NumPut oder NumGet mit Strings verwendet werden, muss der Offset und Typ f&uuml;r den angegeben Stringtyp korrekt sein. Das folgende Beispiel dient als Veranschaulichung:</p>
      <pre><em>;  8-Bit/ANSI   Strings:  size_of_char=1  type_of_char="Char"
; 16-Bit/UTF-16 Strings:  size_of_char=2  type_of_char="UShort"</em>
<i>n</i>th_char := NumGet(var, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)
NumPut(<i>n</i>th_char, var, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)</pre>
      <p>Wenn <code>var</code> einen String im urspr&uuml;nglichen Format enth&auml;lt, k&ouml;nnen die passende Werte auf Basis von <code>A_IsUnicode</code> bestimmt werden:</p>
      <pre><i>n</i>th_char := NumGet(var, t_size(<i>n</i>-1), t_char())
NumPut(<i>n</i>th_char, var, t_size(<i>n</i>-1), t_char())

<em>; F&uuml;r Komfort und &Uuml;bersichtlichkeit Funktionen definieren:</em>
t_char() {
    Return A_IsUnicode ? "UShort" : "Char"
}
t_size(char_count=1) {
    Return A_IsUnicode ? char_count : char_count*2
}</pre>
      <h2 id="ptr">Pointer-Gr&ouml;&szlig;e</h2>
      <p>Pointer haben in 32-Bit-Versionen (einschlie&szlig;lich AutoHotkey Basic) eine Gr&ouml;&szlig;e von 4 Bytes und in in 64-Bit-Versionen eine Gr&ouml;&szlig;e von 8 Bytes. Scripts, die Strukturen oder DllCalls verwenden, sollten diese Sache ber&uuml;cksichtigen, damit sie auf beiden Plattformen richtig funktionieren. Bestimmte Bereiche, die auch betroffen sind:</p>
      <ul>
        <li>Offset-Berechnung bei Strukturfeldern, die ein oder mehr Pointer enthalten.</li>
        <li>Gr&ouml;&szlig;enberechnung bei Strukturen, die ein oder mehr Pointer enthalten.</li>
        <li>Typennamen, die mit <a href="commands/DllCall.htm">DllCall</a>, <a href="Functions.htm#NumPut">NumPut</a> oder <a href="Functions.htm#NumGet">NumGet</a> verwendet werden.</li>
      </ul>
      <p>Zur Berechnung der Gr&ouml;&szlig;e und des Offsets kann <a href="Variables.htm#PtrSize">A_PtrSize</a> verwendet werden. F&uuml;r DllCall, NumPut und NumGet je nach Bedarf den <a href="commands/DllCall.htm">Ptr</a>-Typ.</p>
      <p>Denk daran, dass der Offset eines Felds &uuml;blicherweise die Gesamtgr&ouml;&szlig;e aller vorherigen Felder ist. Beachte zudem, dass Handles (einschlie&szlig;lich Typen wie HWND und HBITMAP) im Grunde Pointer-Typen sind.</p>
      <pre><em>/*
  typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Ptr
    HANDLE hThread;
    DWORD  dwProcessId; // UInt (4 Bytes)
    DWORD  dwThreadId;
  } <a href="http://msdn.microsoft.com/en-us/library/ms684873.aspx">PROCESS_INFORMATION</a>, *LPPROCESS_INFORMATION;
*/</em>
VarSetCapacity(pi, A_PtrSize*2 + 8) <em>; Ptr + Ptr + UInt + UInt</em>
DllCall("<a href="http://msdn.microsoft.com/en-us/library/ms682425.aspx">CreateProcess</a>", <span class="dull">&lt;gek&uuml;rzt&gt;</span>, "Ptr", &amp;pi, <span class="dull">&lt;gek&uuml;rzt&gt;</span>)
hProcess    := NumGet(pi, 0)         <em>; Standardm&auml;&szlig;ig "Ptr".</em>
hThread     := NumGet(pi, A_PtrSize) <em>; </em>
dwProcessId := NumGet(pi, A_PtrSize*2,     "UInt")
dwProcessId := NumGet(pi, A_PtrSize*2 + 4, "UInt")

</pre>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(0);</script>
</body>
</html>