<!DOCTYPE HTML>
<html>
<head>
<title>Script-Kompatibilität</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<link href="static/font.css" rel="stylesheet" type="text/css" />
<script src="static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="static/html5.js"></script>
<![endif]-->
<script src="navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(0);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Script-Kompatibilität</h1>
      <p>Normalerweise müssen viele Scripts, die für AutoHotkey 1.0 geschrieben wurden, nicht geändert werden, um auch für AutoHotkey 1.1 lauffähig zu sein. Allerdings kann es aufgrund von notwendigen Unterschieden zwischen den beiden Versionen passieren, dass einige davon nicht richtig funktionieren. Die meisten Benutzer müssen sich keine Sorgen machen, da die besonders problematischen Unterschiede nur auf erweiterte Funktionalitäten wie DllCall zutreffen.</p>
      <p>AutoHotkey 1.1 ist auch unter den Namen "AutoHotkey_L" bekannt, während AutoHotkey 1.0 rückwirkend als "AutoHotkey Basic" bezeichnet wurde. Einige ältere Versionen von AutoHotkey_L verwenden als Versionsnummer 1.0.*, daher werden die zwei Entwicklungszweige von AutoHotkey der Klarheit halber per Namen genannt, anstatt per Versionsnummer.</p>
      <p class="note"><strong>Hinweis:</strong> Einige typische Probleme werden durch Änderungen bzgl. der Unterstützung für Unicode-Text verursacht und können verhindert werden, indem einfach die ANSI-Version von AutoHotkey_L verwendet wird.</p>
      <h3>Grundlagen</h3>
      <p>Hohe Auswirkung:</p>
      <ul>
        <li><a href="#Syntax_Errors">Bestimmte Syntaxfehler werden nicht länger toleriert</a></li>
        <li><a href="#FileRead">FileRead könnte beschädigte Binärdaten zurückgeben</a></li>
        <li><a href="#Names">Variablen- und Funktionsnamen können nicht mehr [, ] oder ? enthalten</a></li>
      </ul>
      <p>Mittlere Auswirkung:</p>
      <ul>
        <li><a href="#Transform">Der <em>Unicode</em>-Unterbefehl von Transform ist in Unicode-Versionen nicht verfügbar</a></li>
        <li><a href="#Default_Script">AutoHotkey.ahk wird anstelle von AutoHotkey.ini ausgeführt</a></li>
        <li><a href="#SetFormat">SetFormat, Integer, <strong>H</strong> unterscheidet zwischen Groß- und Kleinschreibung</a></li>
        <li><a href="#LastError">A_LastError wird von noch mehr Befehlen geändert</a></li>
        <li><a href="#MsgBox">MsgBox behandelt Kommas konsequenter</a></li>
        <li><a href="#GuiOwner">Gui +Owner überschreibt zusätzliche Styles</a></li>
        <li><a href="#DPIScale">DPI-Skalierung ist für GUIs standardmäßig aktiviert</a></li>
        <li><a href="#VistaSound">SoundSet und SoundGet funktionieren besser in Vista und höher</a></li>
        <li><a href="#Tilde">Tilde (~) hat Einfluss darauf, wie benutzerdefinierte Modifikatortasten funktionieren</a></li>
        <li><a href="#ComboUpDown"><code>x &amp; y::</code> bewirkt, dass sowohl <code>x::</code> als auch <code>x up::</code> ausgelöst werden, sobald x losgelassen wird</a></li>
      </ul>
      <p>Niedrige Auswirkung:</p>
      <ul>
        <li><a href="#IfIs">If <em>Var</em> is <em>Typ</em> ignoriert standardmäßig das Gebietsschema des Betriebssystems</a></li>
        <li><a href="#Window_Groups">GroupActivate setzt ErrorLevel; <em>Label</em> von GroupAdd funktioniert anders</a></li>
        <li><a href="#Run">Run und RunWait interpretieren das <em>Ziel</em> anders</a></li>
        <li><a href="#ControlZ">STRG+Z wird nicht als EOF (End of File) interpretiert</a></li>
        <li><a href="#Compatibility_Mode">Der Kompatibilitätsmodus könnte Verwirrung stiften</a></li>
        <li><a href="#IsCompiled">A_IsCompiled ist immer schreibgeschützt</a></li>
        <li><a href="#Escaped_Whitespace">Führende und nachfolgende `t-Sequenzen werden nicht länger verworfen</a></li>
      </ul>
      <h3>Erweitert</h3>
      <ul>
        <li><a href="#Format">Unicode vs. ANSI</a>
        <ul>
          <li><a href="#VarSetCapacity">VarSetCapacity</a></li>
          <li><a href="#DllCall">DllCall</a></li>
          <li><a href="#NumPutGet">NumPut / NumGet</a></li>
        </ul>
        </li>
        <li><a href="#ptr">Pointer-Größe</a></li>
      </ul>
      <h2 id="Basic">Grundlagen</h2>
      <h3 id="Syntax_Errors">Syntaxfehler</h3>
      <p>Bestimmte Syntaxfehler, die in AutoHotkey Basic toleriert wurden, werden in AutoHotkey_L nicht länger toleriert. Viele solcher Fehler können einfach korrigiert werden, sobald sie identifiziert werden. Die folgenden Fehler werden beim Starten eines Scripts in AutoHotkey_L sofort erkannt, und müssen korrigiert werden, bevor das Script ausgeführt werden kann:</p>
      <ul>
        <li>Zwischen jedem Befehl und dessen Parametern ist ein Leerzeichen, Tabulatorzeichen oder Komma notwendig. Zum Beispiel werden <code>MsgBox&lt; foo</code> und <code>If!foo</code> nicht toleriert.</li>
        <li><code>Hotkey, If<i>Irgendetwas</i></code>, bei dem <i>Irgendetwas</i> ungültig ist, wird nicht toleriert.</li>
      </ul>
      <p>Andere Syntaxfehler werden beim Ausführen des Scripts erkannt. Solche Fehler bewirken, dass eine Fehlermeldung angezeigt wird, bevor der aktuelle Thread endet:</p>
      <ul>
        <li><strong>Häufig:</strong> Unbekannte oder schlecht formatierte Optionen innerhalb von <a href="commands/Gui.htm#Options">Gui</a>, <a href="commands/Gui.htm#Show">Gui Show</a> oder <a href="commands/GuiControl.htm">GuiControl</a>.</li>
        <li>GroupAdd mit einem leeren Gruppennamen. Vorher bewirkte dieser Fehler, dass der Thread <em>automatisch</em> beendet wurde.</li>
        <li>Die Gui-Option <a href="commands/Gui.htm#LastFoundExist">+LastFoundExist</a> darf nicht mit einer anderen Option kombiniert werden, weil das dazu führen würde, dass diese sich wie <a href="commands/Gui.htm#LastFound">+LastFound</a> verhält.</li>
      </ul>
      <p>Andere Syntaxfehler werden zurzeit nicht erkannt, können aber Probleme mit AutoHotkey_L verursachen:</p>
      <ul>
        <li><a href="Variables.htm#concat">Auto-Verkettung</a> mit <code>(</code> ist selektiver, folglich werden einige Ausdrücke wie <code>12(34)</code> nicht länger funktionieren.</li>
      </ul>
      <h3 id="FileRead">FileRead</h3>
      <p><a href="commands/FileRead.htm#Binary">FileRead</a> wandelt den Zeichensatz des Textes in bestimmten Fällen um, wodurch unbrauchbare Binärdaten entstehen können. Um das zu verhindern, kann die <code>*c</code>-Option hinzugefügt oder stattdessen <a href="commands/FileOpen.htm">FileOpen</a> verwendet werden.</p>
      <h3 id="Names">Variablen- und Funktionsnamen</h3>
      <p>Die Zeichen <code>[</code>, <code>]</code> und <code>?</code> sind für <a href="Variables.htm#Expressions">Ausdrücke</a> reserviert und daher nicht länger in Variablennamen gültig. Folglich benötigt <code>?</code> (das für ternären Operationen gilt) nicht länger ein Leerzeichen auf jeder Seite. Siehe auch <a href="Objects.htm#Usage">Objektsyntax</a>.</p>
      <p>Fehler können oder können nicht automatisch erkannt werden:</p>
      <ul>
        <li>Falls ein Script solche Zeichen in Variablennamen innerhalb eines Ausdrucks verwendet, wird das Script ohne Fehlermeldung ausgeführt, aber sich falsch verhalten, da diese Zeichen als Operatoren interpretiert werden, anstatt als Teil eines Variablennamens.</li>
        <li>Falls diese Zeichen in einer <a href="Variables.htm#ref">Doppelderefenzierung</a> verwendet werden (z. B. <code>Array%n%</code>, bei der <em>n</em> eins der oben genannten Zeichen enthält), wird eine Fehlermeldung angezeigt, sobald die Doppeldereferenzierung beim Ausführen des Scripts ausgewertet wird.</li>
        <li>Falls diese Zeichen in einem anderen Kontext verwendet werden (zum Beispiel auf der linken Seite einer Zuweisung, im Namen der Eingabe-/Ausgabevariable eines Befehls oder zwischen %Prozentzeichen%), wird eine Fehlermeldung angezeigt und der Start des Scripts verhindert.</li>
      </ul>
      <h3 id="Transform">Transform</h3>
      <p>In den Unicode-Versionen von AutoHotkey_L wurden einige Unterbefehle von <i>Transform</i> geändert oder entfernt:</p>
      <ul>
        <li><a href="commands/Transform.htm#Unicode">Transform, Unicode</a> ist nicht mehr verfügbar. Um der Zwischenablage ein Unicode-Text zuzuweisen, sollte eine normale Zuweisung verwendet werden. Siehe auch: <a href="commands/StrPutGet.htm">StrPut/StrGet</a>.</li>
        <li><a href="commands/Transform.htm#HTML">Transform, HTML</a> unterstützt <a href="commands/Transform.htm#HTML">zusätzliche Features</a>.</li>
      </ul>
      <h3 id="Default_Script">Standard-Script</h3>
      <p>Falls AutoHotkey_L gestartet wird, ohne dass ein Script angegeben wurde, wird standardmäßig eine .ahk-Datei geladen, anstatt eine .ini-Datei. Der Name dieser Datei beruht auf dem Dateinamen der aktuell ausführbaren Datei. Weitere Details können in "<a href="Scripts.htm#cmd">Befehlszeilenparameter an ein Script übergeben</a>" gefunden werden.</p>
      <h3 id="SetFormat">SetFormat, Integer[Fast], H</h3>
      <p>Sobald ein großgeschriebenes H verwendet wird, sind die hexadezimale Zeichen A-F auch in Großbuchstaben. AutoHotkey Basic verwendet hingegen immer kleingeschriebene Zeichen. Siehe <a href="commands/SetFormat.htm">SetFormat</a>.</p>
      <h3 id="LastError">A_LastError</h3>
      <p>Die folgenden Befehle setzen nun <a href="Variables.htm#LastError">A_LastError</a>, um das Debuggen zu unterstützen: FileAppend, FileRead, FileReadLine, FileDelete, FileCopy, FileMove, FileGetAttrib/Time/Size/Version, FileSetAttrib/Time, FileCreateDir, RegRead, RegWrite, RegDelete. Das Verwenden einer dieser Befehle bewirkt, dass der vorherige Wert von A_LastError überschrieben wird.</p>
      <h3 id="MsgBox">MsgBox</h3>
      <p>Die intelligente Kommahandhabung der <a href="commands/MsgBox.htm">MsgBox</a> wurde geändert, um die Flexibilität und Konsistenz mit allen anderen Befehlen zu verbessern. In den meisten Fällen verhält sich die MsgBox wie erwartet. In einigen seltenen Fällen sind bei Scripts, die auf das alte fehlerbehaftete Verhalten basieren, Änderungen bzgl. des Verhaltens festzustellen. Zum Beispiel:</p>
      <pre><em>; Das folgende wird nun als Ausdruck (Optionen) gefolgt von Text (Titel) interpretiert,
; anstatt als einzelner Ausdruck (Text) mit mehreren <a href="Variables.htm#comma">Teilausdrücken</a>:</em>
MsgBox % x, y
<em>; Runde Klammern können hinzugefügt werden, um die alte Interpretation zu erzwingen:</em>
MsgBox % (x, y)

<em>; Das folgende zeigt nun ein leeres Dialogfenster an, anstatt den Text "0, Titel":</em>
MsgBox 0, Titel
<em>; Das folgende verhält sich sowohl in AutoHotkey_L als auch in AutoHotkey Basic wie erwartet:</em>
MsgBox 0, Titel, % ""   <em>; Zeigt ein leeres Dialogfenster</em>
MsgBox 0`, Titel        <em>; Zeigt den Text "0, Titel"</em>

<em>; Das folgende zeigt nun ein leeres Dialogfenster an, anstatt den Text ", Titel":</em>
MsgBox,, Titel
	</pre>
      <h3 id="GuiOwner">Gui +Owner</h3>
      <p>Sobald die Option <a href="commands/Gui.htm#Owner">+Owner</a> auf ein Gui angewendet wird, wird der WS_CHILD-Style entfernt und der WS_POPUP-Style gesetzt. Das kann Scripts negativ beeinflussen, die mit <code>+Owner</code> das übergeordnete Fenster setzten, <em>nachdem</em> die Styles festgelegt wurden.</p>
      <h3 id="DPIScale">DPI-Skalierung</h3>
      <p><a href="commands/Gui.htm#DPIScale">DPI-Skalierung</a> ist für GUIs standardmäßig aktiviert. Dies wird Scripts betreffen, wenn die DPI-Einstellung des Systems nicht 96 (100%) ist. Mit <code>Gui -DPIScale</code> kann die Skalierung deaktiviert werden.</p>
      <h3 id="VistaSound">Sound-Befehle in Windows Vista oder höher</h3>
      <p><a href="commands/SoundSet.htm">SoundSet</a>, <a href="commands/SoundGet.htm">SoundGet</a>, <a href="commands/SoundSetWaveVolume.htm">SoundSetWaveVolume</a> und <a href="commands/SoundGetWaveVolume.htm">SoundGetWaveVolume</a> werden in Windows Vista oder höher besser unterstützt. Typische Veränderungen im Verhalten sind:</p>
      <ul>
        <li>Scripts haben Auswirkungen auf das ganze System (so wie es sein soll), anstatt nur auf das Script selbst.</li>
        <li>Geräte werden unterschiedlich nummeriert - jeder Ausgang oder Eingang wird als seperates Gerät angesehen.</li>
      </ul>
      <h3 id="Tilde">Tilde (~) und Hotkeys mit benutzerdefinierten Tastenkombationen</h3>
      <p>Seit v1.1.14 hat das <a href="Hotkeys.htm#Tilde">Tilde-Präfix</a> Einfluss darauf, wie eine Taste funktioniert, wenn sie als Modifikatortaste in einer benutzerdefinierten Tastenkombination verwendet wird.</p>
      <h3 id="ComboUpDown">Benutzerdefinierte Tastenkombinationen und Down/Up-Hotkeys</h3>
      <p>Wenn ein KeyDown- und KeyUp-Hotkey für eine benutzerdefinierte Modifikatortaste definiert wurde, werden beide beim Loslassen der Taste ausgelöst (sofern das Tilde-Präfix nicht vorhanden ist). Zum Beispiel würde <code>x &amp; y::</code> bewirken, dass <code>x::</code> und <code>x up::</code> erst ausgelöst werden, wenn x losgelassen wird.</p>
      <h3 id="IfIs">If <em>Var</em> is <em>Typ</em></h3>
      <p><a href="commands/IfIs.htm">If <em>Var</em> is <em>Typ</em></a> ignoriert das Gebietsschema des Betriebssystems, sofern <code><a href="commands/StringCaseSense.htm">StringCaseSense, Locale</a></code> nicht verwendet wird.</p>
      <h3 id="Window_Groups">Fenstergruppen</h3>
      <p><a href="commands/GroupActivate.htm">GroupActivate</a> setzt ErrorLevel auf 1, falls kein Fenster zum Aktivieren gefunden wurde, ansonsten auf 0. Vorher wurde ErrorLevel nicht gesetzt.</p>
      <p>Die Parameter des <a href="commands/GroupAdd.htm">GroupAdd</a>-<em>Labels</em> gelten für die Fenstergruppe als Ganzes, anstatt für eine bestimmte Fensterspezifikation innerhalb der Gruppe. Eine Diskussion zu dieser Änderung kann <a href="http://www.autohotkey.com/community/viewtopic.php?t=61362">im Forum</a> gefunden werden. Allerdings ist dieser Parameter <strong>nicht zu empfehlen</strong>; stattdessen sollte ErrorLevel nach dem Aufruf von GroupActivate überprüft werden.</p>
      <h3 id="Run">Run / RunWait</h3>
      <p>AutoHotkey_L beinhaltet einige Verbesserungen in der Hinsicht, wie die Befehle <a href="commands/Run.htm">Run</a> und <a href="commands/Run.htm">RunWait</a> den <em>Ziel</em>-Parameter interpretieren. Dadurch werden Dinge ermöglich, die zuvor nicht möglich waren, aber in einigen seltenen Fällen dazu führen können, Scripts zu beeinflussen, die bereits in AutoHotkey Basic funktionierten. Das neue Verhalten ist wie folgt:</p>
      <ul>
        <li>Wenn <i>Ziel</i> mit einem Anführungszeichen beginnt, wird alles nach dem Anführungszeichen als Aktion angesehen.</li>
        <li>Ansonsten wird der erste Teilstring, der mit einem Leerzeichen endet und weder eine vorhandene Datei ist noch mit .exe, .bat, .com, .cmd oder .hta endet, als Aktion angesehen. Dadurch können Dateitypen wie .ahk, .vbs oder .lnk auch Parameter akzeptieren, während "bekannte" ausführbare Dateien wie wordpad.exe weiterhin ohne absoluten Pfad ausgeführt werden können.</li>
      </ul>
      <h3 id="ControlZ">STRG+Z</h3>
      <p><a href="commands/LoopReadFile.htm">Loop Read</a> und <a href="commands/FileReadLine.htm">FileReadLine</a> interpretieren das Zeichen STRG+Z (0x1A) nicht länger als Dateiendemarke (end-of-file marker). Jedes STRG+Z (auch das, dass am Ende der Datei vorkommt), wird so geladen, wie es ist. <a href="commands/FileRead.htm">FileRead</a> ignoriert bereits dieses Zeichen und ist deshalb von diesem Problem nicht betroffen.</p>
      <h3 id="Compatibility_Mode">Kompatibilitätsmodus</h3>
      <p>Es ist möglich, dass sich das Script nicht richtig verhält, wenn der <a href="http://de.wikipedia.org/wiki/Kompatibilitätsmodus">Kompatibilitätsmodus</a> in den Eigenschaften der EXE-Datei auf Windows 95, NT4 oder 98/ME gesetzt wird. Das liegt daran, dass der Kompatibilitätsmodus der Anwendung eine bestimmte Windows-Version meldet, die von AutoHotkey_L nicht unterstützt wird. Zum Beispiel bewirkt das Setzen des Kompatibilitätsmodus auf Windows 95 oder 98/ME, dass <code>MsgBox %A_OSVersion%</code> den String <code>WIN_NT4</code> melden wird.</p>
      <h3 id="IsCompiled">A_IsCompiled</h3>
      <p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> enthält einen leeren String, wenn das Script nicht kompiliert wurde. Vorher wurde es nicht definiert, dass zur Folge hatte, dass Zuweisungen wie <code>A_IsCompiled := 1</code> gültig waren, wenn das Script nicht kompiliert wurde. Jetzt wird es in jeder Hinsicht als schreibgeschützte interne Variable behandelt.</p>
      <h3 id="Escaped_Whitespace">Unsichtbare Zeichen mit einem Escapezeichen</h3>
      <p>Unsichtbare Zeichen mit einem Escapezeichen wie <code>`t</code> und <code>` </code>&nbsp;werden nicht länger am Anfang oder am Ende eines Arguments verworfen. Zum Beispiel ist <code>StringReplace s, s, `t</code> nun gültig und wird alle Tabulatorzeichen in <em>s</em> entfernen.</p>
      <h2 id="Format">Unicode vs. ANSI</h2>
      <p>Jeder Textwert, der vom Script bearbeitet wird, wird als Zeichenfolge bzw. <em>String</em> gespeichert. Der numerische Wert und die Größe eines Zeichens ist abhängig davon, welche Version von AutoHotkey zurzeit verwendet wird: <i>Unicode</i> oder <i>ANSI</i>. Solche Details sind normalerweise für Scripts wichtig, die folgendes machen:</p>
      <ul>
        <li>Strings mithilfe von <a href="#DllCall">DllCall</a> an externe Funktionen übergeben.</li>
        <li>Strings mithilfe von <a href="commands/PostMessage.htm">PostMessage/SendMessage</a> übergeben.</li>
        <li>Strings direkt mit <a href="#NumPutGet">NumPut/NumGet</a> manipulieren.</li>
        <li><a href="#VarSetCapacity">VarSetCapacity</a> verwenden, um sicherzustellen, dass eine Variable eine bestimmte Anzahl an Zeichen enthalten kann.</li>
      </ul>
      <p>Scripts, die nur für ein bestimmtes Format gedacht waren, werden oft auf Probleme stoßen, wenn diese mit der falschen AutoHotkey-Version laufen. Zum Beispiel werden einige Scripts, die für AutoHotkey Basic geschrieben wurden, korrekt mit der ANSI-Version von AutoHotkey_L funktionieren, aber nicht mit der Unicode-Version. Wenn man sich nicht sicher ist, welche Version zurzeit verwendet wird, kann man folgenden Script ausführen:</p>
      <pre>MsgBox % <a href="Variables.htm#IsUnicode">A_IsUnicode</a> ? "Unicode" : "ANSI"</pre>
      <p><strong>ANSI:</strong> Jedes Zeichen ist <strong>ein Byte</strong> groß (8 Bits). Zeichencodes über 127 sind von den Spracheinstellungen deines Systems abhängig.</p>
      <p><strong>Unicode:</strong> Jedes Zeichen ist <strong>zwei Bytes</strong> groß (16 Bits). Zeichencodes sind die vom <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>-Format.</p>
      <p class="Indent"><em>Semantischer Hinweis:</em> Technisch gesehen sind einige Unicode-Zeichen durch <i>zwei</i> 16-Bit-Code-Einheiten vertreten, auch allgemein bekannt als "Ersatzzeichenpaar" (surrogate pair). Ebenso enthalten einige <a href="http://msdn.microsoft.com/en-us/library/dd317752.aspx">ANSI-Zeichensätze</a> (allgemein bekannt als <a href="http://msdn.microsoft.com/en-us/library/dd317794.aspx">Doppel-Byte-Zeichensätze</a>) einige Doppel-Byte-Zeichen. Allerdings werden solche aus praktischen Gründen fast immer als zwei einzelne Einheiten (bzw. Zeichen) behandelt.</p>
      <h3 id="VarSetCapacity">VarSetCapacity</h3>
      <p>VarSetCapacity bestimmt die Kapazität einer Variable <i>in Bytes</i>. Um die Kapazität einer Variable in Bezug auf die Zeichenanzahl zu setzen, muss die Größe eines Zeichens berücksichtigt werden. Zum Beispiel:</p>
      <pre>VarSetCapacity(ansi_var,    capacity_in_chars)
VarSetCapacity(unicode_var, capacity_in_chars * 2)
VarSetCapacity(native_var,  capacity_in_chars * (A_IsUnicode ? 2 : 1))
VarSetCapacity(native_var,  t_size(capacity_in_chars))  <em>; siehe <a href="#NumPutGet">unten</a></em>
</pre>
      <p>Es gibt zwei Anwendungsmöglichkeiten für VarSetCapacity:</p>
      <ol>
        <li>Eine Variable auf eine ungefähre Anzahl an Zeichen erweitern, um die Performance bei der schrittweisen Verkettung eines Strings zu verbessern. Zum Beispiel kann mit <code>VarSetCapacity(var, 1000)</code> 1000 Bytes ermöglicht werden, das in den Unicode-Versionen von AutoHotkey_L nur 500 Zeichen sind. Das könnte Einfluss auf die Performance haben, aber das Script selbst sollte weiterhin normal funktionieren.</li>
        <li>Die Größe einer Variable für eine Binärstruktur anpassen. Falls die Struktur direkt Text enthält, muss das Format des Textes berücksichtigt werden. Das ist abhängig von der Struktur - manchmal wird ANSI-Text verwendet, auch in einer Unicode-Version von AutoHotkey_L. Wenn die Variable zu klein ist, kann es passieren, dass das Script abstürzt oder sich ansonsten unvorhersehbar verhält (abhängig davon, wie die Struktur verwendet wird).</li>
      </ol>
      <h3 id="DllCall">DllCall</h3>
      <p>Der "Str"-Typ, falls vorhanden, kennzeichnet einen String im ursprünglichen Format der aktuellen Version. Da einige Funktionen möglicherweise Strings in einem bestimmten Format benötigen oder zurückgeben, stehen folgende Stringtypen zur Verfügung:</p>
      <table class="info">
        <tr>
          <th></th>
          <th>Zeichengröße</th>
          <th>C / Win32-Typen</th>
          <th>Kodierung</th>
        </tr>
        <tr>
          <td class="Syntax" style="text-align: center">WStr</td>
          <td style="text-align: center">16-Bit</td>
          <td>wchar_t*, WCHAR*, LPWSTR, LPCWSTR</td>
          <td>UTF-16</td>
        </tr>
        <tr>
          <td class="Syntax" style="text-align: center">AStr</td>
          <td style="text-align: center">8-Bit</td>
          <td>char*, CHAR*, LPSTR, LPCSTR</td>
          <td>ANSI (der Standard-ANSI-Zeichensatz des Systems)</td>
        </tr>
        <tr>
          <td class="Syntax" style="text-align: center">Str</td>
          <td style="text-align: center">--</td>
          <td>TCHAR*, LPTSTR, LPCTSTR</td>
          <td>Entspricht <b>WStr</b> in Unicode-Versionen und <b>AStr</b> in ANSI-Versionen.</td>
        </tr>
      </table>
      <br>
      <p>Sobald "Str" oder das Gegenstück der aktuellen Version als Parameter verwendet wird, wird die Adresse des Strings oder der Variable an die Funktion übergeben, ansonsten wird stattdessen eine temporäre Kopie des Strings im gewünschten Format erstellt und übergeben. Als allgemeine Regel gilt, dass "AStr" und "WStr" nicht verwendet werden sollten, wenn die Funktion einen Wert in diesen Parameter schreibt.</p>
      <p><b>Hinweis:</b> "AStr" und "WStr" gelten sowohl für Parameter als auch für den Rückgabewert einer Funktion.</p>
      <p>Wenn ein Script über DllCall eine Funktion aufruft, die einen String als Parameter akzeptiert, muss eins der folgenden Ansätze berücksichtigt werden:</p>
      <ol>
        <li>Existiert sowohl eine Unicode- (W) als auch ANSI-Version (A) von der Funktion, sollte die jeweils aufgerufen werden, die zur aktuellen AutoHotkey_L-Version passt. Im folgenden Beispiel ist "DeleteFile" intern als "DeleteFileA" oder "DeleteFileW" bekannt. Da "DeleteFile" selbst nicht wirklich existiert, versucht DllCall automatisch, "A" oder "W" je nach aktuelle Version zu setzen:
        <pre>DllCall("DeleteFile", "Ptr", &amp;Dateiname)
DllCall("DeleteFile", "Str", Dateiname)</pre>
        <p>In diesem Beispiel wird <code>&amp;Dateiname</code> die Adresse des Strings so übergeben, wie sie ist, damit die Funktion einen String im gleichen Format wie der "Str"-Typ erwarten muss. Beachte, dass in AutoHotkey Basic "UInt" anstelle von "Ptr" verwendet werden muss, aber der resultierende Code möglicherweise nicht 64-Bit-kompatibel ist.</p>
        <p><b>Hinweis:</b> Wenn die angegebene Funktion nicht sofort gefunden werden kann, wird AutoHotkey_L das "A"- oder "W"-Suffix anfügen, unabhängig davon, welche DLL angegeben wurde. AutoHotkey Basic hingegen wird den "A"-Suffix nur bei Funktionen anfügen, die in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll vorkommen.</p>
        </li>
        <li>Wenn die Funktion nur einen bestimmten Stringtyp als Eingabevariable akzeptiert, könnte das Script jeweils den passenden Stringtyp verwenden:
        <pre>DllCall("DeleteFileA", "AStr", Dateiname)
DllCall("DeleteFileW", "WStr", Dateiname)</pre>
        </li>
        <li>Wenn die Funktion einen String modifizieren muss (in einem nicht-nativen Format), muss das Script einen Puffer wie <a href="#VarSetCapacity">oben</a> beschrieben bereitstellen und dessen Adresse an die Funktion übergeben. Wenn der Parameter eine Eingabevariable akzeptiert, muss das Script den Eingabestring zudem in das passende Format umwandeln - mithilfe von <a href="commands/StrPutGet.htm">StrPut</a>.</li>
      </ol>
      <h3 id="NumPutGet">NumPut / NumGet</h3>
      <p>Wenn NumPut oder NumGet mit Strings verwendet werden, muss der Offset und Typ für den angegeben Stringtyp korrekt sein. Das folgende Beispiel dient als Veranschaulichung:</p>
      <pre><em>;  8-Bit/ANSI   Strings:  size_of_char=1  type_of_char="Char"
; 16-Bit/UTF-16 Strings:  size_of_char=2  type_of_char="UShort"</em>
<i>n</i>th_char := NumGet(var, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)
NumPut(<i>n</i>th_char, var, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)</pre>
      <p>Wenn <code>var</code> einen String im ursprünglichen Format enthält, können die passende Werte auf Basis von <code>A_IsUnicode</code> bestimmt werden:</p>
      <pre><i>n</i>th_char := NumGet(var, t_size(<i>n</i>-1), t_char())
NumPut(<i>n</i>th_char, var, t_size(<i>n</i>-1), t_char())

<em>; Für Komfort und Übersichtlichkeit Funktionen definieren:</em>
t_char() {
    Return A_IsUnicode ? "UShort" : "Char"
}
t_size(char_count=1) {
    Return A_IsUnicode ? char_count*2 : char_count
}</pre>
      <h2 id="ptr">Pointer-Größe</h2>
      <p>Pointer haben in 32-Bit-Versionen (einschließlich AutoHotkey Basic) eine Größe von 4 Bytes und in in 64-Bit-Versionen eine Größe von 8 Bytes. Scripts, die Strukturen oder DllCalls verwenden, sollten diese Sache berücksichtigen, damit sie auf beiden Plattformen richtig funktionieren. Bestimmte Bereiche, die auch betroffen sind:</p>
      <ul>
        <li>Offset-Berechnung bei Strukturfeldern, die ein oder mehr Pointer enthalten.</li>
        <li>Größenberechnung bei Strukturen, die ein oder mehr Pointer enthalten.</li>
        <li>Typennamen, die mit <a href="commands/DllCall.htm">DllCall</a>, <a href="Functions.htm#NumPut">NumPut</a> oder <a href="Functions.htm#NumGet">NumGet</a> verwendet werden.</li>
      </ul>
      <p>Zur Berechnung der Größe und des Offsets kann <a href="Variables.htm#PtrSize">A_PtrSize</a> verwendet werden. Für DllCall, NumPut und NumGet je nach Bedarf den <a href="commands/DllCall.htm">Ptr</a>-Typ.</p>
      <p>Denk daran, dass der Offset eines Felds üblicherweise die Gesamtgröße aller vorherigen Felder ist. Beachte zudem, dass Handles (einschließlich Typen wie HWND und HBITMAP) im Grunde Pointer-Typen sind.</p>
      <pre><em>/*
  typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Ptr
    HANDLE hThread;
    DWORD  dwProcessId; // UInt (4 Bytes)
    DWORD  dwThreadId;
  } <a href="http://msdn.microsoft.com/en-us/library/ms684873.aspx">PROCESS_INFORMATION</a>, *LPPROCESS_INFORMATION;
*/</em>
VarSetCapacity(pi, A_PtrSize*2 + 8) <em>; Ptr + Ptr + UInt + UInt</em>
DllCall("<a href="http://msdn.microsoft.com/en-us/library/ms682425.aspx">CreateProcess</a>", <span class="dull">&lt;gekürzt&gt;</span>, "Ptr", &amp;pi, <span class="dull">&lt;gekürzt&gt;</span>)
hProcess    := NumGet(pi, 0)         <em>; Standardmäßig "Ptr".</em>
hThread     := NumGet(pi, A_PtrSize) <em>; </em>
dwProcessId := NumGet(pi, A_PtrSize*2,     "UInt")
dwProcessId := NumGet(pi, A_PtrSize*2 + 4, "UInt")

</pre>
      <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div>
  </section>
</div>
<script type="text/javascript">WriteFooter(0);</script>
</body>
</html>
