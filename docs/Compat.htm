<!DOCTYPE HTML>
<html>
<head>
<title>Script-Kompatibilität</title>
<meta name="keywords" content="Grundlage">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/jquery.js" type="text/javascript"></script>
<script src="static/tree.jquery.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>Script-Kompatibilität</h1>
<p>Die meisten Scripts, die noch auf AutoHotkey 1.0 basieren, müssen nicht extra geändert werden, um sie für AutoHotkey 1.1 lauffähig zu machen. Bei einigen Scripts kann es jedoch vorkommen, dass sie nicht mehr ordnungsgemäß funktionieren, weil sich beide Versionen doch in manchen Punkten unterscheiden. Die meisten Benutzer müssen sich keine Sorgen machen, da die besonders problematischen Unterschiede nur auf erweiterte Funktionalitäten wie DllCall zutreffen.</p>
<p>AutoHotkey 1.1 kennt man auch unter den Namen "AutoHotkey_L". AutoHotkey 1.0 hat seit längere Zeit die Bezeichnung "AutoHotkey Basic". Da frühere Versionen von AutoHotkey_L noch Versionsnummern im 1.0-Format haben, wird dieses Dokument die beiden Entwicklungszweige von AutoHotkey per Namen nennen, um die Übersicht zu bewahren.</p>
<p class="note"><strong>Hinweis:</strong> Einige der häufigsten Probleme entstehen durch Änderungen, die zur Unterstützung von Unicode-Text erforderlich waren. Mit der ANSI-Version von AutoHotkey_L können diese Probleme umgangen werden.</p>
<h3>Grundlagen</h3>
<p>Hohe Auswirkung:</p>
<ul>
  <li><a href="#Syntax_Errors">Bestimmte Syntaxfehler werden nicht länger toleriert</a></li>
  <li><a href="#FileRead">FileRead könnte beschädigte Binärdaten zurückgeben</a></li>
  <li><a href="#Names">Variablen- und Funktionsnamen können nicht mehr [, ] oder ? enthalten</a></li>
</ul>
<p>Mittlere Auswirkung:</p>
<ul>
  <li><a href="#Transform">Der <em>Unicode</em>-Unterbefehl von Transform ist in Unicode-Versionen nicht verfügbar</a></li>
  <li><a href="#Default_Script">AutoHotkey.ahk wird anstelle von AutoHotkey.ini ausgeführt</a></li>
  <li><a href="#SetFormat">SetFormat, Integer, <strong>H</strong> unterscheidet zwischen Groß- und Kleinschreibung</a></li>
  <li><a href="#LastError">A_LastError wird von noch mehr Befehlen geändert</a></li>
  <li><a href="#MsgBox">MsgBox behandelt Kommas konsequenter</a></li>
  <li><a href="#GuiOwner">Gui +Owner überschreibt zusätzliche Styles</a></li>
  <li><a href="#DPIScale">DPI-Skalierung ist für GUIs standardmäßig aktiviert</a></li>
  <li><a href="#VistaSound">SoundSet und SoundGet funktionieren besser in Vista und höher</a></li>
  <li><a href="#Tilde">Tilde (~) hat Einfluss darauf, wie benutzerdefinierte Modifikatortasten funktionieren</a></li>
  <li><a href="#ComboUpDown"><code>x &amp; y::</code> bewirkt, dass sowohl <code>x::</code> als auch <code>x up::</code> ausgelöst werden, sobald x losgelassen wird</a></li>
</ul>
<p>Niedrige Auswirkung:</p>
<ul>
  <li><a href="#IfIs">If <em>Var</em> is <em>Typ</em> ignoriert standardmäßig das Gebietsschema des Betriebssystems</a></li>
  <li><a href="#Window_Groups">GroupActivate setzt ErrorLevel; <em>Label</em> von GroupAdd funktioniert anders</a></li>
  <li><a href="#Run">Run und RunWait interpretieren das <em>Ziel</em> unterschiedlich</a></li>
  <li><a href="#ControlZ">STRG+Z wird nicht als EOF (End of File) interpretiert</a></li>
  <li><a href="#Compatibility_Mode">Der Kompatibilitätsmodus kann zu Verwechslungen führen</a></li>
  <li><a href="#IsCompiled">A_IsCompiled ist immer schreibgeschützt</a></li>
  <li><a href="#Escaped_Whitespace">Führende und nachfolgende `t-Sequenzen werden nicht länger verworfen</a></li>
</ul>
<h3>Erweitert</h3>
<ul>
  <li><a href="#Format">Unicode vs. ANSI</a>
  <ul>
    <li><a href="#VarSetCapacity">VarSetCapacity</a></li>
    <li><a href="#DllCall">DllCall</a></li>
    <li><a href="#NumPutGet">NumPut / NumGet</a></li>
  </ul>
  </li>
  <li><a href="#ptr">Pointer-Größe</a></li>
</ul>
<h2 id="Basic">Grundlagen</h2>
<h3 id="Syntax_Errors">Syntaxfehler</h3>
<p>Bestimmte Syntaxfehler, die bei AutoHotkey Basic toleriert wurden, sind bei AutoHotkey_L nicht mehr zugelassen. Viele dieser Fehler kann man einfach korrigieren, sobald sie entdeckt werden. Die folgenden Fehler werden sofort nach dem Starten eines Scripts erkannt; das heißt, dass diese korrigiert werden müssen, bevor das Script starten kann:</p>
<ul>
  <li>Zwischen dem Namen eines Befehls und seinen Parametern muss ein Leerzeichen, Tabulatorzeichen oder Komma vorkommen. Zum Beispiel sind <code>MsgBox&lt; foo</code> und <code>If!foo</code> keine gültigen Angaben.</li>
  <li><code>Hotkey, If<i>Irgendetwas</i></code>, bei dem <i>Irgendetwas</i> ungültig ist, wird nicht toleriert.</li>
</ul>
<p>Einige andere Syntaxfehler werden erkannt, während das Script läuft. Das Script wird eine Fehlermeldung anzeigen, bevor es den aktuellen Thread verlässt:</p>
<ul>
  <li><strong>Häufig auftretend:</strong> Unbekannte oder falsch formatierte Optionen innerhalb von <a href="commands/Gui.htm#Options">Gui</a>, <a href="commands/Gui.htm#Show">Gui Show</a> oder <a href="commands/GuiControl.htm">GuiControl</a>.</li>
  <li>GroupAdd mit einem leeren Gruppennamen. Vorher bewirkte dieser Fehler, dass der Thread <em>ohne Meldung</em> beendet wurde.</li>
  <li>Die Gui-Option <a href="commands/Gui.htm#LastFoundExist">+LastFoundExist</a> darf nicht mit einer anderen Option kombiniert werden, weil sie sich sonst wie <a href="commands/Gui.htm#LastFound">+LastFound</a> verhalten würde.</li>
</ul>
<p>Andere Syntaxfehler wiederrum werden überhaupt nicht erkannt, was bei AutoHotkey_L zu Problemen führen kann:</p>
<ul>
  <li><a href="Variables.htm#concat">Auto-Verkettung</a> mit <code>(</code> ist zielgerichteter, so dass einige Ausdrücke wie <code>12(34)</code> nicht mehr funktionieren.</li>
</ul>
<h3 id="FileRead">FileRead</h3>
<p><a href="commands/FileRead.htm#Binary">FileRead</a> wandelt den Zeichensatz des Textes in bestimmten Fällen um, wodurch unbrauchbare Binärdaten entstehen können. Um das zu verhindern, benutze die <code>*c</code>-Option oder verwende stattdessen <a href="commands/FileOpen.htm">FileOpen</a>.</p>
<h3 id="Names">Variablen- und Funktionsnamen</h3>
<p>Die Zeichen <code>[</code>, <code>]</code> und <code>?</code> sind für die Verwendung in <a href="Variables.htm#Expressions">Ausdrücken</a> reserviert und daher nicht länger in Variablennamen gültig. Folglich benötigt <code>?</code> (das für ternären Operationen gilt) nicht länger ein Leerzeichen auf jeder Seite. Siehe auch <a href="Objects.htm#Usage">Objektsyntax</a>.</p>
<p>Fehler werden automatisch oder überhaupt nicht erkannt, je nachdem, welche Bedingungen zutreffen:</p>
<ul>
  <li>Wenn diese Zeichen in Variablennamen innerhalb eines Ausdrucks verwendet werden, wird das Script in der Regel weiterlaufen, ohne dass eine Fehlermeldung angezeigt wird. Allerdings wird sich das Script falsch verhalten, weil die Zeichen nicht als Teil eines Variablennamens, sondern als Operatoren interpretiert werden.</li>
  <li>Wenn diese Zeichen in einer <a href="Variables.htm#ref">Doppelderefenzierung</a> verwendet werden (z. B. <code>Array%n%</code>, wo <em>n</em> eins der oben genannten Zeichen enthält), wird eine Fehlermeldung beim Auswerten der Doppeldereferenzierung angezeigt, während das Script läuft.</li>
  <li>Wenn diese Zeichen in einem anderen Kontext verwendet werden (zum Beispiel auf der linken Seite einer Zuweisung, im Namen der Eingabe-/Ausgabevariable eines Befehls oder zwischen %Prozentzeichen%), wird eine Fehlermeldung angezeigt und das Starten des Scripts verhindert.</li>
</ul>
<h3 id="Transform">Transform</h3>
<p>In den Unicode-Versionen von AutoHotkey_L wurden einige Unterbefehle von <i>Transform</i> geändert oder entfernt:</p>
<ul>
  <li><a href="commands/Transform.htm#Unicode">Transform, Unicode</a> steht nicht zur Verfügung. Um Unicode-Text in die Zwischenablage zu speichern, verwende eine normale Zuweisung. Siehe auch: <a href="commands/StrPutGet.htm">StrPut/StrGet</a>.</li>
  <li><a href="commands/Transform.htm#HTML">Transform, HTML</a> unterstützt zusätzliche Features.</li>
</ul>
<h3 id="Default_Script">Standard-Script</h3>
<p>Sobald man AutoHotkey_L ohne Angabe eines Scripts startet, wird standardmäßig eine AHK-Datei statt einer INI-Datei geladen. Der Name dieser Datei beruht auf dem Dateinamen der aktuell ausführbaren Datei. Weitere Informationen findet man unter "<a href="Scripts.htm#cmd">Befehlszeilenparameter an ein Script übergeben</a>".</p>
<h3 id="SetFormat">SetFormat, Integer[Fast], H</h3>
<p>Gibt man den Großbuchstaben H an, werden hexadezimale Zeichen A-F auch in Großbuchstaben sein. AutoHotkey Basic verwendet hingegen immer Kleinbuchstaben. Siehe <a href="commands/SetFormat.htm">SetFormat</a>.</p>
<h3 id="LastError">A_LastError</h3>
<p>Absofort setzen die folgenden Befehle <a href="Variables.htm#LastError">A_LastError</a>, um das Debuggen zu unterstützen: FileAppend, FileRead, FileReadLine, FileDelete, FileCopy, FileMove, FileGetAttrib/Time/Size/Version, FileSetAttrib/Time, FileCreateDir, RegRead, RegWrite, RegDelete. Das Verwenden einer dieser Befehle wird den vorherigen Wert von A_LastError überschreiben.</p>
<h3 id="MsgBox">MsgBox</h3>
<p>Die intelligente Kommahandhabung der <a href="commands/MsgBox.htm">MsgBox</a> wurde geändert, um die Flexibilität und Konsistenz bei allen anderen Befehlen zu verbessern. In den meisten Fällen verhält sich die MsgBox so wie sie soll. In einigen seltenen Fällen kann man bei Scripts, die noch auf das alte fehlerbehaftete Verhalten angewiesen sind, Änderungen im Verhalten beobachten. Zum Beispiel:</p>
<pre><em>; Dies wird nun als Ausdruck (Optionen) gefolgt von Text (Titel) interpretiert,
; anstatt als einzelner Ausdruck (Text) mit mehreren <a href="Variables.htm#comma">Teilausdrücken</a>:</em>
MsgBox % x, y
<em>; Mit runden Klammern kann die alte Interpretation erzwungen werden:</em>
MsgBox % (x, y)

<em>; Dies wird nun ein leeres Dialogfenster anzeigen, anstatt den Text "0, Titel":</em>
MsgBox 0, Titel
<em>; Diese verhalten sich in AutoHotkey_L und AutoHotkey Basic wie erwartet:</em>
MsgBox 0, Titel, % ""   <em>; Zeigt ein leeres Dialogfenster an</em>
MsgBox 0`, Titel        <em>; Zeigt den Text "0, Titel" an</em>

<em>; Dies wird nun ein leeres Dialogfenster anzeigen, anstatt den Text ", Titel":</em>
MsgBox,, Titel
	</pre>
<h3 id="GuiOwner">Gui +Owner</h3>
<p>Beim Anwenden der <a href="commands/Gui.htm#Owner">+Owner</a>-Option auf ein GUI wird zusätzlich der WS_CHILD-Style entfernt und der WS_POPUP-Style gesetzt. Dies könnte Scripts negativ beeinflussen, die mit <code>+Owner</code> das übergeordnete Fenster eines GUIs setzen, <em>nachdem</em> die Styles festgelegt wurden.</p>
<h3 id="DPIScale">DPI-Skalierung</h3>
<p><a href="commands/Gui.htm#DPIScale">DPI-Skalierung</a> ist für GUIs standardmäßig aktiviert. Dies wird Scripts betreffen, wenn die DPI-Einstellung des Systems nicht 96 (100%) ist. Mit <code>Gui -DPIScale</code> kann die Skalierung deaktiviert werden.</p>
<h3 id="VistaSound">Sound-Befehle in Windows Vista oder höher</h3>
<p><a href="commands/SoundSet.htm">SoundSet</a>, <a href="commands/SoundGet.htm">SoundGet</a>, <a href="commands/SoundSetWaveVolume.htm">SoundSetWaveVolume</a> und <a href="commands/SoundGetWaveVolume.htm">SoundGetWaveVolume</a> werden in Windows Vista oder höher besser unterstützt. Typische Veränderungen im Verhalten sind:</p>
<ul>
  <li>Scripts beeinflussen nicht nur das Script selbst, sondern das ganze System (so wie es sein soll).</li>
  <li>Geräte werden unterschiedlich nummeriert - jeder Ausgang oder Eingang wird als seperates Gerät angesehen.</li>
</ul>
<h3 id="Tilde">Tilde (~) und Hotkeys mit benutzerdefinierten Tastenkombinationen</h3>
<p>Seit v1.1.14 hat das <a href="Hotkeys.htm#Tilde">Tilde-Präfix</a> Einfluss darauf, wie eine Taste funktioniert, wenn sie als Modifikatortaste in einer benutzerdefinierten Tastenkombination verwendet wird.</p>
<h3 id="ComboUpDown">Benutzerdefinierte Tastenkombinationen und Down/Up-Hotkeys</h3>
<p>Wenn ein KeyDown- und KeyUp-Hotkey für eine benutzerdefinierte Modifikatortaste definiert wurde, werden beide beim Loslassen der Taste ausgelöst (sofern das Tilde-Präfix nicht vorhanden ist). Zum Beispiel würde <code>x &amp; y::</code> bewirken, dass <code>x::</code> und <code>x up::</code> erst ausgelöst werden, wenn x losgelassen wird.</p>
<h3 id="IfIs">If <em>Var</em> is <em>Typ</em></h3>
<p><a href="commands/IfIs.htm">If <em>Var</em> is <em>Typ</em></a> ignoriert das Gebietsschema des Betriebssystems, sofern <a href="commands/StringCaseSense.htm">StringCaseSense Locale</a> nicht verwendet wird.</p>
<h3 id="Window_Groups">Fenstergruppen</h3>
<p><a href="commands/GroupActivate.htm">GroupActivate</a> setzt ErrorLevel auf 1, wenn kein Fenster gefunden wird, das aktiviert werden kann, ansonsten auf 0. Zuvor blieb ErrorLevel unverändert.</p>
<p>Der <em>Label</em>-Parameter von <a href="commands/GroupAdd.htm">GroupAdd</a> gilt nicht für eine bestimmte Fensterspezifikation innerhalb der Gruppe, sondern für die gesamte Fenstergruppe. Eine Diskussion zu dieser Änderung kann <a href="http://www.autohotkey.com/community/viewtopic.php?t=61362">im Forum</a> gefunden werden. Allerdings ist dieser Parameter <strong>nicht empfohlen</strong>; stattdessen sollte ErrorLevel nach dem Aufruf von GroupActivate überprüft werden.</p>
<h3 id="Run">Run / RunWait</h3>
<p>AutoHotkey_L enthält einige Verbesserungen, wie die Befehle <a href="commands/Run.htm">Run</a> und <a href="commands/Run.htm">RunWait</a> den <em>Ziel</em>-Parameter interpretieren. Dadurch werden Dinge möglich, die zuvor nicht möglich waren. In einigen seltenen Fällen könnte dies Auswirkung auf Scripts haben, die mit AutoHotkey Basic bereits funktionierten. Das neue Verhalten ist wie folgt:</p>
<ul>
  <li>Beginnt <i>Ziel</i> mit einem Anführungszeichen, wird alles bis zum nächsten Anführungszeichen als Aktion angesehen (üblicherweise eine ausführbare Datei).</li>
  <li>Ansonsten wird der erste Teilstring bis zu einem Leerzeichen als Aktion angesehen, sofern der Teilstring eine vorhandene Datei ist oder mit .exe, .bat, .com, .cmd oder .hta endet. Dies hat den Vorteil, dass Dateitypen wie .ahk, .vbs oder .lnk Parameter akzeptieren können, und dass "bekannte" ausführbare Dateien wie wordpad.exe ausgeführt werden können, ohne dass ein absoluter Pfad angegeben werden muss (wie es vorher der Fall war).</li>
</ul>
<h3 id="ControlZ">STRG+Z</h3>
<p><a href="commands/LoopReadFile.htm">Loop Read</a> und <a href="commands/FileReadLine.htm">FileReadLine</a> interpretieren das Zeichen STRG+Z (0x1A) nicht länger als Dateiendemarke (end-of-file marker). Jedes STRG+Z-Zeichen, selbst wenn es ganz am Ende einer Datei vorkommt, wird geladen, ohne dass es eine Funktion hat. <a href="commands/FileRead.htm">FileRead</a> ignoriert bereits dieses Zeichen und ist daher von diesem Problem nicht betroffen.</p>
<h3 id="Compatibility_Mode">Kompatibilitätsmodus</h3>
<p>Setzt man den <a href="http://de.wikipedia.org/wiki/Kompatibilitätsmodus">Kompatibilitätsmodus</a> auf Windows 95, NT4 oder 98/ME im Eigenschaftsfenster der EXE-Datei, mit der das Script ausgeführt werden soll, kann es passieren, dass sich das Script falsch verhalten wird. Das liegt daran, dass der Kompatibilitätsmodus eine bestimmte Windows-Version an das Programm senden würde, die in AutoHotkey_L nicht mehr unterstützt wird. Setzt man den Kompatibilitätsmodus auf Windows 95 oder 98/ME, würde <code>MsgBox %A_OSVersion%</code> die Version <code>WIN_NT4</code> melden.</p>
<h3 id="IsCompiled">A_IsCompiled</h3>
<p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> ist als leerer String definiert, sofern das Script noch nicht kompiliert wurde. Vorher blieb es undefiniert, wodurch Zuweisungen wie <code>A_IsCompiled := 1</code> möglich waren, sofern das Script noch nicht kompiliert wurde. Absofort wird sie überall als schreibgeschützte interne Variable behandelt.</p>
<h3 id="Escaped_Whitespace">Unsichtbare Zeichen mit einem Escapezeichen</h3>
<p>Unsichtbare Zeichen mit einem Escapezeichen wie <code>`t</code> und <code>` </code>&nbsp;werden nicht länger am Anfang oder am Ende eines Arguments verworfen. Zum Beispiel ist <code>StringReplace s, s, `t</code> nun eine gültige Anweisung, die alle Tabulatorzeichen in <em>s</em> entfernt.</p>
<h2 id="Format">Unicode vs. ANSI</h2>
<p>Alle vom Script behandelten Textwerte werden als Zeichenfolge bzw. <em>String</em> gespeichert. Der numerische Wert und die Größe jedes Zeichens ist abhängig davon, welche Version von AutoHotkey man aktuell verwendet: <i>Unicode</i> oder <i>ANSI</i>. Solche Details sind in der Regel nur für Scripts interessant, die folgende Aktionen durchführen:</p>
<ul>
  <li>Strings per <a href="#DllCall">DllCall</a> an externe Funktionen übergeben.</li>
  <li>Strings per <a href="commands/PostMessage.htm">PostMessage/SendMessage</a> übergeben.</li>
  <li>Strings per <a href="#NumPutGet">NumPut/NumGet</a> direkt manipulieren.</li>
  <li>Mit <a href="#VarSetCapacity">VarSetCapacity</a> sicherstellen, dass eine Variable eine bestimmte Anzahl an Zeichen enthalten kann.</li>
</ul>
<p>Scripts, die nur für ein bestimmtes Format gedacht waren, werden oft auf Probleme stoßen, wenn sie mit der falschen AutoHotkey-Version laufen. Zum Beispiel werden einige Scripts, die noch auf AutoHotkey Basic basieren, korrekt mit der ANSI-Version von AutoHotkey_L funktionieren, aber nicht mit der Unicode-Version. Mit dem folgenden Script kann man rausfinden, welche Version aktuell verwendet wird:</p>
<pre>MsgBox % <a href="Variables.htm#IsUnicode">A_IsUnicode</a> ? "Unicode" : "ANSI"</pre>
<p><strong>ANSI:</strong> Jedes Zeichen ist <strong>ein Byte</strong> groß (8 Bits). Zeichencodes über 127 sind von den Spracheinstellungen deines Systems abhängig.</p>
<p><strong>Unicode:</strong> Jedes Zeichen ist <strong>zwei Bytes</strong> groß (16 Bits). Zeichencodes sind durch das <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>-Format definiert.</p>
<p class="Indent"><em>Semantischer Hinweis:</em> Technisch gesehen sind einige Unicode-Zeichen durch <i>zwei</i> 16-Bit-Code-Einheiten vertreten, auch allgemein bekannt als "Ersatzzeichenpaar" (surrogate pair). Ebenso enthalten einige <a href="http://msdn.microsoft.com/en-us/library/dd317752.aspx">ANSI-Zeichensätze</a> (allgemein bekannt als <a href="http://msdn.microsoft.com/en-us/library/dd317794.aspx">Doppel-Byte-Zeichensätze</a>) einige Doppel-Byte-Zeichen. Allerdings werden solche aus praktischen Gründen fast immer als zwei einzelne Einheiten (bzw. Zeichen) behandelt.</p>
<h3 id="VarSetCapacity">VarSetCapacity</h3>
<p>VarSetCapacity bestimmt die Kapazität einer Variable <i>in Bytes</i>. Um die Kapazität einer Variable in Bezug auf die Zeichenanzahl zu setzen, muss die Größe eines Zeichens berücksichtigt werden. Zum Beispiel:</p>
<pre>VarSetCapacity(ANSI_Var,    Zeichenkapazit&auml;t)
VarSetCapacity(Unicode_Var, Zeichenkapazit&auml;t * 2)
VarSetCapacity(Native_Var,  Zeichenkapazit&auml;t * (A_IsUnicode ? 2 : 1))
VarSetCapacity(Native_Var,  t_size(Zeichenkapazit&auml;t))  <em>; siehe <a href="#NumPutGet">unten</a></em>
</pre>
<p>Es gibt zwei Anwendungsmöglichkeiten für VarSetCapacity:</p>
<ol>
  <li>Erweitere eine Variable auf eine ungefähre Anzahl an Zeichen, um die Performance bei der schrittweisen Verkettung eines Strings zu verbessern. Zum Beispiel würde <code>VarSetCapacity(var, 1000)</code> 1000 Bytes ermöglichen; in den Unicode-Versionen von AutoHotkey_L wären das nur 500 Zeichen. Das könnte Einfluss auf die Performance haben, aber das Script selbst sollte weiterhin normal funktionieren.</li>
  <li>Passe die Größe einer Variable für eine Binärstrukur an. Enthält die Struktur Text, muss das Format des Textes berücksichtigt werden. Das ist abhängig von der Struktur - ANSI-Text wird manchmal auch in einer Unicode-Version von AutoHotkey_L verwendet. Ist die Variable zu klein, kann es passieren, dass das Script abstürzt oder sich ansonsten unvorhersehbar verhält (abhängig davon, wie die Struktur verwendet wird).</li>
</ol>
<h3 id="DllCall">DllCall</h3>
<p>Der "Str"-Typ, falls vorhanden, kennzeichnet einen String im nativen Format des aktuellen Builds. Da einige Funktionen möglicherweise Strings in einem bestimmten Format benötigen oder zurückgeben müssen, stehen folgende Stringtypen zur Verfügung:</p>
<table class="info">
  <tr>
    <th></th>
    <th>Zeichengröße</th>
    <th>C / Win32-Typen</th>
    <th>Kodierung</th>
  </tr>
  <tr>
    <td class="Syntax" style="text-align: center">WStr</td>
    <td style="text-align: center">16-Bit</td>
    <td>wchar_t*, WCHAR*, LPWSTR, LPCWSTR</td>
    <td>UTF-16</td>
  </tr>
  <tr>
    <td class="Syntax" style="text-align: center">AStr</td>
    <td style="text-align: center">8-Bit</td>
    <td>char*, CHAR*, LPSTR, LPCSTR</td>
    <td>ANSI (der Standard-ANSI-Zeichensatz des Systems)</td>
  </tr>
  <tr>
    <td class="Syntax" style="text-align: center">Str</td>
    <td style="text-align: center">--</td>
    <td>TCHAR*, LPTSTR, LPCTSTR</td>
    <td>Entspricht <b>WStr</b> in Unicode-Versionen und <b>AStr</b> in ANSI-Versionen.</td>
  </tr>
</table>
<br>
<p>Verwendet man "Str" oder das Gegenstück des aktuellen Builds als Parameter, wird die Adresse des Strings oder der Variable an die Funktion übergeben. Ansonsten wird eine temporäre Kopie des Strings im gewünschten Format erstellt und diese stattdessen übergeben. In der Regel sollten "AStr" und "WStr" nicht verwendet werden, wenn die Funktion einen Wert in diesen Parameter schreibt.</p>
<p><b>Hinweis:</b> &quot;AStr&quot; und &quot;WStr&quot; sind sowohl bei Parametern als auch beim Rückgabewert einer Funktion gültig.</p>
<p>Wenn ein Script eine Funktion per DllCall aufruft, die einen String als Parameter akzeptiert, muss eine der folgenden Methoden durchgeführt werden:</p>
<ol>
  <li>Je nach aktuellem Build sollte man die Unicode- (W) oder ANSI-Version (A) der Funktion aufrufen, falls beide zur Verfügung stehen. Im folgenden Beispiel ist "DeleteFile" intern als "DeleteFileA" oder "DeleteFileW" bekannt. Da "DeleteFile" selbst nicht wirklich existiert, wird DllCall automatisch &quot;A&quot; oder &quot;W&quot; je nach aktuellem Build anfügen:
        <pre>DllCall("DeleteFile", "Ptr", &amp;Dateiname)
DllCall("DeleteFile", "Str", Dateiname)</pre>
  <p>In diesem Beispiel wird <code>&amp;Dateiname</code> die Adresse des Strings exakt in dieser Form übergeben, so dass die Funktion einen String im gleichen Format wie der "Str"-Typ erwarten muss. Beachte, dass in AutoHotkey Basic "UInt" statt "Ptr" verwendet werden muss, aber es kann sein, dass der resultierende Code nicht 64-Bit-kompatibel ist.</p>
  <p><b>Hinweis:</b> Wenn die Funktion mit exakt diesem Namen nicht auffindbar ist, fügt AutoHotkey_L das Suffix "A" oder "W" an, egal welche DLL-Datei angegeben ist. AutoHotkey Basic hingegen wird den Suffix "A" nur bei Funktionen anfügen, die in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll vorkommen.</p>
  </li>
  <li>Wenn die Funktion nur einen bestimmten Stringtyp als Eingabevariable akzeptiert, könnte das Script jeweils den passenden Stringtyp verwenden:
        <pre>DllCall("DeleteFileA", "AStr", Dateiname)
DllCall("DeleteFileW", "WStr", Dateiname)</pre>
  </li>
  <li>Wenn die Funktion einen String modifizieren muss (in einem nicht-nativen Format), muss das Script einen Puffer wie <a href="#VarSetCapacity">oben</a> beschrieben bereitstellen und dessen Adresse an die Funktion übergeben. Wenn der Parameter eine Eingabevariable akzeptiert, muss das Script den Eingabestring zudem in das passende Format umwandeln; verwende dazu <a href="commands/StrPutGet.htm">StrPut</a>.</li>
</ol>
<h3 id="NumPutGet">NumPut / NumGet</h3>
<p>Wenn man NumPut oder NumGet bei Strings anwendet, muss der korrekte Offset und Typ für den angegebenen Stringtyp angegeben werden. Das folgende Beispiel könnte dir dabei helfen:</p>
<pre><em>;  8-Bit/ANSI   Strings:  Zeichengröße=1  Zeichentyp="Char"
; 16-Bit/UTF-16 Strings:  Zeichengröße=2  Zeichentyp="UShort"</em>
Zeichencode := NumGet(var, (<i>Zeichenummer</i>-1)*<i>Zeichengröße</i>, <i>Zeichentyp</i>)
NumPut(Zeichencode, var, (<i>Zeichenummer</i>-1)*<i>Zeichengröße</i>, <i>Zeichentyp</i>)</pre>
<p>Wenn <code>var</code> einen String im nativen Format enthält, können die passenden Werte auf Basis von <code>A_IsUnicode</code> bestimmt werden:</p>
<pre>Zeichencode := NumGet(var, t_size(<i>Zeichenummer</i>-1), t_char())
NumPut(Zeichencode, var, t_size(<i>Zeichenummer</i>-1), t_char())

<em>; Definiere Funktionen für Komfort und Übersichtlichkeit:</em>
t_char() {
    Return A_IsUnicode ? "UShort" : "Char"
}
t_size(char_count=1) {
    Return A_IsUnicode ? char_count*2 : char_count
}</pre>
<h2 id="ptr">Pointer-Größe</h2>
<p>Pointer sind in 32-Bit-Builds (einschließlich AutoHotkey Basic) 4 Bytes groß und in 64-Bit-Builds 8 Bytes. Scripts, die Strukturen oder DllCalls verwenden, sollten dies berücksichtigen, so dass sie auf beiden Plattformen richtig laufen können. Bestimmte Bereiche, die auch betroffen sind:</p>
<ul>
  <li>Offset-Berechnung bei Strukturfeldern, die ein oder mehr Pointer enthalten.</li>
  <li>Größenberechnung bei Strukturen, die ein oder mehr Pointer enthalten.</li>
  <li>Typennamen, die mit <a href="commands/DllCall.htm">DllCall</a>, <a href="Functions.htm#NumPut">NumPut</a> oder <a href="Functions.htm#NumGet">NumGet</a> verwendet werden.</li>
</ul>
<p>Mit <a href="Variables.htm#PtrSize">A_PtrSize</a> kann man Größe und Offset berechnen. Je nachdem wo es angebracht ist, kann man den <a href="commands/DllCall.htm">Ptr</a>-Typ bei DllCall, NumPut und NumGet verwenden.</p>
<p>Beachte, dass der Offset eines Felds üblicherweise die Gesamtgröße aller vorherigen Felder ist. Beachte auch, dass Handles (einschließlich Typen wie HWND und HBITMAP) prinzipiell Pointer-Typen sind.</p>
<pre><em>/*
  typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Ptr
    HANDLE hThread;
    DWORD  dwProcessId; // UInt (4 Bytes)
    DWORD  dwThreadId;
  } <a href="http://msdn.microsoft.com/en-us/library/ms684873.aspx">PROCESS_INFORMATION</a>, *LPPROCESS_INFORMATION;
*/</em>
VarSetCapacity(pi, A_PtrSize*2 + 8) <em>; Ptr + Ptr + UInt + UInt</em>
DllCall("<a href="http://msdn.microsoft.com/en-us/library/ms682425.aspx">CreateProcess</a>", <span class="dull">&lt;gekürzt&gt;</span>, "Ptr", &amp;pi, <span class="dull">&lt;gekürzt&gt;</span>)
hProcess    := NumGet(pi, 0)         <em>; Standardmäßig "Ptr".</em>
hThread     := NumGet(pi, A_PtrSize) <em>; </em>
dwProcessId := NumGet(pi, A_PtrSize*2,     "UInt")
dwProcessId := NumGet(pi, A_PtrSize*2 + 4, "UInt")

</pre>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>
