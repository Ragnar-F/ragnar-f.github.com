<!DOCTYPE HTML>
<html>
<head>
<title>ControlGetText</title>
<meta name="keywords" content="Befehl, Steuerelement">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
    <h1>ControlGetText</h1>
    <p>Ermittelt den Text eines Steuerelements.</p>
    <pre class="Syntax">ControlGetText, AusgabeVar [, Steuerelement, Fenstertitel, Fenstertext, Titelausnahme, Textausnahme]</pre>
    <h3>Parameter</h3>
    <table class="info">
      <tr>
        <td style="width: 15%;">AusgabeVar</td>
        <td style="width: 85%;"><p>Name der Variable, in der der ermittelte Text gespeichert werden soll.</p></td>
      </tr>
      <tr>
        <td>Steuerelement</td>
        <td><p>Kann entweder das ClassNN (Klassenname und Instanznummer des Steuerelements) oder der Text des Steuerelements sein, das beides mit Windows Spy ermittelt werden kann. Verwendet man Text, ist das Übereinstimmungsverhalten abhängig von <a href="SetTitleMatchMode.htm">SetTitleMatchMode</a>. Ist dieser Parameter leer oder nicht vorhanden, wird das oberste Steuerelement des Fensters benutzt.</p>
          <p>Um ein Steuerelement per HWND (Windows Handle) anzusteuern, muss dieser Parameter leer gelassen und <code>ahk_id %SteuerelementHwnd%</code> im <em>Fenstertitel</em>-Parameter angegeben werden (funktioniert auch bei versteckten Steuerelementen, selbst wenn <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> deaktiviert ist). Das HWND eines Steuerelements wird üblicherweise per <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a>, <a href="MouseGetPos.htm">MouseGetPos</a> oder <a href="DllCall.htm">DllCall</a> abgerufen.</p></td>
      </tr>
      <tr>
        <td>Fenstertitel</td>
        <td>Ein Fenstertitel oder sonstige Kriterien, die das Zielfenster ermitteln sollen. Siehe <a href="../misc/WinTitle.htm">Fenstertitel</a>.</td>
      </tr>
      <tr>
        <td>Fenstertext</td>
        <td>In diesem Parameter kann ein Teilstring angegeben werden, der in einem Textelement des Zielfensters vorkommt (werden mit Windows Spy angezeigt). Versteckte Textelemente werden auch erkannt, sofern <a href="DetectHiddenText.htm">DetectHiddenText</a> aktiv ist.</td>
      </tr>
      <tr>
        <td>Titelausnahme</td>
        <td>Ignoriert Fenster, deren Titel diesen Wert enthalten.</td>
      </tr>
      <tr>
        <td>Textausnahme</td>
        <td>Ignoriert Fenster, deren Textelemente diesen Wert enthalten.</td>
      </tr>
    </table>
    <h3>ErrorLevel</h3>
    <p><span class="ver">[v1.1.04+]</span> Dieser Befehl ist in der Lage, bei Misserfolg eine Ausnahme auszulösen. Für mehr Informationen, siehe <a href="Catch.htm#RuntimeErrors">Laufzeitfehler</a>.</p>
    <p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> wird bei Misserfolg auf 1 und bei Erfolg auf 0 gesetzt.</p>
    <h3>Bemerkungen</h3>
    <p>Hinweis: Um Text aus einem ListView-, ListBox- oder ComboBox-Steuerelement zu ermitteln, verwende stattdessen <a href="ControlGet.htm#List">ControlGet List</a>.</p>
    <p>Erscheint der ermittelte Text gekürzt (unvollständig), muss <a href="VarSetCapacity.htm"><code>VarSetCapacity(AusgabeVar, 55)</code></a> vor ControlGetText verwenden werden [55 sollte durch eine wesentlich größere Zahl als die Länge des Textes ersetzt werden]. Das ist notwendig, weil einige Anwendungen nicht richtig auf die WM_GETTEXTLENGTH-Nachricht reagieren, wodurch AutoHotkey die Ausgabevariable für den Text zu klein macht.</p>
    <p>Die Menge des ermittelten Textes ist auf die Maximalkapazität einer Variable begrenzt (die über die <a href="_MaxMem.htm">#MaxMem</a>-Direktive geändert werden kann). Folglich könnte dieser Befehl eine große Menge an RAM erzeugen, wenn das Steuerelement (z. B. ein Editor mit einem geöffneten umfangreichen Dokument) eine große Menge an Text beinhaltet. Allerdings kann der Speicher der Variable geleert werden, indem man ihr nichts zuteilt, z. B. <code>AusgabeVar := ""</code>.</p>
    <p>Meistens enthält der abgerufene Text eines Steuerelements CR- und LF-Zeichen (`r`n), anstatt ein einzelnes LF-Zeichen (`n), um das Ende jeder Zeile zu kennzeichnen.</p>
    <p>Es ist nicht notwendig, <code>SetTitleMatchMode Slow</code> zu verwenden, weil ControlGetText den Text immer mithilfe der langsamen Methode ermittelt (da bei dieser Methode die Chance höher ist, dass der Befehl bei den meisten Steuerelementarten funktioniert).</p>
    <p>Mit <a href="WinGet.htm#ControlList">WinGet ControlList</a> kann eine Liste mit Steuerelementen von einem Fenster abgerufen werden.</p>
    <p>Fenstertitel und -texte unterscheiden zwischen Groß- und Kleinschreibung. Solange <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> deaktiviert ist, werden versteckte Fenster nicht wahrgenommen.</p>
    <h3>Verwandte Befehle</h3>
    <p><a href="ControlSetText.htm">ControlSetText</a>, <a href="WinGetText.htm">WinGetText</a>, <a href="Control.htm">Control</a>, <a href="ControlGet.htm">ControlGet</a>, <a href="ControlMove.htm">ControlMove</a>, <a href="ControlFocus.htm">ControlFocus</a>, <a href="ControlClick.htm">ControlClick</a>, <a href="ControlSend.htm">ControlSend</a>, <a href="_MaxMem.htm">#MaxMem</a></p>
    <h3>Beispiel</h3>
    <pre class="NoIndent">ControlGetText, AusgabeVar, Edit1, Unbenannt -</pre>
  </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>