<!DOCTYPE HTML>
<html>
<head>
<title>SetTimer</title>
<meta name="description" content="Führe intervallweise programmierte Aktionen deiner Wahl mit diesem freien Makro-Programm aus. SetTimer lässt eine Subroutine automatisch und wiederholend laufen.">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>SetTimer</h1>

<p>Lässt eine Subroutine automatisch und wiederholend in einem angegebenen Zeitintervall laufen.</p>

<pre class="Syntax">SetTimer [, Label, Periode|On|Off, Priorität]</pre>
<h3>Parameter</h3>
<dl>

  <dt>Label</dt>
  <dd><p>Name des <a href="../misc/Labels.htm">Labels</a> oder <a href="../Hotkeys.htm">Hotkey-Labels</a>, der angesprungen werden soll, um die Befehle unterhalb von <em>Label</em> auszuführen, bis ein <a href="Return.htm">Return</a> oder <a href="Exit.htm">Exit</a> erreicht wurde. <em>Label</em> kann, wie Parameter und die meisten anderen Befehle auch, einen <a href="../Variables.htm">Variablenverweis</a> wie %MeinLabel% enthalten, um den gespeicherten Namen in der Variable als Ziel zu verwenden.</p>
      <p><span class="ver">[v1.1.01+]:</span> Fehlt das <em>Label</em>, wird stattdessen <a href="../Variables.htm#ThisLabel">A_ThisLabel</a> verwendet. Zum Beispiel könnte <code>SetTimer,, Off</code> innerhalb einer Timer-Subroutine verwendet werden, um den Timer zu deaktivieren.</p></dd>

  <dt>Periode|On|Off</dt>
  <dd><p><strong>On</strong>: Reaktiviert einen zuvor deaktivierten Timer mit ihrer früheren <em>Periode</em>. Falls der Timer noch nicht vorhanden ist, wird er erstellt (mit einer Standardperiode von 250). Wenn ein Timer bereits vorhanden ist, der zuvor im <a href="#once">Nur-Einmal-Laufen-Modus</a> gestartet wurde, wird er auch dieses Mal nur einmal ausgeführt.</p>
      <p><strong>Off</strong>: Deaktiviert einen vorhandenen Timer.</p>
      <p><strong>Periode</strong>: Erstellt oder aktualisiert einen Timer, indem er diesen Parameter als <a href="#Precision">ungefähre</a> Zeitspanne verwendet, die erreicht werden soll, nachdem die <em>Label</em>-Subroutine gestartet wurde. Nachdem diese Zeitspanne erreicht wurde, wird <em>Label</em> nochmals ausgeführt (sofern das vorherige Label fertig ausgeführt wurde). Der Timer wird automatisch aktiviert. Um dies zu verhindern, muss der Befehl mit Off-Parameter direkt danach ein zweites Mal aufgerufen werden.</p>
      <p><em>Periode</em> muss ein Integer sein. Verwendet man eine Variable oder einen Ausdruck, werden Nachkommastellen ignoriert.</p>
      <p>Wenn dieser Parameter leer ist und:<br>
      1) der Timer nicht existiert, wird der Timer mit einer Periode von 250 erstellt.<br>
      2) der Timer bereits vorhanden ist, wird er aktiviert und seine frühere <em>Periode</em> <a href="#reset">wiederhergestellt</a>, sofern eine <em>Priorität</em> noch nicht angegeben wurde.</p>
      <p><strong><a name="once" id="once"></a>Nur einmal laufen</strong> <span class="ver">[v1.0.46.16+]:</span> Verwende eine negative <em>Periode</em>, um den Timer zu kennzeichnen, dass er nur einmal laufen soll. Zum Beispiel würde -100 den Timer nach 100 ms einmal ausführen und ihn dann deaktivieren, als hätte man <code>SetTimer, Label, Off</code> angegeben.<br>
      </p>
    </dd>

  <dt>Priorität</dt>
  <dd><p>Dieser optionale Parameter ist ein Integer zwischen -2147483648 und 2147483647 (oder ein <a href="../Variables.htm#Expressions">Ausdruck</a>), um die Thread-Priorität des Timers zu bestimmen. Fehlt dieser Parameter, gilt standardmäßig 0. Siehe <a href="../misc/Threads.htm">Threads</a> für weitere Details.</p>
      <p>Um die Priorität eines vorhandenen Timers zu ändern, ohne ihn dabei anderweitig zu beeinflussen, muss der Parameter davor leergelassen werden.</p></dd>

</dl>

<h3>Bemerkungen</h3>
<p>Timer sind nützlich, weil sie asynchron laufen - das heißt, dass sie in einem bestimmten Intervall (Frequenz) ausgeführt werden, auch dann, wenn das Script auf ein Fenster wartet, ein Dialogfenster anzeigt oder mit einer anderen Aufgabe beschäftigt ist. Unter anderem kann der Timer verwendet werden, um eine Aktion bei Abwesenheit des Benutzers durchzuführen (in Verbindung mit <a href="../Variables.htm#TimeIdle">A_TimeIdle</a>) oder um unerwünschte Fenster sofort wieder zu schließen, wenn sie erscheinen.</p>
<p>Timer erzeugen nur die Illusion, dass das Script mehrere Aufgaben gleichzeitig durchführen kann. In Wirklichkeit werden zeitgesteuerte Subroutinen genauso wie andere Threads behandelt: sie können unterbrechen oder von anderen Threads, wie z. B. eine <a href="../Hotkeys.htm">Hotkey-Subroutine</a>, unterbrochen werden. Siehe <a href="../misc/Threads.htm">Threads</a> für weitere Details.</p>
<p>Die Subroutine eines erstellten, reaktivierten oder mit einer neuen <em>Periode</em> versehenen Timers wird nicht sofort ausgeführt; zuerst muss seine angegebene <em>Periode</em> verstreichen. Wenn der Timer sofort beginnen soll, muss du <a href="Gosub.htm">Gosub</a> zum Ausführen der Timer-Subroutine verwenden (allerdings wird das keinen neuen Thread starten, wie es der Timer selbst machen würde; demzufolge werden Einstellungen wie <a href="SendMode.htm">SendMode</a> nicht mit ihren Standardwerten beginnen).</p>
<p><a name="reset"></a>Wenn SetTimer auf einem bereits vorhandenen Timer angewendet wird und der 2. Parameter eine Nummer oder das Wort ON ist (oder weggelassen wird), wird die interne "zuvor verwendete Zeit" auf die aktuelle Zeit zurückgesetzt; das heißt, dass seine Periode einmal komplett verstreichen muss, bevor seine Subroutine wieder ausgeführt wird.</p>
<p><strong><a name="Precision"></a>Genauigkeit des Timers</strong>: Durch die Granularität (Ungenauigkeit) der Zeiterfassung im Betriebssystem wird <em>Periode</em> möglicherweise auf das nächstmögliche Vielfache von 10 oder 15.6 Millisekunden aufgerundet (abhängig vom Typ der installierten Hardware und Treiber). In Windows 2000/XP ist eine <em>Periode</em> zwischen 1 und 10 gleichbedeutend mit 10 oder 15.6. Eine kürzere Verzögerung kann mittels Loop+Sleep erreicht werden, wie bei <a href="Sleep.htm#ShorterSleep">DllCall+<span class="NoIndent">timeBeginPeriod</span>+Sleep</a> gezeigt.</p>
<p>Es kann sein, dass ein Timer unregelmäßig läuft, wenn folgende Bedingungen auftreten:</p>
<ol>
  <li>Andere Anwendungen belasten die CPU ziemlich stark.</li>
  <li>Die Timer-Subroutine braucht länger als die angebende Periode oder es gibt zu viele konkurrierende Timer (das Ändern von <a href="SetBatchLines.htm">SetBatchLines</a> kann helfen).</li>
  <li>Der Timer wurde von einem anderen <a href="../misc/Threads.htm">Thread</a> unterbrochen, dazu zählen andere zeitgesteuerte Subroutinen, <a href="../Hotkeys.htm">Hotkey-Subroutinen</a> oder <a href="Menu.htm">benutzerdefinierte Menüpunkte</a> (kann mit <a href="Critical.htm">Critical</a> verhindert werden). Falls das passiert und der unterbrechende Thread lange Zeit zum Beenden braucht, wird der unterbrochene Timer für diese Dauer deaktiviert. Allerdings werden alle anderen Timer weiterlaufen, indem sie den <a href="../misc/Threads.htm">Thread</a> unterbrechen, der den ersten Timer unterbrochen hat.</li>
  <li>Ein Script kann nicht unterbrochen werden, wenn man <a href="Critical.htm">Critical</a> oder <a href="Thread.htm">Thread Interrupt/Priority</a> verwendet. In solchen Zeiten werden Timer nicht laufen. Wenn das Script später wieder unterbrochen werden kann, wird jeder überfällige Timer sobald wie möglich einmal ausgeführt und danach seinen normalen Ablauf fortsetzen.</li>
</ol>
<p>Zwar funktionieren Timer auch, wenn das Script <a href="Suspend.htm">gesperrt</a> ist, allerdings werden sie nicht laufen, wenn <a href="Thread.htm">Thread NoTimers</a> im <a href="../misc/Threads.htm">aktuellen Thread</a> vorhanden ist oder wenn ein Thread <a href="Pause.htm">pausiert</a> wurde. Darüber hinaus werden sie nicht funktionieren, wenn der Benutzer in einem der Script-Menüs navigiert (wie z. B. das Tray-Icon-Menü oder eine Menüleiste).</p>
<p>Da Timer vorübergehend die aktuelle Aktivität des Scripts unterbrechen, sollten ihre Subroutinen kurz gehalten werden (so dass sie schnell zum Ende kommen), wann immer eine lange Unterbrechung unerwünscht ist.</p>
<p>Timer, die die ganze Zeit laufen sollen, sollten üblicherweise im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> erstellt werden. Dagegen deaktivieren sich temporäre Timer oft mit ihren eigenen Subroutinen (siehe Beispiele weiter unten).</p>
<p>Immer wenn eine zeitgesteuerte Subroutine gestartet wird, beginnt sie mit den Standardeinstellungen von Befehlen wie <a href="SendMode.htm">SendMode</a>. Diese Standardeinstellungen können im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> geändert werden.</p>
<p>Wenn die <a href="../Hotkeys.htm">Hotkey</a>-Reaktionszeit von entscheidender Bedeutung ist (z. B. bei Spielen) und das Script bestimmte Timer enthält, deren Subroutinen länger als 5 ms zum Ausführen benötigen, dann sollte der folgende Befehl verwendet werden, um eine mögliche Verzögerung von 15 ms zu unterbinden. So eine Verzögerung würde ansonsten auftreten, wenn ein Hotkey exakt zu dem Zeitpunkt gedrückt wird, wo ein Timer-Thread in seiner unterbrechungsfreien Phase ist:</p>
<pre><a href="Thread.htm">Thread</a>, interrupt, 0  <em>; Macht alle Threads jederzeit unterbrechbar.</em></pre>
<p>Deaktiviert man einen Timer, während seine Subroutine noch läuft, wird diese Subroutine bis zu ihrem Ende fortgesetzt.</p>
<p>Die <a href="KeyHistory.htm">KeyHistory</a>-Funktion zeigt, wie viele Timer vorhanden und wie viele zurzeit aktiviert sind.</p>
<p>Eine Timer-Periode kann nicht länger als 4294967295 Millisekunden dauern (49.7 Tage).</p>
<p>Mit <a href="_Persistent.htm">#Persistent</a> kann ein Script aufrecht erhalten werden - zum Beispiel für ein Script, das nur Timer enthält.</p>
<h3>Siehe auch</h3>
<p><a href="Gosub.htm">Gosub</a>, <a href="Return.htm">Return</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Thread.htm">Thread (Befehl)</a>, <a href="Critical.htm">Critical</a>, <a href="../Functions.htm#IsLabel">IsLabel()</a>, <a href="Menu.htm">Menu</a>, <a href="_Persistent.htm">#Persistent</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel #1: Schließt unerwünschte Fenster, sobald sie auftauchen:</em>
#Persistent
SetTimer, MailWarnungenSchließen, 250
return

MailWarnungenSchließen:
WinClose, Microsoft Outlook, Während der Kommunikation mit dem Server wurde das Zeitlimit überschritten
WinClose, Microsoft Outlook, Es konnte keine Verbindung aufgebaut werden
return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Wartet auf ein bestimmtes Fenster und alarmiert danach den Benutzer:</em>
#Persistent
SetTimer, Alarm1, 500
return

Alarm1:
IfWinNotExist, Video-Konvertierung, Prozess abgeschlossen
    return
<em>; Ansonsten:</em>
SetTimer, Alarm1, Off  <em>; d. h. der Timer deaktiviert sich selbst.</em>
SplashTextOn, , , Die Video-Konvertierung wurde abgeschlossen.
Sleep, 3000
SplashTextOff
return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Erkennt, ob ein Hotkey einmal, zweimal oder dreimal gedrückt wurde. Dadurch
; kann ein Hotkey eine unterschiedliche Operation durchführen,
; je nachdem, wie oft er gedrückt wurde:</em>
#c::
if winc_anzahl &gt; 0 <em>; Da SetTimer bereits gestartet wurde, wird stattdessen der Tastendruck protokolliert</em>.
{
    winc_anzahl += 1
    return
}
<em>; Ansonsten ist das der erste Tastendruck einer neuen Serie. Zählung wird 
; auf 1 gesetzt und der Timer gestartet:</em>
winc_anzahl = 1
SetTimer, TasteWinC, 400 <em>; Wartet bis zu 400 Millisekunden, dass der Hotkey nochmal gedrückt wird.</em>
return

TasteWinC:
SetTimer, TasteWinC, off
if winc_anzahl = 1 <em>; Die Taste wurde einmal gedrückt.</em>
{
    Run, m:\  <em>; Öffnet einen Ordner.</em>
}
else if winc_anzahl = 2 <em>; Die Taste wurde zweimal gedrückt.</em>
{
    Run, m:\multimedia  <em>; Öffnet einen anderen Ordner.</em>
}
else if winc_anzahl &gt; 2
{
    MsgBox, Drei oder mehr Klicks erkannt.
}
<em>; Unabhängig von der zuvor ausgelösten Aktion wird die Zählung zurückgesetzt,
; um die nächste Serie von Tastendrücken vorzubereiten:</em>
winc_anzahl = 0
return</pre>

</body>
</html>
