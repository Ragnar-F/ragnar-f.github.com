<!DOCTYPE HTML>
<html>
<head>
<title>SetTimer</title>
<meta name="description" content="Führe intervallweise selbst programmierte Aktionen mit diesem freien Makro-Programm aus. SetTimer startet eine Subroutine automatisch und wiederholend.">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>SetTimer</h1>

<p>Bewirkt, dass eine Subroutine in bestimmten Zeitintervallen automatisch und wiederholend ausgeführt wird.</p>

<pre class="Syntax">SetTimer [, Label, Periode|On|Off, Priorität]</pre>
<h3>Parameter</h3>
<dl>

  <dt>Label</dt>
  <dd><p>Name des <a href="../misc/Labels.htm">Labels</a> oder <a href="../Hotkeys.htm">Hotkey-Labels</a>, der angesprungen werden soll, um die Befehle unterhalb von <em>Label</em> bis zu einem <a href="Return.htm">Return</a> oder <a href="Exit.htm">Exit</a> auszuführen. <em>Label</em> kann, wie Parameter und die meisten anderen Befehle auch, einen <a href="../Variables.htm">Variablenverweis</a> wie %MeinLabel% enthalten, um den gespeicherten Namen in der Variable als Ziel zu verwenden.</p>
      <p><span class="ver">[v1.1.01+]:</span> Ist <em>Label</em> nicht vorhanden, gilt stattdessen <a href="../Variables.htm#ThisLabel">A_ThisLabel</a>. Zum Beispiel kann <code>SetTimer,, Off</code> innerhalb einer Timer-Subroutine verwendet werden, um den Timer zu deaktivieren.</p></dd>

  <dt>Periode|On|Off</dt>
  <dd><p><strong>On</strong>: Reaktiviert einen zuvor deaktivierten Timer mit der vorherigen <em>Periode</em>. Falls der Timer noch nicht vorhanden ist, wird er erstellt (mit einer Standardperiode von 250). Ist der Timer vorhanden, aber dazu bestimmt, <a href="#once">nur einmal ausgeführt zu werden</a>, wird er auch dieses Mal nur einmal ausgeführt.</p>
      <p><strong>Off</strong>: Deaktiviert einen vorhandenen Timer.</p>
      <p><strong>Periode</strong>: Erstellt oder aktualisiert ein Timer mit der <a href="#Precision">ungefähren</a> Wartezeit in Millisekunden, bevor die <em>Label</em>-Subroutine ausgeführt wird. Sobald diese Zeit vertrichen ist, wird <em>Label</em> nochmals ausgeführt (sofern das vorherige Label fertig ausgeführt wurde). Der Timer wird automatisch aktiviert. Um dies zu verhindern, muss der Befehl unmittelbar danach ein weiteres Mal aufgerufen und für diesen Parameter OFF angegeben werden.</p>
      <p>Wenn dieser Parameter leer ist und:<br>
      1) der Timer nicht existiert, wird der Timer mit einer Periode von 250 erstellt.<br>
      2) der Timer bereits vorhanden ist, wird er aktiviert und dessen <em>Periode</em> auf den vorherigen Wert <a href="#reset">zurückgesetzt</a>, sofern die <em>Priorität</em> noch nicht bestimmt wurde.</p>
      <p><strong><a name="once" id="once"></a>Nur einmal ausführen</strong> <span class="ver">[v1.0.46.16+]:</span> Eine negative <em>Periode</em> bewirkt, dass der Timer nur einmal ausgeführt wird. Zum Beispiel wird mit -100 der Timer nach 100 ms einmal ausgeführt und danach deaktiviert, als ob <code>SetTimer, Label, Off</code> verwendet wurde.<br>
      </p>
    </dd>

  <dt>Priorität</dt>
  <dd><p>Dieser optionale Parameter ist ein Integer zwischen -2147483648 und 2147483647 (oder ein <a href="../Variables.htm#Expressions">Ausdruck</a>), um die Thread-Priorität des Timers zu bestimmen. Ist dieser Parameter nicht vorhanden, wird 0 verwendet. Siehe <a href="../misc/Threads.htm">Threads</a> für weitere Details.</p>
      <p>Um die Priorität eines vorhandenen Timers zu ändern, ohne ihn dabei anderweitig zu beeinflussen, sollte der Parameter davor leergelassen werden.</p></dd>

</dl>

<h3>Bemerkungen</h3>
<p>Timer sind nützlich, weil sie asynchron laufen, das heißt, dass sie in einem bestimmten Intervall (Frequenz) ausgeführt werden, auch dann, wenn das Script auf ein Fenster wartet, ein Dialogfenster anzeigt oder mit einer anderen Aufgabe beschäftigt ist. Unter anderem kann der Timer dazu verwendet werden, eine Aktion duchzuführen, wenn der Benutzer abwesend wird (in Verbindung mit <a href="../Variables.htm#TimeIdle">A_TimeIdle</a>) oder unerwünschte Fenster zu schließen, sobald sie erscheinen.</p>
<p>Obwohl Timer die Illusion erzeugen, dass das Script mehrere Aufgaben gleichzeitig durchführen kann, ist das nicht der Fall. Stattdessen werden zeitgesteuerte Subroutinen einfach wie andere Threads behandelt: sie sind in der Lage, zu unterbrechen oder von anderen Threads unterbrochen zu werden, wie z. B. eine <a href="../Hotkeys.htm">Hotkey-Subroutine</a>. Siehe <a href="../misc/Threads.htm">Threads</a> für weitere Details.</p>
<p>Sobald ein Timer erstellt, reaktiviert oder mit einer neuen <em>Periode</em> aktualisiert wird, wird dessen Subroutine nicht sofort ausgeführt - zuerst muss die angegebene <em>Periode</em> verstreichen. Muss die erste Ausführung des Timers sofort erfolgen, sollte <a href="Gosub.htm">Gosub</a> verwendet werden, um die Subroutine des Timers auszuführen (allerdings wird kein neuer Thread gestartet, wie es der Timer selbst macht, folglich haben Einstellungen wie <a href="SendMode.htm">SendMode</a> zu Beginn nicht ihre Standardwerte).</p>
<p><a name="reset"></a>Wenn SetTimer sich auf einen bereits vorhandenen Timer bezieht und der zweite Parameter eine Zahl oder das Wort ON ist (oder weggelassen wird), wird die interne "zuvor verwendete Zeit" auf die aktuelle Zeit zurückgesetzt. Außerdem muss dessen Periode einmal komplett verstreichen, bevor die Subroutine wieder ausgeführt wird.</p>
<p><strong><a name="Precision"></a>Genauigkeit des Timers</strong>: Durch die Granularität (Ungenauigkeit) der Zeiterfassung im Betriebssystem wird <em>Periode</em> möglicherweise auf das nächstmögliche Vielfache von 10 oder 15.6 Millisekunden aufgerundet (abhängig vom Typ der installierten Hardware und Treiber). In Windows 2000/XP ist eine <em>Periode</em> zwischen 1 und 10 gleichbedeutend mit 10 oder 15.6. Eine kürzere Verzögerung kann mittels Loop+Sleep erreicht werden, wie in <a href="Sleep.htm#ShorterSleep">DllCall+<span class="NoIndent">timeBeginPeriod</span>+Sleep</a> demonstriert.</p>
<p>Es ist möglich, dass ein Timer unter folgenden Bedingungen unregelmäßig läuft:</p>
<ol>
  <li>Andere Anwendungen belasten die CPU ziemlich stark.</li>
  <li>Die Timer-Subroutine braucht länger als die angebende Periode oder es gibt zu viele konkurrierende Timer (das Ändern von <a href="SetBatchLines.htm">SetBatchLines</a> kann helfen).</li>
  <li>Der Timer wurde von einem anderen <a href="../misc/Threads.htm">Thread</a> unterbrochen, dazu zählen andere zeitgesteuerte Subroutinen, <a href="../Hotkeys.htm">Hotkey-Subroutinen</a> oder <a href="Menu.htm">benutzerdefinierte Menüpunkte</a> (kann mit <a href="Critical.htm">Critical</a> verhindert werden). Falls das passiert und die Unterbrechung etwas dauert, wird der unterbrochene Timer in dieser Zeitspanne deaktiviert. Allerdings werden andere Timer fortgesetzt, indem sie den <a href="../misc/Threads.htm">Thread</a> unterbrechen, der den ersten Timer unterbrochen hat.</li>
  <li>Das Script ist aufgrund von <a href="Critical.htm">Critical</a> oder <a href="Thread.htm">Thread Interrupt/Priority</a> unterbrechungsfrei. In solchen Zeiten werden Timer nicht ausgeführt. Wenn das Script später wieder unterbrochen werden kann, wird jeder überfällige Timer sobald wie möglich einmal ausgeführt und danach deren normaler Ablauf fortgesetzt.</li>
</ol>
<p>Obwohl Timer auch laufen, während das Script <a href="Suspend.htm">gesperrt</a> ist, werden sie nicht laufen, wenn im <a href="../misc/Threads.htm">aktuellen Thread</a> der Befehl <a href="Thread.htm">Thread NoTimers</a> aktiv ist oder ein Thread <a href="Pause.htm">angehalten</a> wird. Darüber hinaus laufen sie nicht, wenn der Benutzer durch ein Menü des Scripts navigiert (wie z. B. das Tray-Icon-Menü oder eine Menüleiste).</p>
<p>Da Timer auch laufen, während die aktuelle Script-Aktivität vorübergehend unterbrochen wird, sollten ihre Subroutinen kurz gehalten werden (sodass sie schnell beendet werden können), falls eine lange Unterbrechung unerwünscht ist.</p>
<p>Timer, die während eines Scripts aktiv bleiben, sollten für gewöhnlich im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> erstellt werden. Temporäre Timer hingegen deaktivieren sich oft selbst (siehe Beispiele weiter unten).</p>
<p>Sobald eine zeitgesteuerte Subroutine ausgeführt wird, werden die Standardwerte in den Einstellungen wie <a href="SendMode.htm">SendMode</a> verwendet. Diese Standardwerte können im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> geändert werden.</p>
<p>Wenn die <a href="../Hotkeys.htm">Hotkey</a>-Reaktionszeit von entscheidender Bedeutung ist (z. B. bei Spielen) und das Script bestimmte Timer enthält, deren Subroutinen zum Ausführen mehr als 5 ms brauchen, dann sollte der folgende Befehl verwendet werden, um eine mögliche Verzögerung von 15 ms zu unterbinden. So eine Verzögerung würde ansonsten auftreten, falls ein Hotkey genau in dem Moment gedrückt wird, wenn sich ein Timer-Thread in der unterbrechungsfreien Phase befindet:</p>
<pre><a href="Thread.htm">Thread</a>, interrupt, 0  <em>; Alle Threads sind jederzeit unterbrechbar.</em></pre>
<p>Wenn ein Timer deaktiviert wird, während seine Subroutine noch läuft, wird diese Subroutine fortgesetzt, bis sie das Ende erreicht.</p>
<p>Die <a href="KeyHistory.htm">KeyHistory</a>-Funktion zeigt, wie viele Timer vorhanden und wie viele zurzeit aktiviert sind.</p>
<p>Eine Timer-Periode kann nicht länger als 4294967295 Millisekunden dauern (49.7 Tage).</p>
<p>Zur Aufrechterhaltung eines Scripts (das zum Beispiel nur Timer enthält) kann <a href="_Persistent.htm">#Persistent</a> verwendet werden.</p>
<h3>Siehe auch</h3>
<p><a href="Gosub.htm">Gosub</a>, <a href="Return.htm">Return</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Thread.htm">Thread (Befehl)</a>, <a href="Critical.htm">Critical</a>, <a href="../Functions.htm#IsLabel">IsLabel()</a>, <a href="Menu.htm">Menu</a>, <a href="_Persistent.htm">#Persistent</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel #1: Schließt unerwünschte Fenster, sobald sie auftauchen:</em>
#Persistent
SetTimer, MailWarnungenSchließen, 250
return

MailWarnungenSchließen:
WinClose, Microsoft Outlook, Während der Kommunikation mit dem Server wurde das Zeitlimit überschritten
WinClose, Microsoft Outlook, Es konnte keine Verbindung aufgebaut werden
return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Wartet auf ein bestimmtes Fenster und alarmiert danach den Benutzer:</em>
#Persistent
SetTimer, Alarm1, 500
return

Alarm1:
IfWinNotExist, Video-Konvertierung, Prozess abgeschlossen
    return
<em>; Ansonsten:</em>
SetTimer, Alarm1, Off  <em>; d. h. der Timer deaktiviert sich selbst.</em>
SplashTextOn, , , Die Video-Konvertierung wurde abgeschlossen.
Sleep, 3000
SplashTextOff
return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Erkennt, ob ein Hotkey einmal, zweimal oder dreimal gedrückt wurde. Dadurch
; kann ein Hotkey eine unterschiedliche Operation durchführen,
; je nachdem, wie oft er gedrückt wurde:</em>
#c::
if winc_anzahl &gt; 0 <em>; Da SetTimer bereits gestartet wurde, wird stattdessen der Tastendruck protokolliert</em>.
{
    winc_anzahl += 1
    return
}
<em>; Ansonsten ist das der erste Tastendruck einer neuen Serie. Zählung wird 
; auf 1 gesetzt und der Timer gestartet:</em>
winc_anzahl = 1
SetTimer, TasteWinC, 400 <em>; Wartet bis zu 400 Millisekunden, dass der Hotkey nochmal gedrückt wird.</em>
return

TasteWinC:
SetTimer, TasteWinC, off
if winc_anzahl = 1 <em>; Die Taste wurde einmal gedrückt.</em>
{
    Run, m:\  <em>; Öffnet einen Ordner.</em>
}
else if winc_anzahl = 2 <em>; Die Taste wurde zweimal gedrückt.</em>
{
    Run, m:\multimedia  <em>; Öffnet einen anderen Ordner.</em>
}
else if winc_anzahl &gt; 2
{
    MsgBox, Drei oder mehr Klicks erkannt.
}
<em>; Unabhängig von der zuvor ausgelösten Aktion wird die Zählung zurückgesetzt,
; um die nächste Serie von Tastendrücken vorzubereiten:</em>
winc_anzahl = 0
return</pre>

</body>
</html>
