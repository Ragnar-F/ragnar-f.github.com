<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>RegExReplace</title>
<meta name="keywords" content="Befehl, Funktion, String">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="wrapper">
<script src="../navbar/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(1);</script>


<h1>RegExReplace() <span class="ver">[v1.0.45+]</span></h1>

<p>Ersetzt bestimmte Muster (regul&auml;re Ausdr&uuml;cke) in einem String.</p>

<pre class="Syntax">NeuerStr := RegExReplace(Heuhaufen, NadelRegEx [, Ersatz = "", AusgabevariableAnzahl = "", Limit = -1, Startposition = 1])</pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">NeuerStr</td>
    <td width="85%">RegExReplace() gibt eine Version des <em>Heuhaufens</em> zur&uuml;ck, deren Inhalt ersetzt wurde. Wenn das Ersetzen nicht notwendig ist, dann wird der <em>Heuhaufen</em> unver&auml;ndert zur&uuml;ckgegeben. Wenn ein Fehler auftritt (z. B. ein Syntaxfehler in der <em>NadelRegEx</em>), dann wird der <em>Heuhaufen</em> unver&auml;ndert zur&uuml;ckgegeben (aber nicht in den Versionen vor 1.0.46.06, die "" zur&uuml;ckgegeben) und ErrorLevel auf einen <a href="#ErrorLevel">unten genannten</a> Wert anstelle von 0 gesetzt.</td>
  </tr>
  <tr>
    <td>Heuhaufen</td>
    <td>Der String, dessen Inhalt durchsucht und ersetzt wird. </td>
  </tr>
  <tr>
    <td>NadelRegEx</td>
    <td>Das zu suchende Muster, welches ein Perl-kompatibler regul&auml;rer Ausdruck (PCRE) ist. Die <a href="../misc/RegEx-QuickRef.htm#Options">Optionen</a> des Musters (falls vorhanden) m&uuml;ssen am Anfang des Strings stehen, gefolgt von einer schlie&szlig;enden Klammer. Zum Beispiel wird das Muster "<span class="red">i)</span>abc.*123" die Abh&auml;ngigkeit von der Gro&szlig;- und Kleinschreibung deaktivieren und nach "abc", null oder mehr Zeichen und "123" suchen. Wenn keine Optionen vorhanden sind, dann ist ")" optional; zum Beispiel ist ")abc" gleichbedeutend mit "abc".</td>
  </tr>
  <tr>
    <td>Ersatz</td>
    <td><p><a name="BackRef"></a>Der String, der als Ersatz f&uuml;r jede &Uuml;bereinstimmung dient und Klartext ist (kein regul&auml;rer Ausdruck). Darin k&ouml;nnen sich auch R&uuml;ckreferenzen (z. B. $1) befinden, die den Teilstring vom <em>Heuhaufen</em> einbringen, welcher mit dem ersten <a href="../misc/RegEx-QuickRef.htm#subpat">Teilausdruck</a> &uuml;bereinstimmt. Die einfachsten R&uuml;ckreferenzen sind $0 bis $9, wobei $0 der Teilstring ist, der mit dem gesamten Muster &uuml;bereinstimmt, $1 der Teilstring ist, der mit dem ersten Teilausdruck &uuml;bereinstimmt, $2 mit dem Zweiten und so weiter. Bei R&uuml;ckreferenzen &uuml;ber 9 (und optional auch bei den 9 selber) m&uuml;ssen die Nummern von geschweiften Klammern umschlossen werden, zum Beispiel: ${10}, ${11} und so weiter. Bei <a href="RegExMatch.htm#NamedSubPat">benannten Teilausdr&uuml;cken</a> muss der Name von geschweiften Klammern umschlossen werden, zum Beispiel ${SubpatternName}. Um ein $ direkt anzugeben, verwendet $$ (ist das einzige Zeichen, dass eine Sonderbehandlung ben&ouml;tigt; Backslash-Zeichen werden nie ben&ouml;tigt, um irgendwas zu sch&uuml;tzen).</p>
      <p>Um die Gro&szlig;- und Kleinschreibung des Teilausdrucks umzuwandeln, setzt nach $ folgendes Zeichen: U oder u (Gro&szlig;buchstaben), L oder l (Kleinbuchstaben), T oder t (Titel, damit wird das erste Zeichen jeden Wortes gro&szlig;geschrieben, alle anderen jedoch kleingeschrieben). Zum Beispiel &uuml;bertr&auml;gt sowohl $U1 als auch $U{1} eine gro&szlig;geschriebene Version des ersten Teilausdrucks.</p>
      <p>Nicht vorhandene R&uuml;ckreferenzen und diejenigen, die keine &Uuml;bereinstimmung im <em>Heuhaufen</em> haben (z. B. einen Teilausdruck von <em>(abc)|(xyz)</em>), werden als leerer String &uuml;bertragen.</p></td>
  </tr>
  <tr>
    <td><span class="CommandSyntax">AusgabevariableAnzahl</span></td>
    <td>Der Name der Variable ohne Anf&uuml;hrungszeichen, in der die Anzahl gespeichert wird, wie oft der Heuhaufen ersetzt wurde (0, wenn nicht).</td>
  </tr>
  <tr>
    <td>Limit</td>
    <td>Wenn das <em>Limit</em> weggelassen wird, dann standardm&auml;&szlig;ig -1, um <strong>alle</strong> Vorkommen des Musters zu ersetzen, die im <em>Heuhaufen</em> gefunden werden. Andernfalls kann angegeben werden, wie oft der <em>Heuhaufen</em> ersetzt werden kann. Der <em>Heuhaufen</em>-Bereich auf der rechten Seite des letzten Ersatzes bleibt unver&auml;ndert.</td>
  </tr>
  <tr>
    <td>Startposition</td>
    <td><p>Wenn die <em>Startposition</em> weggelassen wird, dann standardm&auml;&szlig;ig eine 1 (der Anfang vom <em>Heuhaufen</em>). Verwendet andernfalls eine 2, um beim zweiten Zeichen beginnen, eine 3, um beim Dritten zu beginnen und so weiter.  Wenn die <em>Startposition</em> die L&auml;nge des <em>Heuhaufens</em> &uuml;berschreitet, dann beginnt die Suche bei einem leeren String, welcher sich am Ende des <em>Heuhaufens</em> befindet (ergibt typischerweise keinen Ersatz).</p>
      <p>Wenn die <em>Startposition</em> kleiner als 1 ist, dann ist es das Offset vom Ende des <em>Heuhaufens</em>. Zum Beispiel beginnt 0 beim letzten Zeichen und -1 beim vorletzten Zeichen. Wenn die <em>Startposition</em> das linke Ende des <em>Heuhaufens</em> &uuml;berschreitet, dann wird alles vom <em>Heuhaufen</em> durchsucht.</p>
      <p>Unabh&auml;ngig vom <em>Startposition</em>-Wert ist der R&uuml;ckgabewert immer eine komplette Kopie des <em>Heuhaufens</em>, nur mit dem Unterschied, dass mehr von der linken Seite unver&auml;ndert ist, verglichen mit dem, was passieren k&ouml;nnte, wenn die <em>Startposition</em> eine 1 enth&auml;lt.</p></td>
  </tr>
</table>
<h3 id="ErrorLevel">ErrorLevel</h3>
<p><span class="ver">[v1.1.04+]</span> Diese Funktion ist in der Lage, bei Misserfolg eine Ausnahme auszul&ouml;sen (nicht zu verwechseln mit "keine &Uuml;bereinstimmung gefunden"). F&uuml;r mehr Informationen, siehe <a href="Catch.htm#RuntimeErrors">Laufzeitfehler</a>.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> kann Folgendes enthalten:</p>
<ul>
  <li>0, was bedeutet, dass kein Fehler aufgetreten ist.</li>
  <li>Einen String in folgender Form: <em>Compile error N at offset M: Beschreibung</em>. In diesem String ist <em>N</em> die PCRE-Fehlernummer, <em>M</em> die Position des betroffenen Zeichens im regul&auml;ren Ausdruck und <em>Beschreibung</em> ein Text, der den Fehler beschreibt.</li>
  <li>Eine negative Zahl, was bedeutet, dass ein Fehler w&auml;hrend der <em>Ausf&uuml;hrung</em> des regul&auml;ren Ausdrucks aufgetreten ist. Obwohl solche Fehler selten sind, sind die h&auml;ufigsten auftretenden Fehler  "zu viele m&ouml;gliche &Uuml;bereinstimmungen mit leeren Strings" (-22), "Rekursion zu tief" (-21) und "Limit der &Uuml;bereinstimmung erreicht" (-8). In diesem Fall sollte das Muster soweit wie m&ouml;glich umgestaltet werden, damit es restriktiver ist, zum Beispiel * mit ?, + oder eine Begrenzung wie {0,3} ersetzen.</li>
</ul>
<h3>Optionen</h3>
<p>Siehe <a href="../misc/RegEx-QuickRef.htm#Options">Optionen</a> f&uuml;r Modifikatoren wie "<span class="red">i)</span>abc", um die Abh&auml;ngigkeit von Gro&szlig;- und Kleinschreibung im Muster "abc" zu deaktivieren.</p>
<h3>Performance</h3>
<p>Um einfache Teilstrings zu ersetzen, verwendet <a href="StringReplace.htm">StringReplace</a>, weil es schneller als RegExReplace() ist.</p>
<p>Wenn bekannt ist, wie oft der String ersetzt wird, dann verbessert diese Anzahl im <em>Limit</em>-Parameter die Performance, weil die Suche fr&uuml;her gestoppt werden kann (was auch die Speicherauslastung auf dem System w&auml;hrend der Operation reduziert). Wenn zum Beispiel bekannt ist, dass nur eine &Uuml;bereinstimmung am Anfang eines langen Strings erfolgen kann, verwendet einen Limit von 1.</p>
<p>Um die Performance zu verbessern, werden die 100 aktuellsten regul&auml;ren Ausdr&uuml;cken im Speicher zwischengespeichert (in kompilierter Form).</p>
<p>Die <a href="../misc/RegEx-QuickRef.htm#Study">S-Option</a> kann manchmal die Performance eines regul&auml;ren Ausdrucks verbessern, welches oft verwendet wird (z. B. in einer Schleife).</p>
<h3>Bemerkungen</h3>
<p>Die meisten Zeichen wie abc123 k&ouml;nnen direkt in einem regul&auml;ren Ausdruck verwendet werden. Allerdings m&uuml;ssen die Zeichen <strong>\.*?+[{|()^$</strong> mit einem Backslash vorangestellt werden, damit sie direkt verwendet werden. Zum Beispiel ist <strong>\.</strong> ein direkt vorhandener Punkt und <strong>\\</strong> ist ein direkt vorhandener Backslash. Das Sch&uuml;tzen kann mit \Q...\E verhindert werden. Zum Beispiel: \QDirekt vorhandener Text\E.</p>
<p>Innerhalb eines regul&auml;ren Ausdrucks k&ouml;nnen bestimmte Sonderzeichen wie Tabulatoren und Zeilenumbr&uuml;che mit einem Akzent- (`) oder Backslash-Zeichen (\) gesch&uuml;tzt werden. Zum Beispiel ist `t das Gleiche wie \t.</p>
<p>Um die Grundlagen von regul&auml;ren Ausdr&uuml;cken kennenzulernen (oder das Ged&auml;chtnis ein wenig aufzufrischen), siehe <a href="../misc/RegEx-QuickRef.htm">RegEx-Kurz&uuml;bersicht</a>.</p>
<h3>Verwandte Befehle</h3>
<p><a href="RegExMatch.htm">RegExMatch()</a>, <a href="../misc/RegEx-QuickRef.htm">RegEx-Kurz&uuml;bersicht</a>, <a href="../misc/RegExCallout.htm">Callouts in regul&auml;ren Ausdr&uuml;cken</a>, <a href="StringReplace.htm">StringReplace</a>, <a href="../Functions.htm#InStr">InStr()</a></p>
<p>H&auml;ufige Quellen von Textdaten: <a href="FileRead.htm">FileRead</a>, <a href="URLDownloadToFile.htm">UrlDownloadToFile</a>, <a href="../misc/Clipboard.htm">Clipboard</a>, <a href="GuiControls.htm#Edit">GUI-Eingabefelder</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent">NeuerStr := RegExReplace("abc123123", "123$", "xyz")  <em>; Gibt "abc123xyz" zur&uuml;ck, weil $ nur eine &Uuml;bereinstimmung am Ende erlaubt.</em>
NeuerStr := RegExReplace("abc123", "i)^ABC")  <em>; Gibt 123 zur&uuml;ck, weil eine &Uuml;bereinstimmung durch die Unabh&auml;ngigkeit von Gro&szlig;- und Kleinschreibung gefunden wurde.</em>
NeuerStr := RegExReplace("abcXYZ123", "abc<span class="red">(.*)</span>123", "aaa<span class="red">$1</span>zzz")  <em>; Gibt "aaaXYZzzz" mithilfe der <a href="#BackRef">R&uuml;ckreferenz</a> <span class="red">$1</span> zur&uuml;ck.</em>
NeuerStr := RegExReplace("abc123abc456", "abc\d+", "", Ersatzanzahl)  <em>; Gibt "" zur&uuml;ck und setzt die Ersatzanzahl auf 2.</em>

<em>; Allgemeine RegEx-Beispiele k&ouml;nnen in der <a href="../misc/RegEx-QuickRef.htm">RegEx-Kurz&uuml;bersicht</a> gefunden werden.</em></pre>
</div>
</body>
</html>