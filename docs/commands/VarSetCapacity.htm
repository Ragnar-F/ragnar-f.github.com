<!DOCTYPE HTML>
<html>
<head>
<title>VarSetCapacity()</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>VarSetCapacity()</h1>

<p>Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei. Normalerweise ist das nur bei ungewöhnlichen Fällen wie <a href="DllCall.htm">DllCall</a> notwendig.</p>

<pre class="Syntax">Kapazitätserstattung := VarSetCapacity(VarName [, Kapazitätsbedarf, Füllbyte])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Kapazitätserstattung</dt>
  <dd><p>Die Anzahl an Bytes, die die Variable nun enthalten kann und größer gleich <em>Kapazitätserstattung</em> sein wird. Falls <em>VarName</em> keine gültige Variable ist (z. B. literaler String oder Zahl), wird eine 0 zurückgegeben. Wenn das System nicht genügend Speicher hat, um die Veränderung vorzunehmen (sehr selten), wird eine Fehlermeldung angezeigt und die aktuelle Kapazität zurückgegeben - dieses Verhalten wird wahrscheinlich in einer zukünftigen Version geändert.</p></dd>

  <dt>VarName</dt>
  <dd><p>Name der Variable (<em>ohne Anführungszeichen</em>). Zum Beispiel: <code>VarSetCapacity(MeineVar, 1000)</code>. Das kann auch eine dynamische Variable wie <code>Array%i%</code> oder der <a href="../Functions.htm#ByRef">ByRef-Parameter einer Funktion</a> sein.</p></dd>

  <dt>Kapazitätsbedarf</dt>
  <dd><p>Ist dieser Parameter nicht vorhanden, wird die aktuelle Kapazität der Variable zurückgegeben, zudem bleibt deren Inhalt unverändert. Ansonsten geht alles verloren, was sich in der Variable befindet (die Variable wird leer gemacht).</p>
      <p>Für <em>Kapazitätsbedarf</em> kann die Anzahl an Bytes angegeben werden, die die Variable nach der Anpassung enthalten soll. Bei Unicode-Strings sollte das die doppelte Länge sein. <em>Kapazitätsbedarf</em> schließt den internen Null-Terminator nicht mit ein. Zum Beispiel ermöglicht eine 1, dass die Variable zusätzlich zu deren internen Terminator bis zu einem Byte enthalten kann. Hinweis: Die Variable wird automatisch erweitert, wenn ihr später vom Script ein größerer Wert zugewiesen wird.</p> 
      <p>Da diese Funktion oft nur aufgerufen wird, um eine bestimmte Mindestkapazität für die Variable sicherzustellen, erfolgt das Verkleinern der Variable aus Performance-Gründen nur, wenn <em>Kapazitätsbedarf</em> eine 0 ist. Das heißt, dass die Kapazität der Variable nicht reduziert wird, wenn sie bereits größer ist als <em>Kapazitätsbedarf</em> (allerdings wird die Variable weiterhin leer gemacht, um Widersprüche zu vermeiden).</p>
      <p>Zum expliziten Verkleinern einer Variable ist es daher erforderlich, erst deren Speicher mit <code>VarSetCapacity(Var, 0)</code> freizugeben und danach <code>VarSetCapacity(Var, NeueKapazität)</code> zu verwenden -- oder lasse die Variable einfach so, wie sie ist, so dass sie sich selbst je nach Bedarf erweitern kann.</p>
      <p>Aus Performance-Gründen ist es möglich, dass das Freigeben einer Variable, deren vorherige Kapazität kleiner als 64 Zeichen (128 Bytes in Unicode-Builds) war, nicht funktionieren wird, weil deren Speicher von permanenter Art ist. In diesem Fall wird die aktuelle Kapazität zurückgegeben, anstatt eine 0.</p>
      <p>Aus Performance-Gründen wird der Speicher einer Variable, deren Kapazität kleiner als 4096 Bytes ist, nicht freigegeben, wenn in dieser ein leerer String gespeichert wird (z. B. <code>Var := ""</code>). Allerdings ist <code>VarSetCapacity(Var, 0)</code> in der Lage, diese Variable freizugeben.</p>
      <p><a name="neg1"></a>Seit v1.0.44.03 kann -1 in <em>Kapazitätsbedarf</em> angegeben werden, um die intern-gespeicherte Stringlänge der Variable auf die Länge des aktuellen Inhalts zu aktualisieren. Das ist besonders in Fällen nützlich, bei denen die Variable indirekt geändert wurde, wie z. B. das Übergeben deren <a href="../Variables.htm#amp">Adresse</a> per <a href="DllCall.htm">DllCall()</a>. In diesem Modus wird VarSetCapacity() die Länge in Bytes zurückgeben, anstatt die Kapazität.</p></dd>

  <dt>Füllbyte</dt>
  <dd><p>Dieser Parameter wird normalerweise weggelassen - in diesem Fall wird der Speicher der Zielvariable nicht initialisiert (stattdessen wird die Variable wie oben beschrieben einfach leer gemacht). Ansonsten kann eine Zahl zwischen 0 und 255 angegeben werden. Jedes Byte im Speicherbereich der Zielvariable (das deren aktuelle Kapazität ist, die größer als <em>Kapazitätsbedarf</em> sein kann) wird auf diese Zahl gesetzt. 0 ist dabei der am häufigsten benutzte Wert, die besonders in Fällen nützlich ist, bei denen die Variablen unbearbeitete Binärdaten enthalten, wie z. B. eine <a href="DllCall.htm#struct">DllCall-Struktur</a>).</p></dd>

</dl>

<h3>Bemerkungen</h3>
<p>Zusätzlich zu deren Nutzen bei <a href="DllCall.htm#str">DllCall</a> kann diese Funktion auch dazu verwendet werden, die Performance beim Erstellen eines Strings mittels stufenweiser Verkettung zu verbessern. Dadurch können mehrere automatische Größenanpassungen verhindert werden, wenn bekannt ist, wie groß die Stringlänge letztendlich sein wird. In so einem Fall muss <em>Kapazitätsbedarf</em> nicht genau sein: Falls die Kapazität zu klein ist, gilt weiterhin eine hohe Performance und die Variable beginnt damit, sich automatisch zu erweitern, wenn die Kapazität überschritten wird. Ist die Kapazität zu groß, wird einiges an Speicher verschwendet, aber nur vorübergehend, da der gesamte Speicher nach der Operation mithilfe von <code>VarSetCapacity(Var, 0)</code> oder <code>Var := ""</code> wieder freigegeben werden kann.</p>
<p><a href="_MaxMem.htm">#MaxMem</a> limitiert nur die automatische Erweiterung, das die Variable selbst durchführt. Diese Direktive hat kein Einfluss auf <a href="VarSetCapacity.htm">VarSetCapacity</a>.</p>
<h3>Siehe auch</h3>
<p><a href="DllCall.htm">DllCall</a>, <a href="_MaxMem.htm">#MaxMem</a>, <a href="NumPut.htm">NumPut</a>, <a href="NumGet.htm">NumGet</a></p>
<h3>Beispiel</h3>
<pre class="NoIndent"><em>; Optimieren, indem genügend Speicherplatz für MeineVar bereitgestellt wird.</em>
VarSetCapacity(MeineVar, 10240000)  <em>; ~10 MB</em>
Loop
{
    ...
    MeineVar = %MeineVar%%StringFürVerkettung%
    ...
}</pre>

<pre class="NoIndent"><em>; Berechnet den erforderlichen Zwischenspeicher für einen String.</em>
bytes_per_char := A_IsUnicode ? 2 : 1
max_chars := 500
max_bytes := max_chars * bytes_per_char

Loop 2
{
    <em>; Reserviert Speicher für die Verwendung mit DllCall.</em>
    VarSetCapacity(buf, max_bytes)

    if A_Index = 1
        <em>; Ändert die Variable indirekt per DllCall.</em>
        DllCall("wsprintf", <span class="red">"ptr", &amp;buf</span>, "str", "0x%08x", "uint", 4919)
    else
        <em>; Verwendet "str", um die Länge automatisch zu aktualisieren:</em>
        DllCall("wsprintf", <span class="blue">"str", buf</span>, "str", "0x%08x", "uint", 4919)

    <em>; Verkettet einen String, um zu zeigen, warum die Länge aktualisiert werden muss:</em>
    wrong_str := buf . "&lt;end&gt;"
    wrong_len := StrLen(buf)

    <em>; Aktualisiert die Länge der Variable.</em>
    VarSetCapacity(buf, -1)

    right_str := buf . "&lt;end&gt;"
    right_len := StrLen(buf)

    MsgBox,
    (
    Vor der Aktualisierung
      String: %wrong_str%
      Länge: %wrong_len%

    Nach der Aktualisierung
      String: %right_str%
      Länge: %right_len%
    )
}
</pre>

</body>
</html>
