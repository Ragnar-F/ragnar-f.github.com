<!DOCTYPE HTML>
<html>
<head>
<title>VarSetCapacity()</title>
<meta name="keywords" content="Befehl, Funktion, Interoperabilit&auml;t">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="wrapper">
  <div id="content"> 
    <script src="../navbar/NavScript.js" type="text/javascript"></script> 
    <script type="text/javascript">WriteNavLink(1);</script>
    <h1>VarSetCapacity()</h1>
    <p>Vergr&ouml;&szlig;ert die Aufnahmekapazit&auml;t einer Variable oder gibt deren Speicher frei. Normalerweise nur f&uuml;r ungew&ouml;hnliche Sachverhalte wie bei <a href="DllCall.htm">DllCall</a>.</p>
    <pre class="Syntax">Gew&auml;hrteKapazit&auml;t := VarSetCapacity(Variablenname [, Ben&ouml;tigteKapazit&auml;t, F&uuml;llbyte])</pre>
    <h3>Parameter</h3>
    <table class="info">
      <tr>
        <td style="width: 15%;">Gew&auml;hrteKapazit&auml;t</td>
        <td style="width: 85%;">Die Anzahl an Bytes, die die Variable nun enthalten kann, wobei sie gr&ouml;&szlig;er gleich <em>Gew&auml;hrteKapazit&auml;t</em> ist. Wenn der <em>Variablenname</em> ung&uuml;ltig ist (z. B. direkt vorhandener String oder Zahl), dann wird eine 0 zur&uuml;ckgegeben. Wenn das System nicht gen&uuml;gend Speicher zu Verf&uuml;gung hat, um die Ver&auml;nderung vorzunehmen (sehr selten), dann wird eine Fehlermeldung angezeigt und die aktuelle Kapazit&auml;t zur&uuml;ckgegeben - dieses Verhalten wird wahrscheinlich in einer zuk&uuml;nftigen Version ge&auml;ndert.</td>
      </tr>
      <tr>
        <td>Variablenname</td>
        <td>Der Name der Variable (<em>ohne Anf&uuml;hrungszeichen</em>). Zum Beispiel: <code>VarSetCapacity(EigeneVar, 1000)</code>. Kann auch eine dynamische Variable wie <code>Array%i%</code> oder der <a href="../Functions.htm#ByRef">ByRef-Parameter einer Funktion</a> sein.</td>
      </tr>
      <tr>
        <td>Ben&ouml;tigteKapazit&auml;t</td>
        <td><p>Wenn weggelassen, dann wird die aktuelle Kapazit&auml;t der Variable zur&uuml;ckgegeben und deren Inhalt nicht ge&auml;ndert. Ansonsten geht der komplette Inhalt der Variable verloren (die Variable wird leer gemacht).</p>
          <p>Bestimmt f&uuml;r die <em>Ben&ouml;tigteKapazit&auml;t</em> die Anzahl an Bytes, die die Variable nach dem Einstellen enthalten soll. Bei Unicode-Strings sollte die doppelte Anzahl angegeben werden. Die <em>Ben&ouml;tigteKapazit&auml;t</em> umfasst nicht den internen Null-Terminator. Zum Beispiel erlaubt eine 1, dass die Variable zus&auml;tzlich zum internen Terminator ein Byte enth&auml;lt. Hinweis: Die Variable wird automatisch erweitert, wenn ihr sp&auml;ter vom Script einen gr&ouml;&szlig;eren Wert zugewiesen wird.</p>
          <p>Da diese Funktion oft aufgerufen wird, um einfach sicherzustellen, dass die Variable eine bestimmte Mindestkapazit&auml;t hat, dann wird die Variable aus Gr&uuml;nden der Performance nur verkleinert, wenn die <em>Ben&ouml;tigteKapazit&auml;t</em> eine 0 ist. Das hei&szlig;t, wenn die Variablenkapazit&auml;t bereits gr&ouml;&szlig;er als die <em>Ben&ouml;tigteKapazit&auml;t</em> ist, wird sie nicht verkleinert (die Variable wird aber aus Konsistenzgr&uuml;nden weiterhin leer gemacht).</p>
          <p>Um daher eine Variable direkt zu verkleinern, gebt deren Speicher mit <code>VarSetCapacity(Var, 0)</code> frei und verwendet danach <code>VarSetCapacity(Var, NeueKapazit&auml;t)</code>, oder lasst sie einfach nach Bedarf automatisch um 0 erweitern.</p>
          <p>Aus Gr&uuml;nden der Performance k&ouml;nnte das Freigeben einer Variable mit einer Kapazit&auml;t kleiner als 64 Zeichen (128 Bytes in Unicode-Versionen) nicht funktionieren, weil deren Speicher permanenter Art ist. In diesem Fall wird die aktuelle Kapazit&auml;t anstelle von 0 zur&uuml;ckgegeben.</p>
          <p>Aus Gr&uuml;nden der Performance wird der Speicher einer Variable mit einer Kapazit&auml;t kleiner als 4096 Bytes nicht freigegeben, sobald ein leerer String gespeichert wird (z. B. <code>Var := ""</code>). Allerdings kann sie mit <code>VarSetCapacity(Var, 0)</code> freigegeben werden.</p>
          <p id="neg1">Seit v1.0.44.03 kann mit -1 f&uuml;r <em>Ben&ouml;tigteKapazit&auml;t</em> die intern gespeicherte String-L&auml;nge der Variable auf die L&auml;nge des aktuellen Inhalts aktualisiert werden. Besonders n&uuml;tzlich, wenn die Variable indirekt ge&auml;ndert wurde, wie die &Uuml;bergabe deren <a href="../Variables.htm#amp">Adresse</a> mithilfe von <a href="DllCall.htm">DllCall()</a>. In diesem Modus gibt VarSetCapacity() die L&auml;nge in Bytes anstelle der Kapazit&auml;t zur&uuml;ck.</p></td>
      </tr>
      <tr>
        <td>F&uuml;llbyte</td>
        <td>Dieser Parameter wird normalerweise weggelassen, in diesem Fall wird der Speicher der Zielvariable nicht initialisiert (stattdessen wird die Variable wie oben beschrieben einfach leer gemacht). Verwendet ansonsten eine Zahl zwischen 0 und 255. Jedes Byte im Speicherbereich der Zielvariable (deren aktuelle Kapazit&auml;t, die gr&ouml;&szlig;er als <em>Ben&ouml;tigteKapazit&auml;t</em> sein kann) wird auf diese Zahl gesetzt.  Die 0 ist mit Abstand der h&auml;ufigste verwendete Wert, weil sie bei Variablen mit unbearbeiteten Bin&auml;rdaten n&uuml;tzlich ist (z. B. bei einer <a href="DllCall.htm#struct">DllCall-Struktur</a>).</td>
      </tr>
    </table>
    <h3>Bemerkungen</h3>
    <p>Neben der <a href="DllCall.htm#str">DllCall</a>-Verwendung kann diese Funktion auch dazu verwendet werden, die Performance zu erh&ouml;hen, wenn ein String mithilfe der stufenweisen Verkettung konstruiert wird. Dadurch k&ouml;nnen mehrere automatische Gr&ouml;&szlig;enanpassungen verhindert werden, wenn bekannt ist, wie gro&szlig; letztendlich die Stringl&auml;nge ist. In einem solchen Fall muss die <em>Ben&ouml;tigteKapazit&auml;t</em> nicht genau sein: wenn die Kapazit&auml;t zu klein ist, dann ist die Performance weiterhin verbessert. Au&szlig;erdem beginnt die Variable mit der automatischen Erweiterung, wenn die Kapazit&auml;t verbraucht ist. Wenn die Kapazit&auml;t zu gro&szlig; ist, dann wird etwas zu viel Speicher verbraucht, aber nur vor&uuml;bergehend, denn der gesamte Speicher kann mithilfe von <em>VarSetCapacity(Var, 0)</em> oder <em>Var := ""</em> wieder freigegeben werden.</p>
    <p><a href="_MaxMem.htm">#MaxMem</a> limitiert nur die automatische Erweiterung der Variable. <a href="VarSetCapacity.htm">VarSetCapacity</a> wird aber dadurch nicht beeinflusst.</p>
    <h3>Verwandte Befehle</h3>
    <p><a href="DllCall.htm">DllCall</a>, <a href="_MaxMem.htm">#MaxMem</a></p>
    <h3>Beispiel</h3>
    <pre class="NoIndent"><em>; Optimieren, indem gen&uuml;gend Speicherplatz f&uuml;r EigeneVar bereitgestellt wird.</em>
VarSetCapacity(EigeneVar, 10240000)  <em>; ~10 MB</em>
Loop
{
    ...
    EigeneVar = %EigeneVar%%StringF&uuml;rVerkettung%
    ...
}</pre>
    <pre class="NoIndent"><em>; Erforderlichen Zwischenspeicher f&uuml;r einen String berechnen.</em>
bytes_per_char := A_IsUnicode ? 2 : 1
max_chars := 500
max_bytes := max_chars * bytes_per_char

Loop 2
{
    <em>; Speicher f&uuml;r die Verwendung von DllCall reservieren.</em>
    VarSetCapacity(buf, max_bytes)

    if A_Index = 1
        <em>; Die Variable indirekt mit DllCall &auml;ndern.</em>
        DllCall("wsprintf", <span class="red">"ptr", &amp;buf</span>, "str", "0x%08x", "uint", 4919)
    else
        <em>; "str" verwenden, um die L&auml;nge automatisch zu aktualisieren:</em>
        DllCall("wsprintf", <span class="blue">"str", buf</span>, "str", "0x%08x", "uint", 4919)

    <em>; Einen String verketten, um zu zeigen, warum die L&auml;nge aktualisiert werden muss:</em>
    wrong_str := buf . "&lt;end&gt;"
    wrong_len := StrLen(buf)

    <em>; L&auml;nge der Variable aktualisieren.</em>
    VarSetCapacity(buf, -1)

    right_str := buf . "&lt;end&gt;"
    right_len := StrLen(buf)

    MsgBox,
    (
    Vor der Aktualisierung
      String: %wrong_str%
      L&auml;nge: %wrong_len%

    Nach der Aktualisierung
      String: %right_str%
      L&auml;nge: %right_len%
    )
}
</pre>
  </div>
</div>
</body>
</html>