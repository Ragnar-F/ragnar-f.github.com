<!DOCTYPE HTML>
<html>
<head>
<title>VarSetCapacity()</title>
<meta name="keywords" content="Befehl, Funktion, Interoperabilit&auml;t">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <article>
      <h1>VarSetCapacity()</h1>
      <p>Vergr&ouml;&szlig;ert die Aufnahmekapazit&auml;t einer Variable oder gibt deren Speicher frei, das normalerweise nur in ungew&ouml;hnlichen F&auml;llen wie <a href="DllCall.htm">DllCall</a> notwendig ist.</p>
      <pre class="Syntax">Kapazit&auml;tserstattung := VarSetCapacity(Variablenname [, Kapazit&auml;tsbedarf, F&uuml;llbyte])</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Kapazit&auml;tserstattung</td>
          <td style="width: 85%;">Die Anzahl an Bytes, die die Variable nun enthalten kann und gr&ouml;&szlig;er gleich <em>Kapazit&auml;tserstattung</em> sein wird. Falls <em>Variablenname</em> keine g&uuml;ltige Variable ist (z. B. direkter String oder Zahl), wird eine 0 zur&uuml;ckgegeben. Wenn das System nicht gen&uuml;gend Speicher hat, um die Ver&auml;nderung vorzunehmen (sehr selten), wird eine Fehlermeldung angezeigt und die aktuelle Kapazit&auml;t zur&uuml;ckgegeben - dieses Verhalten wird wahrscheinlich in einer zuk&uuml;nftigen Version ge&auml;ndert.</td>
        </tr>
        <tr>
          <td>Variablenname</td>
          <td>Name der Variable (<em>ohne Anf&uuml;hrungszeichen</em>). Zum Beispiel: <code>VarSetCapacity(EigeneVar, 1000)</code>. Das kann auch eine dynamische Variable wie <code>Array%i%</code> oder der <a href="../Functions.htm#ByRef">ByRef-Parameter einer Funktion</a> sein.</td>
        </tr>
        <tr>
          <td>Kapazit&auml;tsbedarf</td>
          <td><p>Ist dieser Parameter nicht vorhanden, wird die aktuelle Kapazit&auml;t der Variable zur&uuml;ckgegeben, zudem bleibt deren Inhalt unver&auml;ndert. Ansonsten geht alles verloren, was sich in der Variable befindet (die Variable wird leer gemacht).</p>
            <p>F&uuml;r <em>Kapazit&auml;tsbedarf</em> kann die Anzahl an Bytes angegeben werden, die die Variable nach der Anpassung enthalten soll. Bei Unicode-Strings sollte das die doppelte L&auml;nge sein. <em>Kapazit&auml;tsbedarf</em> schlie&szlig;t den internen Null-Terminator nicht mit ein. Zum Beispiel erm&ouml;glicht eine 1, dass die Variable zus&auml;tzlich zu deren internen Terminator bis zu einem Byte enthalten kann. Hinweis: Die Variable wird automatisch erweitert, wenn ihr sp&auml;ter vom Script ein gr&ouml;&szlig;erer Wert zugewiesen wird.</p>
            <p>Da diese Funktion oft nur aufgerufen wird, um eine bestimmte Mindestkapazit&auml;t f&uuml;r die Variable sicherzustellen, erfolgt das Verkleinern der Variable aus Performance-Gr&uuml;nden nur, wenn <em>Kapazit&auml;tsbedarf</em> eine 0 ist. Das hei&szlig;t, dass die Kapazit&auml;t der Variable nicht reduziert wird, wenn sie bereits gr&ouml;&szlig;er als <em>Kapazit&auml;tsbedarf</em> ist (allerdings wird die Variable aus Konsistenzgr&uuml;nden weiterhin leer gemacht).</p>
            <p>Zum Verkleinern einer Variable ist es daher erforderlich, erst deren Speicher mit <code>VarSetCapacity(Var, 0)</code> freizugeben und danach <code>VarSetCapacity(Var, NeueKapazit&auml;t)</code> zu verwenden -- oder lasse die Variable einfach so, wie sie ist, so dass sie sich selbst je nach Bedarf erweitern kann.</p>
            <p>Aus Performance-Gr&uuml;nden ist es m&ouml;glich, dass das Freigeben einer Variable, deren vorherige Kapazit&auml;t kleiner als 64 Zeichen (128 Bytes in Unicode-Versionen) war, nicht funktionieren wird, weil deren Speicher von permanenter Art ist. In diesem Fall wird die aktuelle Kapazit&auml;t zur&uuml;ckgegeben, anstatt eine 0.</p>
            <p>Aus Performance-Gr&uuml;nden wird der Speicher einer Variable, deren Kapazit&auml;t kleiner als 4096 Bytes ist, nicht freigegeben, wenn in dieser ein leerer String gespeichert wird (z. B. <code>Var := ""</code>). Allerdings ist <code>VarSetCapacity(Var, 0)</code> in der Lage, diese Variable freizugeben.</p>
            <p id="neg1">Seit v1.0.44.03 kann -1 in <em>Kapazit&auml;tsbedarf</em> angegeben werden, um die intern-gespeicherte Stringl&auml;nge der Variable auf die L&auml;nge des aktuellen Inhalts zu aktualisieren. Das ist besonders in F&auml;llen n&uuml;tzlich, bei denen die Variable indirekt ge&auml;ndert wurde, wie z. B. das &Uuml;bergeben deren <a href="../Variables.htm#amp">Adresse</a> per <a href="DllCall.htm">DllCall()</a>. In diesem Modus wird VarSetCapacity() die L&auml;nge in Bytes zur&uuml;ckgeben, anstatt die Kapazit&auml;t.</p></td>
        </tr>
        <tr>
          <td>F&uuml;llbyte</td>
          <td>Dieser Parameter wird normalerweise weggelassen, damit der Speicher der Zielvariable nicht initialisiert wird (stattdessen wird die Variable wie oben beschrieben einfach leer gemacht). Ansonsten kann eine Zahl zwischen 0 und 255 angegeben werden. Jedes Byte im Speicherbereich der Zielvariable (das deren aktuelle Kapazit&auml;t ist, die gr&ouml;&szlig;er als <em>Kapazit&auml;tsbedarf</em> sein kann) wird auf diese Zahl gesetzt. 0 ist dabei der am h&auml;ufigsten benutzte Wert, die besonders in F&auml;llen n&uuml;tzlich ist, bei denen die Variablen unbearbeitete Bin&auml;rdaten enthalten, wie z. B. eine <a href="DllCall.htm#struct">DllCall-Struktur</a>).</td>
        </tr>
      </table>
      <h3>Bemerkungen</h3>
      <p>Zus&auml;tzlich zu deren Nutzen bei <a href="DllCall.htm#str">DllCall</a> kann diese Funktion auch dazu verwendet werden, die Performance beim Erstellen eines Strings mittels stufenweiser Verkettung zu verbessern. Dadurch k&ouml;nnen mehrere automatische Gr&ouml;&szlig;enanpassungen verhindert werden, wenn bekannt ist, wie gro&szlig; die Stringl&auml;nge letztendlich sein wird. In so einem Fall muss <em>Kapazit&auml;tsbedarf</em> nicht genau sein: Falls die Kapazit&auml;t zu klein ist, gilt weiterhin eine hohe Performance und die Variable beginnt damit, sich automatisch zu erweitern, wenn die Kapazit&auml;t &uuml;berschritten wird. Ist die Kapazit&auml;t zu gro&szlig;, wird einiges an Speicher verschwendet, aber nur vor&uuml;bergehend, da der gesamte Speicher nach der Operation mithilfe von <code>VarSetCapacity(Var, 0)</code> oder <code>Var := ""</code> wieder freigegeben werden kann.</p>
      <p><a href="_MaxMem.htm">#MaxMem</a> limitiert nur die automatische Erweiterung, das die Variable selbst durchf&uuml;hrt. Diese Direktive hat kein Einfluss auf <a href="VarSetCapacity.htm">VarSetCapacity</a>.</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="DllCall.htm">DllCall</a>, <a href="_MaxMem.htm">#MaxMem</a></p>
      <h3>Beispiel</h3>
      <pre class="NoIndent"><em>; Optimieren, indem gen&uuml;gend Speicherplatz f&uuml;r EigeneVar bereitgestellt wird.</em>
VarSetCapacity(EigeneVar, 10240000)  <em>; ~10 MB</em>
Loop
{
    ...
    EigeneVar = %EigeneVar%%StringF&uuml;rVerkettung%
    ...
}</pre>
      <pre class="NoIndent"><em>; Berechnet den erforderlichen Zwischenspeicher f&uuml;r einen String.</em>
bytes_per_char := A_IsUnicode ? 2 : 1
max_chars := 500
max_bytes := max_chars * bytes_per_char

Loop 2
{
    <em>; Reserviert Speicher f&uuml;r die Verwendung mit DllCall.</em>
    VarSetCapacity(buf, max_bytes)

    if A_Index = 1
        <em>; &Auml;ndert die Variable indirekt per DllCall.</em>
        DllCall("wsprintf", <span class="red">"ptr", &amp;buf</span>, "str", "0x%08x", "uint", 4919)
    else
        <em>; Verwendet "str", um die L&auml;nge automatisch zu aktualisieren:</em>
        DllCall("wsprintf", <span class="blue">"str", buf</span>, "str", "0x%08x", "uint", 4919)

    <em>; Verkettet einen String, um zu zeigen, warum die L&auml;nge aktualisiert werden muss:</em>
    wrong_str := buf . "&lt;end&gt;"
    wrong_len := StrLen(buf)

    <em>; Aktualisiert die L&auml;nge der Variable.</em>
    VarSetCapacity(buf, -1)

    right_str := buf . "&lt;end&gt;"
    right_len := StrLen(buf)

    MsgBox,
    (
    Vor der Aktualisierung
      String: %wrong_str%
      L&auml;nge: %wrong_len%

    Nach der Aktualisierung
      String: %right_str%
      L&auml;nge: %right_len%
    )
}
</pre>
    </article>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>