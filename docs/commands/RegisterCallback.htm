<!DOCTYPE HTML>
<html>
<head>
<title>RegisterCallback</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>RegisterCallback() <span class="ver">[v1.0.47+]</span></h1>

<p>Erstellt eine Maschinencode-Adresse, die ihren Aufruf zu einer <a href="../Functions.htm">Funktion</a> im Script weiterleitet.</p>

<pre class="Syntax">Adresse := RegisterCallback("Funktionsname" [, Optionen = "", Parameteranzahl = Formalanzahl, Ereignisinfo = Adresse])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Adresse</dt>
  <dd><p>Bei Erfolg gibt RegisterCallback() eine numerische Adresse zurück, die mit <a href="DllCall.htm">DllCall()</a> oder Ähnlichem aufgerufen werden kann. Bei Misserfolg gibt sie einen leeren String zurück. Fehler treten auf, wenn <em>Funktionsname</em>: 1) nicht existiert; 2) zu viele oder zu wenig Parameter in Bezug auf <em>Parameteranzahl</em> akzeptiert; oder 3) einen beliebigen <a href="../Functions.htm#ByRef">ByRef-Parameter</a> akzeptiert.</p></dd>

  <dt>Funktionsname</dt>
  <dd>
      <p>Ein <a href="../Functions.htm">Funktion</a>sname, der in Anführungszeichen gesetzt werden muss, wenn er ein literaler String ist. Diese Funktion wird automatisch aufgerufen, wann immer die <em>Adresse</em> aufgerufen wird. Die Funktion empfängt auch die Parameter, die an die <em>Adresse</em> übergeben wurden.</p>
      <p><span class="ver">[v1.1.06+]:</span> Anstelle eines Funktionsnamens kann ein <a href="../objects/Func.htm">Funktionsverweis</a> übergeben werden.</p>
    </dd>

  <dt>Optionen</dt>
  <dd><p>Verwende null oder mehrere der folgenden Wörter. Trenne diese Optionen jeweils mit einem Leerzeichen (z.B. <code>C Fast</code>).</p>
    <p><strong><a name="Fast" id="Fast"></a>Fast</strong> oder <strong>F</strong>: Verhindert, dass jedesmal ein neuer <a href="../misc/Threads.htm">Thread</a> startet, wenn <em>Funktionsname</em> aufgerufen wird. Zwar ist dies leistungsfähiger, allerdings sollte es nicht verwendet werden, wenn der Thread, in dem <em>Adresse</em> aufgerufen wurde, variiert (z. B. wenn das Callback durch eine eingehende Nachricht ausgelöst wurde). Denn <em>Funktionsname</em> kann globale Einstellungen eines Threads wie <a href="../misc/ErrorLevel.htm">ErrorLevel</a>, <a href="../Variables.htm#LastError">A_LastError</a> und das <a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a> jederzeit ändern. Weitere Informationen findest du bei den <a href="#Threads">Bemerkungen</a>.</p>
    <p><strong>CDecl</strong> oder <strong>C</strong>: Passt die <em>Adresse</em> an die "C"-Aufrufkonvention an. Diese Option lässt man üblicherweise weg, weil die Standard-Aufrufkonvention in der Regel für Callbacks genügt.</p></dd>

  <dt>Parameteranzahl</dt>
  <dd><p>Die Anzahl der Parameter, die <em>Adresse</em>'s Aufrufer übergeben muss. Fehlt dieser Parameter, gilt standardmäßig die Anzahl der Pflichtparameter, die in der <a href="../Functions.htm#define">Definition</a> von <em>Funktionsname</em> angegeben sind. In beiden Fällen muss sichergestellt werden, dass der Aufrufer genau diese Anzahl von Parametern übergibt.</p></dd>

  <dt>EventInfo</dt>
  <dd>
      <p>Ein Integer, den <em>Funktionsname</em> in <a href="../Variables.htm#EventInfo">A_EventInfo</a> sieht, wenn es über diese <em>Adresse</em> aufgerufen wird. Dies ist nützlich, wenn <em>Funktionsname</em> von mehr als einer <em>Adresse</em> aufgerufen wird. Ist dieser Parameter nicht vorhanden, gilt standardmäßig die <em>Adresse</em>. Hinweis: Im Gegensatz zu anderen globalen Einstellungen wird das A_EventInfo des <a href="../misc/Threads.htm">aktuellen Threads</a> nicht vom <a href="#Fast">Fast-Modus</a> beeinflusst.</p>
      <p>Wenn die script-ausführende EXE-Datei im 32-Bit-Format ist, muss dieser Parameter ein Wert zwischen 0 und 4294967295 sein. Wenn die EXE-Datei im 64-Bit-Format ist, kann dieser Parameter ein 64-Bit-Integer sein. Zwar gibt <a href="../Variables.htm#EventInfo">A_EventInfo</a> üblicherweise einen vorzeichenlosen Integer zurück, allerdings bietet AutoHotkey keine volle Unterstützung für vorzeichenlose 64-Bit-Integer, demzufolge könnten einige Operationen bewirken, dass der Wert in den vorzeichenbehafteten Bereich rutscht.</p></dd>

</dl>

<h3>Die Parameter der Callback-Funktion</h3>
<p>Eine <a href="../Functions.htm">Funktion</a>, die einer Callback-Adresse zugewiesen ist, kann bis zu 31 Parameter akzeptieren. <a href="../Functions.htm#optional">Optionale Parameter</a> sind erlaubt, so dass die Funktion von mehr als einem Aufrufer aufgerufen werden kann.</p>
<p><strong>32-Bit</strong>: Alle eingehenden Parameter sind vorzeichenlose 32-Bit-Integer. Wenn ein eingehender Parameter als vorzeichenbehafteter Integer vorgesehen ist, können negative Zahlen mit einem der folgenden Beispielen offenbart werden:</p>
<pre><em>; Methode #1</em>
if wParam &gt; 0x7FFFFFFF
    wParam := -(~wParam) - 1

<em>; Methode #2: Beruht auf der Tatsache, dass AutoHotkey von sich aus vorzeichenbehaftete 64-Bit-Integer verwendet.</em>
wParam := wParam &lt;&lt; 32 &gt;&gt; 32</pre>
<p><strong>64-Bit</strong>: Alle eingehenden Parameter sind vorzeichenbehaftete 64-Bit-Integer. AutoHotkey unterstützt von sich aus keine vorzeichenlose 64-Bit-Integers.</p>
<p>Wenn ein eingehender Parameter als String vorgesehen ist, dann ist das, was aktuell empfangen wird, die aktuelle Adresse des Strings. Mit <a href="StrPutGet.htm">StrGet</a> kann der String selbst abgerufen werden:</p>
<pre>MeinString := StrGet(MeinParameter)  <em>; AHK_L 46+</em></pre>
<p>Wenn ein eingehender Parameter die Adresse einer Struktur ist, kann man die einzelnen Elementen durch Befolgen der Schritte in "<a href="DllCall.htm#struct">DllCall-Strukturen</a>" extrahieren.</p>
<p id="Indirect"><span class="ver">[AHK_L 60+]:</span> Wenn die Funktion als <a href="../Functions.htm#Variadic">variadisch</a> deklariert ist, wird der letzte Parameter die <i>Adresse</i> des ersten Callback-Parameters erhalten, der einem Script-Parameter nicht zugewiesen wurde. Zum Beispiel:</p>
<pre>callback := RegisterCallback("Func", "F", 1)  <em>; Parameteranzahl muss angegeben werden.</em>
Func("Funktion wurde direkt aufgerufen.")  <em>; Ruft Func direkt auf.</em>
DllCall(callback, float, 10.5)  <em>; Ruft Func via Callback auf.</em>
Func(params*) {
    if IsObject(params)
        MsgBox % params[1]
    else
        MsgBox % <a href="NumGet.htm">NumGet</a>(params+0, 0, "float")
}</pre>
<p>Die meisten Callbacks verwenden die <i>stdcall</i>-Aufrufkonvention, die eine feste Anzahl an Parametern voraussetzt. In solchen Fällen muss <i>Parameteranzahl</i> beim Erstellen des Callbacks angegeben werden. Die <i>Parameteranzahl</i> kann in 64-Bit-Builds und bei <i>Cdecl</i>-Callbacks in 32-Bit-Builds weggelassen werden - in solchen Fällen werden alle optionalen Parameter ihre Standardwerte erhalten, und bei der Berechnung der Adresse ignoriert, um in <i>params</i> gespeichert zu werden.</p>
<h3>Was die Funktion per <em>Return</em> zurückgeben sollte</h3>
<p>Wenn die Funktion ein <a href="Return.htm">Return</a> verwendet, dessen Parameter entweder fehlt oder einen leeren Wert wie "" hat (oder überhaupt kein Return verwendet), wird eine 0 an <em>Adresse</em>'s Aufrufer zurückgegeben. Ansonsten sollte die Funktion einen Integer zwischen -2147483648 und 4294967295 zurückgeben, der dann an <em>Adresse</em>'s Aufrufer zurückgegeben wird.</p>
<h3 id="Threads">Fast vs. Slow</h3>
<p>Der Standard/Slow-Modus lässt die Funktion mit den Standardeinstellungen von Befehlen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> beginnen. Diese Standardeinstellungen können im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> geändert werden.</p>
<p>Der <a href="#Fast">Fast-Modus</a> erbt hingegen die globalen Einstellungen von einem <a href="../misc/Threads.htm">Thread</a>, der zum Zeitpunkt des Funktionsaufrufs aktiv war. Desweiteren werden jegliche Änderungen, die die Funktion bei globalen Einstellungen gemacht hat (einschließlich <a href="../misc/ErrorLevel.htm">ErrorLevel</a> und das <a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>), auch für den <a href="../misc/Threads.htm">aktuellen Thread</a> wirksam. Demzufolge sollte der Fast-Modus nur verwendet werden, wenn bekannt ist, in welchen Threads die Funktion aufgerufen wird.</p>
<p>Um die eigene Unterbrechung (oder von einem anderen Thread) zu verhindern, kann ein Callback <a href="Critical.htm">Critical</a> in der ersten Zeile verwenden. Allerdings ist dies nicht effektiv, wenn die Funktion indirekt via eingehende Nachricht kleiner als 0x312 aufgerufen wird (das Erhöhen von Critical's <a href="Critical.htm#Interval">Intervall</a> könnte helfen). Desweiteren kann <a href="Critical.htm">Critical</a> die Funktion nicht daran zu hindern, etwas zu tun, das zum indirekten Selbstaufruf führen könnte, wie z. B. durch <a href="PostMessage.htm">SendMessage</a> oder <a href="DllCall.htm">DllCall</a>.</p>
<h3>Speicher</h3>
<p>Jede Verwendung von RegisterCallback() bekommt eine kleine Speichermenge zugewiesen (32 Bytes plus System-Overhead). Da das Betriebssystem diesen Speicher automatisch beim Beenden des Scripts freigibt, muss jedes Script, das eine kleine <em>feste</em> Anzahl an Callbacks zugewiesen bekommt, den Speicher nicht explizit freigegeben. Dagegen sollte ein Script, das RegisterCallback() unendlich oft aufruft, folgende Funktion bei jedem unbenutzten Callback aufrufen:</p>
<pre>DllCall("GlobalFree", "Ptr", Adresse, "Ptr")</pre>
<h3>Siehe auch</h3>
<p><a href="DllCall.htm">DllCall()</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="OnExit.htm">OnExit</a>, <a href="../misc/Clipboard.htm#OnClipboardChange">OnClipboardChange</a>, <a href="Sort.htm#callback">Sort's Callback</a>, <a href="Critical.htm">Critical</a>, <a href="PostMessage.htm">Post/SendMessage</a>, <a href="../Functions.htm">Funktionen</a>, <a href="../misc/SendMessageList.htm">Liste mit Fensternachrichten</a>, <a href="../misc/Threads.htm">Threads</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel: Das folgende Script zeigt eine Zusammenfassung aller Fenster auf höchster Ebene an.</em>

<em>; Aus Performance- und Speichergründen wird RegisterCallback() nur einmal für einen bestimmten Callback aufgerufen:</em>
if not EnumAdresse  <em>; Fast-Modus ist okay, weil er nur von diesem Thread aufgerufen wird:</em>
    EnumAdresse := <strong>RegisterCallback</strong>("EnumWindowsProc", "Fast")

DetectHiddenWindows On  <em>; Aufgrund des Fast-Modus wird diese Einstellung auch für Callback wirksam.</em>

<em>; Übergibt die Kontrolle an EnumWindows(), das Callback wiederholend aufruft:</em>
DllCall("EnumWindows", Ptr, EnumAdresse, Ptr, 0)
MsgBox %Ausgabe%  <em>; Zeigt die gesammelten Informationen von Callback an.</em>

EnumWindowsProc(hwnd, lParam)
{
    global Ausgabe
    WinGetTitle, Titel, ahk_id %hwnd%
    WinGetClass, Klasse, ahk_id %hwnd%
    if Titel
        Ausgabe .= "HWND: " . hwnd . "`tTitel: " . Titel . "`tKlasse: " . Klasse . "`n"
    return true  <em>; Setzt EnumWindows() fort, bis alle Fenster abgearbeitet wurden.</em>
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel: Das folgende Script zeigt, wie ein GUI-Fenster zu einer Unterklasse gemacht werden kann,
; wenn man sein WindowProc an einen neuen WindowProc weiterleitet. In diesem Fall wird die Hintergrundfarbe
; des Text-Steuerelements auf eine benutzerdefinierte Farbe gesetzt.</em>

Texthintergrundfarbe := 0xFFBBBB  <em>; Eine benutzerdefinierte Farbe im BGR-Format.</em>
Pinsel := DllCall("CreateSolidBrush", UInt, Texthintergrundfarbe)

Gui, Add, Text, HwndMeinTextHwnd, Hier ein Text mit einer`nbenutzerdefinierter Hintergrundfarbe.
Gui +LastFound
GuiHwnd := WinExist()

<em>; 64-Bit-Scripts müssen SetWindowLongPtr statt SetWindowLong aufrufen:</em>
SetWindowLong := A_PtrSize=8 ? "SetWindowLongPtr" : "SetWindowLong"

WindowProcNeu := <strong>RegisterCallback</strong>("WindowProc", ""  <em>; Mit "" wird der Fast-Modus beim Setzen der Unterklasse verhindert.</em>
    , <strong>4</strong>, MeinTextHwnd)  <em>; Es muss die genaue Parameteranzahl angegeben werden, wenn der EventInfo-Parameter vorhanden ist.</em>
WindowProcAlt := DllCall(SetWindowLong, Ptr, GuiHwnd, Int, -4  <em>; -4 ist GWL_WNDPROC</em>
    , Ptr, WindowProcNeu, Ptr)  <em>; Wert muss auf Ptr oder UPtr anstatt auf Int gesetzt werden.</em>

Gui Show
return

WindowProc(hwnd, uMsg, wParam, lParam)
{
    Critical
    global Texthintergrundfarbe, Pinsel, WindowProcAlt
    if (uMsg = 0x138 &amp;&amp; lParam = A_EventInfo)  <em>; 0x138 ist WM_CTLCOLORSTATIC.</em>
    {
        DllCall("SetBkColor", UInt, wParam, Ptr, Texthintergrundfarbe)
        return Pinsel  <em>; Gibt HBRUSH zurück, um dem OS mitzuteilen, dass wir HDC geändert haben.</em>
    }
    <em>; Ansonsten (da oben nichts zurückgegeben wurde) werden alle unbehandelten Ereignisse an das originale WindowProc übergeben.</em>
    return DllCall("CallWindowProc", Ptr, WindowProcAlt, Ptr, hwnd, UInt, uMsg, Ptr, wParam, Ptr, lParam)
}

GuiClose:
ExitApp</pre>

</body>
</html>
