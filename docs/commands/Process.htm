<!DOCTYPE HTML>
<html>
<head>
<title>Process</title>
<meta name="keywords" content="Befehl, Prozess">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Process</h1>
      <p>F&uuml;hrt verschiedene Operationen an einem Prozess aus: &Uuml;berpr&uuml;fung seiner Existenz, &Auml;nderung seiner Priorit&auml;t, Schlie&szlig;en, Warten auf Schlie&szlig;en des Prozesses.</p>
      <pre class="Syntax">Process, Befehl, PID-oder-Name [, Param3]</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Befehl</td>
          <td style="width: 85%;"><p>Eins der folgenden W&ouml;rter:</p>
            <p><strong>Exist</strong>: Setzt <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf die Prozess-ID (PID), falls ein passender Prozess gefunden wird, ansonsten auf 0. Ist der <em>PID-oder-Name</em>-Parameter leer, wird die PID des Scripts abgerufen. Alternativ kann die einzeilige Methode <code>PID := DllCall("GetCurrentProcessId")</code> verwendet werden, um die PID des Scripts abzurufen.</p>
            <p><strong>Close</strong>: Wenn ein passender Prozess erfolgreich beendet wird, enth&auml;lt <a href="../misc/ErrorLevel.htm">ErrorLevel</a> die zuletzt verwendete Prozess-ID (PID). Andernfalls wird ErrorLevel auf 0 gesetzt (das hei&szlig;t, dass der Prozess nicht gefunden wurde oder nicht richtig beendet werden konnte). Das Schlie&szlig;en eines Prozesses kann dazu f&uuml;hren, dass der Prozessablauf an einem kritischen Punkt unterbrochen wird oder nicht gespeicherte Daten in seinem Fenster verloren gehen k&ouml;nnen, falls vorhanden. Da der Prozess abrupt beendet wird, sollte diese Methode nur verwendet werden, wenn sein Fenster mit <a href="WinClose.htm">WinClose</a> nicht geschlossen werden kann.</p>
            <p><strong>List</strong>: Obwohl <em>List</em> noch nicht unterst&uuml;tzt wird, wird im <a href="#ListEx">Beispiele-Abschnitt</a> demonstriert, wie mit DllCall eine Prozessliste ermittelt werden kann.</p>
            <p id="Priority"><strong>Priority</strong>: &Auml;ndert die Priorit&auml;t (wie im Windows Task-Manager angezeigt) des ersten passenden Prozesses auf <em>Param3</em> und setzt <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf dessen Prozess-ID (PID). Ist der <em>PID-oder-Name</em>-Parameter leer, wird die Priorit&auml;t vom Script ge&auml;ndert. Falls kein passender Prozess gefunden wird oder Probleme beim &Auml;ndern der Priorit&auml;t auftreten, wird ErrorLevel auf 0 gesetzt.</p>
            <p><em>Param3</em> sollte einer der folgenden Buchstaben oder W&ouml;rter sein: L (oder Low), B (oder BelowNormal), N (oder Normal), A (oder AboveNormal), H (oder High), R (oder Realtime). Da BelowNormal und AboveNormal in Windows 95/98/Me/NT4 nicht unterst&uuml;tzt werden, werden diese automatisch mit <em>Normal</em> ersetzt. Hinweis: Jeder Prozess, der nicht darauf ausgelegt ist, in Echtzeit (Realtime) zu laufen, reduziert m&ouml;glicherweise die Systemstabilit&auml;t, wenn er auf diese Priorit&auml;t gesetzt wird.</p>
            <p><strong>Wait</strong>: Wartet bis zu <em>Param3</em> Sekunden (kann einen Dezimalpunkt enthalten), bis ein passender Prozess vorhanden ist. Wenn <em>Param3</em> nicht vorhanden ist, wird der Befehl unendlich lang warten. Wenn ein passender Prozess entdeckt wird, wird <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf die Prozess-ID (PID) gesetzt. Wenn der Befehl das Zeitlimit &uuml;berschreitet, wird ErrorLevel auf 0 gesetzt.</p>
            <p><strong>WaitClose</strong>: Wartet bis zu <em>Param3</em> Sekunden darauf (kann einen Dezimalpunkt enthalten), dass ALLE passenden Prozesse geschlossen werden. Wenn <em>Param3</em> nicht vorhanden ist, wird der Befehl unendlich lang warten. Wenn alle passenden Prozesse geschlossen sind, wird <a href="../misc/ErrorLevel.htm">Errorlevel</a> auf 0 gesetzt. Wenn der Befehl das Zeitlimit &uuml;berschreitet, wird ErrorLevel auf die Prozess-ID (PID) des ersten passenden Prozesses gesetzt, der noch vorhanden ist.</p></td>
        </tr>
        <tr>
          <td>PID-oder-Name </td>
          <td><p>Dieser Parameter ist entweder eine Nummer (die PID) oder ein Prozessname, wie unten beschrieben. Zudem kann dieser Parameter leer gelassen werden, um die Priorit&auml;t des Scripts selbst zu &auml;ndern.</p>
            <p>PID: Die Prozess-ID - eine Nummer, die einen bestimmten Prozess eindeutig identifiziert (diese Nummer ist nur w&auml;hrend der Laufzeit dieses Prozesses g&uuml;ltig). Die PID eines neu gestarteten Prozesses kann mit dem <a href="Run.htm">Run</a>-Befehl ermittelt werden. Ebenso kann die PID eines Fensters mit <a href="WinGet.htm">WinGet</a> abgerufen werden. Der Process-Befehl selbst kann auch dazu verwendet werden, eine PID zu ermitteln.</p>
            <p>Name: Der Prozessname ist im Prinzip der Name der ausf&uuml;hrbaren Datei (ohne Pfad), z. B. notepad.exe oder winword.exe. Da ein Name mit mehreren laufenden Prozessen &uuml;bereinstimmen kann, wird nur der erste Prozess bearbeitet. Der Name ist nicht von der Gro&szlig;-/Kleinschreibung abh&auml;ngig.</p></td>
        </tr>
        <tr>
          <td>Param3</td>
          <td>Siehe <em>Befehl</em>-Parameter f&uuml;r Details.</td>
        </tr>
      </table>
      <h3>ErrorLevel</h3>
      <p>Siehe <em>Befehl</em>-Parameter f&uuml;r Details.</p>
      <h3>Bemerkungen</h3>
      <p>Bei <em>Wait</em> und <em>WaitClose</em> werden Prozesse alle 100 Millisekunden &uuml;berpr&uuml;ft; sobald die Bedingung erf&uuml;llt ist, h&ouml;rt der Befehl auf, zu warten. Das hei&szlig;t, dass der Befehl diese Zeit&uuml;berschreitung nicht erst abwartet, sondern <a href="../misc/ErrorLevel.htm">ErrorLevel</a> sofort auf einen oben genannten Wert setzt und die Ausf&uuml;hrung des Scripts fortsetzt. W&auml;hrend der Befehl im Wartezustand ist, k&ouml;nnen neue <a href="../misc/Threads.htm">Threads</a> per <a href="../Hotkeys.htm">Hotkey</a>, <a href="Menu.htm">benutzerdefinierte Men&uuml;eintr&auml;ge</a> oder <a href="SetTimer.htm">Timer</a> gestartet werden.</p>
      <p>Damit der Process-Befehl in Windows NT4 funktioniert, wird die Datei PSAPI.DLL ben&ouml;tigt, welche normalerweise bereits im AutoHotkey-Installationsverzeichnis enthalten ist (d. h., dass keine zus&auml;tzlichen Installationsschritte notwendig sind). Um diesen Befehl innerhalb eines <a href="../Scripts.htm#ahk2exe">kompilierten Scripts</a> in Windows NT4 zu verwenden, muss eine Kopie von PSAPI.DLL im Ordner des Scripts oder in eins der angegebenen Verzeichnisse aus der PATH-Umgebungsvariable eingef&uuml;gt werden (einige NT4-Systeme verf&uuml;gen bereits &uuml;ber die DLL).</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="Run.htm">Run</a>, <a href="WinGet.htm">WinGet</a>, <a href="WinClose.htm">WinClose</a>, <a href="WinKill.htm">WinKill</a>, <a href="WinWait.htm">WinWait</a>, <a href="WinWaitClose.htm">WinWaitClose</a>, <a href="IfWinExist.htm">IfWinExist</a></p>
      <h3>Beispiele</h3>
      <pre class="NoIndent"><em>; Beispiel #1:</em>

Run Notepad.exe, , , NeuPID
Process, priority, %NeuPID%, High
MsgBox Die PID des neu gestarteten Editors ist %NeuPID%.</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #2:</em>

Process, wait, Notepad.exe, 5.5
NeuPID = %ErrorLevel%  <em>; Den Wert sofort speichern, da sich ErrorLevel st&auml;ndig &auml;ndert.</em>
If NeuPID = 0
{
    MsgBox Innerhalb von 5.5 Sekunden ist kein passender Prozess erschienen.
    Return
}
<em>; Ansonsten:</em>
MsgBox Ein passender Prozess ist erschienen (Prozess-ID ist %NeuPID%).
Process, priority, %NeuPID%, Low
Process, priority, , High  <em>; Das Script selbst setzt sich auf hohe Priorit&auml;t.</em>
WinClose Unbenannt - Editor
Process, WaitClose, %NeuPID%, 5
If ErrorLevel <em>; Die PID ist noch vorhanden.</em>
    MsgBox Der Prozess wurde nicht innerhalb von 5 Sekunden geschlossen.</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #3: Ein Hotkey, der die Priorit&auml;t des Prozesses vom aktiven Fenster &auml;ndert:</em>

#z:: <em>; Hotkey: Win+Z</em>
WinGet, aktiv_pid, PID, A
WinGetTitle, aktiv_titel, A
Gui, 5:Add, Text,, Dr&uuml;cke ESCAPE, um das Fenster zu schlie&szlig;en, oder w&auml;hle mit einem Doppelklick eine neue Priorit&auml;tsstufe f&uuml;r das folgende Fenster:`n%aktiv_titel%
Gui, 5:Add, ListBox, vEigeneListBox gEigeneListBox r5, Normal|High|Low|BelowNormal|AboveNormal
Gui, 5:Add, Button, default, OK
Gui, 5:Show,, Priorit&auml;t bestimmen
Return

5GuiEscape:
5GuiClose:
Gui, Destroy
Return

EigeneListBox:
If A_GuiEvent &lt;&gt; DoubleClick
    Return
<em>; sonst bis zum n&auml;chsten Label springen:</em>
5ButtonOK:
GuiControlGet, EigeneListBox
Gui, Destroy
Process, Priority, %aktiv_pid%, %EigeneListBox%
If ErrorLevel
    MsgBox Erfolg: Die Priorit&auml;t wurde auf "%EigeneListBox%" gesetzt.
Else
    MsgBox Fehler: Die Priorit&auml;t wurde nicht auf "%EigeneListBox%" gesetzt.
Return</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent" id="ListEx"><em>; Beispiel #4: Ermittelt mit DllCall eine Liste aller laufenden Prozesse und zeigt sie in einer MsgBox an.</em>

d := "  |  "  <em>; String-Trennzeichen</em>
s := 4096  <em>; Gr&ouml;&szlig;e der Puffer und Arrays (4 KB)</em>

Process, Exist  <em>; Setzt ErrorLevel auf die PID des laufenden Scripts</em>
<em>; Ermittelt den Handle des Scripts mit PROCESS_QUERY_INFORMATION (0x0400)</em>
h := DllCall("OpenProcess", "UInt", 0x0400, "Int", false, "UInt", ErrorLevel, "Ptr")
<em>; &Ouml;ffnet einen anpassbaren Zugriffstoken mit diesem Prozess (TOKEN_ADJUST_PRIVILEGES = 32)</em>
DllCall("Advapi32.dll\OpenProcessToken", "Ptr", h, "UInt", 32, "PtrP", t)
VarSetCapacity(ti, 16, 0)  <em>; Struktur der Berechtigungen</em>
NumPut(1, ti, 0, "UInt")  <em>; Einen Eintrag in das Array mit Berechtigungen ...</em>
<em>; Ermittelt die lokale eindeutige Kennung der Debug-Berechtigung:</em>
DllCall("Advapi32.dll\LookupPrivilegeValue", "Ptr", 0, "Str", "SeDebugPrivilege", "Int64P", luid)
NumPut(luid, ti, 4, "Int64")
NumPut(2, ti, 12, "UInt")  <em>; Aktiviert die Berechtigung: SE_PRIVILEGE_ENABLED = 2</em>
<em>; Aktualisiert die Berechtigungen von diesem Prozess mit dem neuen Zugriffstoken:</em>
DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", t, "Int", false, "Ptr", &amp;ti, "UInt", 0, "Ptr", 0, "Ptr", 0)
DllCall("CloseHandle", "Ptr", t)  <em>; Handle vom Zugriffstoken schlie&szlig;en, um Speicherplatz zu sparen.</em>
DllCall("CloseHandle", "Ptr", h)  <em>; Handle vom Prozess schlie&szlig;en, um Speicherplatz zu sparen.</em>

hModule := DllCall("LoadLibrary", "Str", "Psapi.dll")  <em>; Bibliothek vorher laden, um die Performance zu erh&ouml;hen.</em>
s := VarSetCapacity(a, s)  <em>; Ein Array, das die Liste mit Prozesskennungen erh&auml;lt:</em>
c := 0  <em>; Z&auml;hler f&uuml;r Prozesskennungen</em>
DllCall("Psapi.dll\EnumProcesses", "Ptr", &amp;a, "UInt", s, "UIntP", r)
Loop, % r // 4  <em>; Parst das Array nach Kennungen in DWORD-Formaten (32 Bit):</em>
{
   id := NumGet(a, A_Index * 4, "UInt")
   <em>; &Ouml;ffnet Prozess mit: PROCESS_VM_READ (0x0010) | PROCESS_QUERY_INFORMATION (0x0400)</em>
   h := DllCall("OpenProcess", "UInt", 0x0010 | 0x0400, "Int", false, "UInt", id, "Ptr")
   If !h
      continue
   VarSetCapacity(n, s, 0)  <em>; Ein Puffer, der den Basisnamen des Moduls erh&auml;lt:</em>
   e := DllCall("Psapi.dll\GetModuleBaseName", "Ptr", h, "Ptr", 0, "Str", n, "UInt", A_IsUnicode ? s//2 : s)
   If !e    <em>; R&uuml;ckfallmethode f&uuml;r 64-Bit-Prozesse, falls im 32-Bit-Modus:</em>
      If e := DllCall("Psapi.dll\GetProcessImageFileName", "Ptr", h, "Str", n, "UInt", A_IsUnicode ? s//2 : s)
         SplitPath n, n
   DllCall("CloseHandle", "Ptr", h)  <em>; Handle vom Prozess schlie&szlig;en, um Speicherplatz zu sparen.</em>
   If (n && e)  <em>; Wenn Abbild ungleich 0 ist, zur Liste hinzuf&uuml;gen:</em>
      l .= n . d, c++
}
DllCall("FreeLibrary", "Ptr", hModule)  <em>; Bibliothek entladen, um Speicher freizugeben.</em>
<em>;Sort, l, C  ; Hebt die Kommentierung dieser Zeile auf, um die Liste alphabetisch zu sortieren.</em>
MsgBox, 0, %c% Prozesse, %l%</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent" id="ListCom"><em>; Beispiel #5: Ermittelt &uuml;ber COM eine Liste von laufenden Prozessen.</em>

Gui, Add, ListView, x2 y0 w400 h500, Prozessname|Befehlszeile
for Prozess in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Process")
    LV_Add("", Prozess.Name, Prozess.CommandLine)
Gui, Show,, Prozessliste

<em>; Win32_Prozess: <a href="http://msdn.microsoft.com/en-us/library/aa394372.aspx">http://msdn.microsoft.com/en-us/library/aa394372.aspx</a></em>
</pre>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>