<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>BlockInput</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>BlockInput</h1>

<p>Deaktiviert oder aktiviert die F&auml;higkeit des Benutzers, mit dem Computer mittels Tastatur und Maus zu interagieren. </p>

<pre class="Syntax">BlockInput, Modus </pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Modus</td>
    <td width="85%"><p><strong><u>Modus 1</u></strong>: Eins der folgenden W&ouml;rter:</p>
      <p>On: Der Benutzer wird davon abgehalten, mit dem Computer zu interagieren (Maus- und Tastaturaktionen haben keine Wirkung). </p>
      <p><strong>Off</strong>: Eingaben sind wieder m&ouml;glich.</p>
      <p><u><strong>Modus 2</strong></u> (hat keine Wirkung in Windows 9x): Dieser Modus l&auml;uft unabh&auml;ngig von den Anderen. Zum Beispiel wird <em>BlockInput On</em> solange die Eingaben weiter blockieren, bis <em>BlockInput Off</em> eingeleitet wird, selbst wenn ein nachfolgender Befehl aktiv ist.</p>
      <p><strong>Send</strong>: Die Tastatur- und Mausaktionen des Benutzers werden ignoriert, w&auml;hrend <a href="Send.htm">Send</a> oder <a href="Send.htm">SendRaw</a> aktiv sind (nur der traditionelle <a href="SendMode.htm">SendEvent Mode</a>). Somit werden die k&uuml;nstlichen Tastatureingaben nicht von den Tastatureingaben des Benutzers unterbrochen. Wenn der Send-Befehl beendet wird, dann ist eine Eingabe wieder m&ouml;glich (es sei denn, es wird noch durch <em>BlockInput On</em> geblockt).</p>
      <p><strong>Mouse</strong>: Die Tastatur- und Mausaktionen des Benutzers werden ignoriert, w&auml;hrend <a href="Click.htm">Click</a>, <a href="MouseMove.htm">MouseMove</a>, <a href="MouseClick.htm">MouseClick</a> oder <a href="MouseClickDrag.htm">MouseClickDrag</a> aktiv sind (nur der traditionelle <a href="SendMode.htm">SendEvent Mode</a>). Somit werden die simulierten Mausaktionen nicht von den Mausaktionen des Benutzers unterbrochen. Wenn der Maus-Befehl beendet wird, dann ist eine Eingabe wieder m&ouml;glich (es sei denn, es wird noch durch <em>BlockInput On</em> geblockt).</p>
      <p><strong>SendAndMouse</strong>: Eine Kombination von <i>Send</i> und <i>Mouse</i>.</p>
      <p><strong>Default</strong>: Sowohl der <em>Send</em>- als auch der <em>Mouse</em>-Modus werden deaktiviert, der aktuelle Blockierungszustand der Eingabe bleibt jedoch unver&auml;ndert. Wenn zum Beispiel <em>BlockInput On</em> noch aktiv ist, dann hat <em>BlockInput Default</em> keinen Effekt.</p>
      <p><u><strong><a name="MouseMove"></a></strong></u><strong><u>Modus 3</u></strong><u> (funktioniert nicht in Windows 9x; ben&ouml;tigt v1.0.43.11+):</u> Dieser Modus l&auml;uft unabh&auml;ngig von den Anderen. Zum Beispiel werden Mausbewegungen solange weiter geblockt, bis <em>BlockInput On</em> und <em>BlockInput MouseMove</em> deaktiviert werden.</p>
      <p><strong>MouseMove</strong>: Der Mauszeiger reagiert nicht auf die physische Mausbewegung des Benutzers (DirectInput-Anwendungen sind eine m&ouml;gliche Ausnahme). Sobald ein Script diesen Befehl verwendet, wird der <a href="_InstallMouseHook.htm">Maus-Hook</a> installiert (wenn es nicht bereits geschehen ist). Zus&auml;tzlich wird das Script <a href="_Persistent.htm">persistent</a>, d. h. <a href="ExitApp.htm">ExitApp</a> sollte zum Beenden des Scripts verwendet werden. Der Maus-Hook bleibt solange installiert, bis die Befehle <a href="Suspend.htm">Suspend</a> oder <a href="Hotkey.htm">Hotkey</a> verwendet werden. In diesem Fall wird der Hook entfernt, wenn er nicht explizit von Hotkeys oder Hotstrings ben&ouml;tigt wird (siehe <a href="_Hotstring.htm">#Hotstring NoMouse</a>).</p>
      <p><strong>MouseMoveOff</strong>: Erlaubt dem Benutzer, den Mauszeiger zu bewegen.</p></td>
  </tr>
</table>

<h3>Bemerkungen</h3>
<p>Bei Verwendung von BlockInput sollte oft <a href="SendMode.htm"><em>SendMode Input</em></a> oder <em><a href="SendMode.htm">SendMode Play</a></em> in Betracht gezogen werden, damit die Tastatureingaben und Mausklicks nicht unterbrochen werden k&ouml;nnen. Denn im Gegensatz zum BlockInput verwerfen solche Modi nicht die Eingabe des Benutzers w&auml;hrend des Send-Befehls. Solche Tastatureingaben werden stattdessen zwischengespeichert und danach gesendet. Durch das Vermeiden von BlockInput wird auch verhindert, dass festgeklemmte Tasten umgangen werden m&uuml;ssen, wie im n&auml;chsten Abschnitt beschrieben.</p>
<p>Wenn BlockInput aktiviert wird, w&auml;hrend der Benutzer Tasten gedr&uuml;ckt h&auml;lt, dann bleiben diese Tasten dauerhaft gedr&uuml;ckt. Das kann verhindert werden, wenn auf das Loslassen von Tasten gewartet wird, bevor BlockInput aktiviert wird. Zum Beispiel:</p>
<pre>^!p::
KeyWait Control  <em>; Warten, bis die Taste losgelassen wird.  KeyWait f&uuml;r jede Modifikator-Taste verwenden.</em>
KeyWait Alt
BlockInput On
<em>; ... Tastatureingaben und Mausklicks senden ...</em>
BlockInput Off
Return</pre>
<p>Das Blocken der Eingabe wird automatisch und sofort deaktiviert, sobald die ALT-Taste gesendet wird (wird danach wieder aktiviert).</p>
<p>Die Tabelle unten zeigt, wie sich BlockInput bei verschiedenen Windows-Versionen verh&auml;lt. Nur Strg+Alt+Entf hebt durch eine API-Funktion von Windows das Blocken wieder auf.</p>
<table class="info">
  <tr>
    <th width="37%"><strong><em>Betriebssystem </em></strong></th>
    <th width="63%"><strong><em>Ergebnis von BlockInput </em></strong></th>
  </tr>
  <tr>
    <td>Windows 95 </td>
    <td>Keinen Effekt. </td>
  </tr>
  <tr>
    <td>Windows 98/Me</td>
    <td>Benutzereingabe wird blockiert und AutoHotkey ist <strong>nicht f&auml;hig</strong>, Eingaben zu simulieren. </td>
  </tr>
  <tr>
    <td>Windows NT 4 (<em>ohne</em> Service-Pack 6) </td>
    <td>Keinen Effekt. </td>
  </tr>
  <tr>
    <td>Windows NT 4 (<em>mit</em> Service-Pack 6) </td>
    <td>Benutzereingabe wird blockiert, aber AutoHotkey kann weiterhin Tastatureingaben und Mausklicks simulieren. </td>
  </tr>
  <tr>
    <td>Windows 2000/XP</td>
    <td>Benutzereingabe wird blockiert, aber AutoHotkey kann weiterhin Tastatureingaben und Mausklicks simulieren. </td>
  </tr>
</table>
<p><br> Windows 98/Me: Obwohl Scripts nicht in der Lage sind, Tastatureingaben und Mausklicks w&auml;hrend BlockInput zu senden, funktionieren Befehle wie <a href="WinMove.htm">WinMove</a> nach wie vor. <a href="ControlSend.htm">ControlSend</a> k&ouml;nnte auch funktionieren. </p>
<p>Verschiedene Arten von <a href="_UseHook.htm">Hook-Hotkeys</a> k&ouml;nnen immer noch ausgel&ouml;st werden, wenn BlockInput aktiv ist. Beispielsweise "MButton" (Maus-Hook) und "LWin & Space" (Tastatur-Hook mit eindeutigem Pr&auml;fix anstelle von Modifikatoren "$#").</p>
<p> Eingabe wird automatisch wieder erm&ouml;glicht, wenn das Script beendet wird.</p>
<h3>Verwandte Befehle</h3>
<p><a href="SendMode.htm">SendMode</a>, <a href="Send.htm">Send</a>, <a href="Click.htm">Click</a>, <a href="MouseMove.htm">MouseMove</a>, <a href="MouseClick.htm">MouseClick</a>, <a href="MouseClickDrag.htm">MouseClickDrag</a></p>
<h3>Beispiel</h3>
<pre class="NoIndent">If A_OSType &lt;&gt; WIN32_WINDOWS <em>; z. B. nicht Windows 9x.</em>
    BlockInput, on
Run, notepad
WinWaitActive, Unbenannt- Editor
Send, {F5} <em>; Zeit und Datum hinzuf&uuml;gen</em>
BlockInput, off</pre>

</body>
</html>