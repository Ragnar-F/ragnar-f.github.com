<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>BlockInput</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="../../NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>


<h1>BlockInput</h1>

<p>Deaktiviert oder aktiviert die F&auml;higkeit des Benutzers, mit dem Computer mittels Tastatur und Maus zu interagieren.</p>

<pre class="Syntax">BlockInput, Modus </pre>
<h3>Parameter</h3>
<dl>
  
    <dt>Modus</dt>
    <dd><p><strong><u>Modus 1</u></strong>: Eins der folgenden W&ouml;rter:</p>
      <p><strong>On</strong>: Der Benutzer kann nicht mehr mit dem Computer interagieren (Maus- und Tastatureingaben haben keine Wirkung).</p>
      <p><strong>Off</strong>: Eingaben sind wieder m&ouml;glich.</p>
      <p><u><strong>Modus 2</strong></u>: Dieser Modus l&auml;uft unabh&auml;ngig von den Anderen. Zum Beispiel wird <em>BlockInput On</em> solange die Eingaben weiter blockieren, bis <em>BlockInput Off</em> verwendet wird, selbst wenn einer der Nachfolgenden aktiv ist.</p>
      <p><strong>Send</strong>: Die Tastatur- und Mauseingaben des Benutzers werden ignoriert, w&auml;hrend ein <a href="Send.htm">Send</a>- oder <a href="Send.htm">SendRaw</a>-Befehl ausgef&uuml;hrt wird (nur der traditionelle <a href="SendMode.htm">SendEvent-Modus</a>). Somit werden k&uuml;nstliche Tastatureingaben nicht von den Tastatureingaben des Benutzers beeinflusst. Sobald der Send-Befehl endet, sind Eingaben wieder m&ouml;glich (es sei denn, es wird noch durch ein weiteres <em>BlockInput On</em> geblockt).</p>
      <p><strong>Mouse</strong>: Die Tastatur- und Mauseingaben des Benutzers werden ignoriert, w&auml;hrend ein <a href="Click.htm">Click</a>-, <a href="MouseMove.htm">MouseMove</a>-, <a href="MouseClick.htm">MouseClick</a>- oder <a href="MouseClickDrag.htm">MouseClickDrag</a>-Befehl ausgef&uuml;hrt wird (nur der traditionelle <a href="SendMode.htm">SendEvent-Modus</a>). Somit werden k&uuml;nstliche Mauseingaben nicht von den Mauseingaben des Benutzers beeinflusst. Sobald der Maus-Befehl endet, sind Eingaben wieder m&ouml;glich (es sei denn, es wird noch durch ein weiteres <em>BlockInput On</em> geblockt).</p>
      <p><strong>SendAndMouse</strong>: Eine Kombination von <i>Send</i> und <i>Mouse</i>.</p>
      <p><strong>Default</strong>: Sowohl der <em>Send</em>- als auch der <em>Mouse</em>-Modus wird deaktiviert, der aktuelle Zustand der Eingabeblockierung bleibt jedoch unver&auml;ndert. Wenn zum Beispiel <em>BlockInput On</em> aktiv ist, dann bleibt <em>BlockInput Default</em> unwirksam.</p>
      <p><u><strong><a name="MouseMove"></a></strong></u><strong><u>Modus 3</u></strong><u> (ben&ouml;tigt v1.0.43.11+):</u> Dieser Modus l&auml;uft unabh&auml;ngig von den Anderen. Zum Beispiel werden Mausbewegungen solange weiter geblockt, bis <em>BlockInput On</em> und <em>BlockInput MouseMove</em> deaktiviert werden.</p>
      <p><strong>MouseMove</strong>: Der Mauszeiger reagiert nicht auf die physische Mausbewegung des Benutzers (DirectInput-Anwendungen sind eine m&ouml;gliche Ausnahme). Sobald ein Script diesen Befehl verwendet, wird der <a href="_InstallMouseHook.htm">Maus-Hook</a> installiert (wenn es nicht bereits geschehen ist). Wenn der Maus-Hook beim n&auml;chsten <a href="Suspend.htm">Suspend-</a> oder <a href="Hotkey.htm">Hotkey</a>-Befehl nicht mehr von Hotkeys oder Hotstrings ben&ouml;tigt wird, wird er deinstalliert (siehe <a href="_Hotstring.htm">#Hotstring NoMouse</a>).</p>
      <p><strong>MouseMoveOff</strong>: Erlaubt dem Benutzer, den Mauszeiger zu bewegen.</p></dd>
  
</dl>

<h3>Bemerkungen</h3>
<p>Anstelle von BlockInput sollte lieber <a href="SendMode.htm"><em>SendMode Input</em></a> oder <em><a href="SendMode.htm">SendMode Play</a></em> verwendet werden, damit die Tastatureingaben und Mausklicks nicht mehr unterbrochen werden k&ouml;nnen. Denn im Gegensatz zum BlockInput verwerfen diese Methoden nicht die Benutzereingabe beim Senden; solche Tastatureingaben werden stattdessen zwischengespeichert und danach gesendet. Durch das Vermeiden von BlockInput wird auch verhindert, h&auml;ngende Tasten wie im n&auml;chsten Abschnitt zu umgehen.</p>
<p>Wenn BlockInput beim Dr&uuml;cken von Tasten aktiviert wird, dann kann es passieren, dass diese Tasten "h&auml;ngen bleiben". Das kann verhindert werden, wenn den Tasten die M&ouml;glichkeit wie im folgenden Beispiel geboten wird, wieder losgelassen werden zu k&ouml;nnen, bevor BlockInput aktiviert wird:</p>
<pre>^!p::
KeyWait Control  <em>; Warten, bis die Taste losgelassen wird. Jeweils ein KeyWait f&uuml;r jede Modifikator-Taste verwenden.</em>
KeyWait Alt
BlockInput On
<em>; ... Tastatureingaben und Mausklicks senden ...</em>
BlockInput Off
Return</pre>
<p>Die Eingabeblockierung wird automatisch und sofort deaktiviert, sobald die ALT-Taste gesendet wird (wird aber danach wieder aktiviert).</p>
<p>Sobald BlockInput aktiv ist, wird die Benutzereingabe blockiert, jedoch kann AutoHotkey weiterhin Tastatureingaben und Mausklicks simulieren. Nur Strg+Alt+Entf ist aufgrund einer API-Funktion von Windows in der Lage, die Eingabe wieder zu aktivieren.</p>
<p>Verschiedene Arten von <a href="_UseHook.htm">Hook-Hotkeys</a> k&ouml;nnen weiterhin ausgel&ouml;st werden, wenn BlockInput aktiv ist. Beispielsweise "MButton" (Maus-Hook) und "LWin &amp; Space" (Tastatur-Hook mit eindeutigem Pr&auml;fix anstelle von Modifikatoren "$#").</p>
<p>Die Eingabe wird automatisch wieder aktiviert, wenn das Script beendet wird.</p>
<h3>Verwandte Befehle</h3>
<p><a href="SendMode.htm">SendMode</a>, <a href="Send.htm">Send</a>, <a href="Click.htm">Click</a>, <a href="MouseMove.htm">MouseMove</a>, <a href="MouseClick.htm">MouseClick</a>, <a href="MouseClickDrag.htm">MouseClickDrag</a></p>
<h3>Beispiel</h3>
<pre class="NoIndent">BlockInput, on
Run, notepad
WinWaitActive, Unbenannt - Editor
Send, {F5} <em>; Zeit und Datum einf&uuml;gen</em>
BlockInput, off</pre>
</body></html>