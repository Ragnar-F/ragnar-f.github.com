<!DOCTYPE HTML>
<html>
<head>
<title>Transform</title>
<meta name="keywords" content="Befehl, Berechnung">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Transform</h1>
      <p>Führt verschiedene mathematische Funktionen, bitweise Operationen und Aufgaben wie ASCII/Unicode-Konvertierung aus.</p>
      <pre class="Syntax">Transform, AusgabeVar, Befehl, Wert1 [, Wert2]</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td>AusgabeVar</td>
          <td>Name der Variable, in der der Rückgabewert von <em>Befehl</em> gespeichert wird. <a href="SetFormat.htm">SetFormat</a> bestimmt, ob Integer hexadezimal oder dezimal gespeichert werden.</td>
        </tr>
        <tr>
          <td style="width: 15%;">Befehl, Wert1/2</td>
          <td style="width: 85%;">Siehe untere Liste.</td>
        </tr>
      </table>
      <h3>Befehl, Wert1, Wert2</h3>
      <p>Die Parameter <em>Befehl</em>, <em>Wert1</em> und <em>Wert2</em> sind voneinander abhängig und können wie folgt verwendet werden.</p>
      <p id="Unicode"><strong>Unicode [, String]</strong>: <em>(Dieser Befehl steht in der Unicode-Version von AutoHotkey nicht zur Verfügung.)</em> Ermittelt oder speichert den Unicode-Text in die Zwischenablage. Hinweis: Die gesamte Zwischenablage kann mit <a href="../misc/Clipboard.htm#ClipboardAll">ClipboardAll</a> gespeichert und wiederhergestellt werden, damit "Transform Unicode" ohne Verlust des originalen Inhalts der Zwischenablage durchgeführt wird.</p>
      <p>Es gibt zwei verschiedene Methoden, den Befehl auszuführen:</p>
      <pre>Transform, AusgabeVar, Unicode  <em>; Ermittelt den Unicode-Text aus der Zwischenablage als UTF-8-String.</em>
Transform, Clipboard, Unicode, %EigenerUTF_String%  <em>; Speichert den Unicode-Text in die Zwischenablage.</em></pre>
      <p>Im zweiten oberen Beispiel besteht die Möglichkeit, anstelle von %EigenerUTF_String% einen direkten UTF-8-String  anzugeben.</p>
      <p>Mit dem folgenden Hotkey kann der UTF-8-String ermittelt werden, der zu einem angegebenen Unicode-String gehört:</p>
      <pre>^!u::  <em>; Hotkey STRG+ALT+U.</em>
MsgBox Kopiere einen beliebigen Unicode-Text, kehre danach zu diesem Fenster zurück und drücke auf OK, um fortzufahren.
Transform, ClipUTF, Unicode
Clipboard = Transform, Clipboard, Unicode, %ClipUTF%`r`n
MsgBox Die Zwischenablage enthält nun die folgende Zeile, die man in seinem Script einfügen kann. Sobald diese Zeile ausgeführt wird, wird der originale Unicode-Text, den man kopiert hat, in die Zwischenablage gespeichert:`n`n%Clipboard%
Return</pre>
      <p>Hinweise:</p>
      <ul>
        <li>Windows 95 benötigt <em>Microsoft Layer for Unicode (MSLU)</em>, um diesen Befehl unterstützen zu können (Windows 98/Me/NT4 oder höher haben eine integrierte Unterstützung).</li>
        <li>Mit <a href="Send.htm#asc"><code>Send {ASC nnnnn}</code></a> können auch Unicode-Zeichen erzeugt werden, allerdings funktioniert dieser Befehl nicht in jeder Anwendung.</li>
      </ul>
      <p><strong>Asc, String</strong>: Ermittelt den ASCII-Code (eine Zahl zwischen 1 und 255) für das erste Zeichen im <em>String</em>. Falls der <em>String</em> leer ist, wird <em>AusgabeVar</em> auch leer gemacht. Zum Beispiel: <code>Transform, AusgabeVar, Asc, %VarMitString%</code>. Dazugehörige Funktion: <a href="../Functions.htm#Asc">Asc(String)</a>.</p>
      <p><strong>Chr, Wert1</strong>: Ermittelt ein einzelnes Zeichen, das zum angegebenen ASCII-Code in <em>Wert1</em> gehört. Falls <em>Wert1</em> nicht zwischen 1 und 255 liegt, wird <em>AusgabeVar</em> leer gemacht, um das Problem zu kennzeichnen. Zum Beispiel: <code>Transform, AusgabeVar, Chr, 130</code>. Dazugehörige Funktion: <a href="../Functions.htm#Chr">Chr(Zahl)</a>.</p>
      <p id="Deref"><strong>Deref, String</strong>: Erweitert Variablenverweise und <a href="_EscapeChar.htm">Escapesequenzen</a>, die sich in anderen Variablen befinden. Jeder schlecht formatierte Variablenverweis wird im erweiterten Ergebnis weggelassen. Das gleiche gilt auch, wenn sich <em>AusgabeVar</em> in sich selbst erweitert. Das heißt, dass Verweise auf <em>AusgabeVar</em> innerhalb der Variablen von <em>String</em> beim Erweitern weggelassen werden (allerdings kann <em>String</em> selbst %<em>AusgabeVar</em>% <u>sein</u>). Wenn im folgenden Beispiel Var1 den String "Test" und Var2 den <u>direkten</u> String "%Var1%" enthält, wird <em>AusgabeVar</em> auf den String "Test" gesetzt: <code>Transform, AusgabeVar, deref, %Var2%</code>. Innerhalb einer <a href="../Functions.htm">Funktion</a> wird jede Variable in <em>String</em> immer in eine lokale Variable aufgelöst, sofern so eine Variable vorhanden ist, ansonsten wird sie in eine globale Variable aufgelöst (oder leer, wenn keine vorhanden ist).</p>
      <p id="HTML"><strong>HTML, String [, Flags]</strong>:</p>
      <p><em>Bei ausführbaren ANSI-Dateien</em> wird <em>String</em> in dessen HTML-Äquivalent umgewandelt, indem er Zeichen, deren ASCII-Werte über 127 liegen, in ihre HTML-Namen übersetzt (z. B. wird &pound; zu &amp;pound;). Zudem werden die vier Zeichen "&&lt;&gt; in &amp;quot;&amp;amp;&amp;lt;&amp;gt;  und zu guter Letzt jedes LF-Zeichen (`n) in &lt;br&gt;`n übersetzt (&lt;br&gt;, gefolgt von einem LF-Zeilenumbruchszeichen). Der <em>Flags</em>-Parameter wird ignoriert.</p>
      <p><em>Bei ausführbaren Unicode-Dateien</em> kann zusätzlich der <em>Flags</em>-Parameter verwendet werden, der entweder eine 0 oder eine Kombination (Summe) der folgenden Werte sein kann. Ist dieser Parameter nicht vorhanden, gilt standardmäßig eine 1.</p>
      <ul>
        <li>1: Wandelt bestimmte Zeichen in benannte Ausdrücke um. Zum Beispiel wird &euro; zu <code>&amp;euro;</code>.</li>
        <li>2: Wandelt bestimmte Zeichen in nummerierte Ausdrücke um. Zum Beispiel wird &euro; zu <code>&amp;#8364;</code>.</li>
      </ul>
      <p>Nur Zeichen, die nicht zum ASCII-Zeichensatz gehören, sind davon betroffen. Falls <i>Flags</i> = 3 ist, werden nummerierte Ausdrücke nur verwendet, wenn ein benannter Ausdruck nicht verfügbar ist. Die folgenden Zeichen werden immer umgewandelt: <code>&lt;&gt;"&</code> und <code>`n</code> (LF-Zeilenumbruchszeichen).</p>
      <p id="FromCodePage"><strong>FromCodePage</strong> / <strong>ToCodePage</strong>: Veraltet. Verwende stattdessen <a href="StrPutGet.htm">StrPut() / StrGet()</a>.</p>
      <p><strong>Mod, Dividend, Divisor</strong>: Ermittelt den Rest von <em>Dividend</em>, geteilt durch <em>Divisor</em>. Falls <em>Divisor</em> eine 0 ist, wird <em>AusgabeVar</em> leer gemacht. Sowohl <em>Dividend</em> als auch <em>Divisor</em> können einen Dezimalpunkt enthalten. Falls <em>Divisor</em> negativ ist, wird er für die Berechnung als positiv angesehen. Im folgenden Beispiel ist das Ergebnis eine 2: <code>Transform, AusgabeVar, mod, 5, 3</code>. Dazugehörige Funktion: <a href="../Functions.htm#Mod">Mod(Dividend, Divisor)</a>.</p>
      <p><strong>Pow, Basis, Exponent</strong>: Ermittelt <em>Basis</em>, potenziert mit <em>Exponent</em>. Sowohl <em>Basis</em> als auch <em>Exponent</em> können einen Dezimalpunkt enthalten. Falls <em>Exponent</em> negativ ist, wird <em>AusgabeVar</em> in eine Fließkommazahl umgewandelt, auch dann, wenn <em>Basis</em> und <em>Exponent</em> Integer sind. Eine negative <em>Basis</em>, kombiniert mit einem gebrochenen <em>Exponent</em> wie 1.5, wird nicht unterstützt und führt dazu, dass <em>AusgabeVar</em> leer gemacht wird. Siehe auch: <a href="../Variables.htm#pow">**-Operator</a>.</p>
      <p><strong>Exp, N</strong>: Ermittelt e (ungefähr 2.71828182845905), potenziert mit <em>N</em>. <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Dazugehörige Funktion: <a href="../Functions.htm#Exp">Exp(N)</a>.</p>
      <p><strong>Sqrt, Wert1</strong>: Ermittelt die Quadratwurzel von Wert1. Falls <em>Wert1</em> negativ ist, wird <em>AusgabeVar</em> leer gemacht. Dazugehörige Funktion: <a href="../Functions.htm#Sqrt">Sqrt(Zahl)</a>.</p>
      <p><strong>Log, Wert1</strong>: Ermittelt den Logarithmus (Basis 10) von <em>Wert1</em>. Falls <em>Wert1</em> negativ ist, wird <em>AusgabeVar</em> leer gemacht. Dazugehörige Funktion: <a href="../Functions.htm#Log">Log(Zahl)</a>.</p>
      <p><strong>Ln, Wert1</strong>: Ermittelt den Logarithmus (Basis e) von <em>Wert1</em>. Falls <em>Wert1</em> negativ ist, wird <em>AusgabeVar</em> leer gemacht. Dazugehörige Funktion: <a href="../Functions.htm#Ln">Ln(Zahl)</a>.</p>
      <p><strong>Round, Wert1 [, N]</strong>: Ist <em>N</em> nicht vorhanden, wird <em>AusgabeVar</em> auf <em>Wert1</em> gesetzt, gerundet auf den nächsten Integer. Wenn <em>N</em> eine positive Zahl ist, wird <em>Wert1</em> auf <em>N</em> Stellen nach dem Komma gerundet. Falls <em>N</em> negativ ist, wird <em>Wert1</em> auf <em>N</em> Stellen vor dem Komma gerundet. Zum Beispiel rundet -1 auf Einerstelle, -2 auf Zehnerstelle und -3 auf Hunderterstelle. Hinweis: Round  kann beim Runden von Dezimalstellen nachfolgende Nullen nicht entfernen. Zum Beispiel wird 12.333 zu 12.300000 beim Runden auf eine Dezimalstelle. Dieses Verhalten kann geändert werden, indem so etwas wie <code><a href="SetFormat.htm">SetFormat</a>, float, 0.1</code> vor der Operation verwendet wird (tatsächlich könnte <a href="SetFormat.htm">SetFormat</a> das Verwenden von Round an erster Stelle überflüssig machen). Dazugehörige Funktion: <a href="../Functions.htm#Round">Round(Zahl [, N])</a>.</p>
      <p><strong>Ceil, Wert1</strong>: Ermittelt <em>Wert1</em>, auf den nächst höheren Integer gerundet. Dazugehörige Funktion: <a href="../Functions.htm#Ceil">Ceil(Zahl)</a>.</p>
      <p><strong>Floor, Wert1</strong>: Ermittelt <em>Wert1</em>, auf den nächst niedrigeren Integer gerundet. Dazugehörige Funktion: <a href="../Functions.htm#Floor">Floor(Zahl)</a>.</p>
      <p><strong>Abs, Wert1</strong>: Ermittelt den absoluten Wert von <em>Wert1</em>, indem das führende Minuszeichen (Bindestrich), falls vorhanden, von <em>Wert1</em> entfernt wird. Dazugehörige Funktion: <a href="../Functions.htm#Abs">Abs(Zahl)</a>.</p>
      <p><strong>Sin, Wert1</strong>: Ermittelt den trigonometrischen Sinus von <em>Wert1</em>. <em>Wert1</em> muss als Bogenmaß angegeben werden. Dazugehörige Funktion: <a href="../Functions.htm#Sin">Sin(Zahl)</a>.</p>
      <p><strong>Cos, Wert1</strong>: Ermittelt den trigonometrischen Kosinus von <em>Wert1</em>. <em>Wert1</em> muss als Bogenmaß angegeben werden. Dazugehörige Funktion: <a href="../Functions.htm#Cos">Cos(Zahl)</a>.</p>
      <p><strong>Tan, Wert1</strong>: Ermittelt den trigonometrischen Tangens von <em>Wert1</em>. <em>Wert1</em> muss als Bogenmaß angegeben werden. Dazugehörige Funktion: <a href="../Functions.htm#Tan">Tan(Zahl)</a>.</p>
      <p><strong>ASin, Wert1</strong>: Ermittelt den Arkussinus (die Zahl, deren Sinus <em>Wert1</em> ist) als Bogenmaß. Falls <em>Wert1</em> kleiner als -1 oder größer als 1 ist, wird <em>AusgabeVar</em> leer gemacht. Dazugehörige Funktion: <a href="../Functions.htm#ASin">ASin(Zahl)</a>.</p>
      <p><strong>ACos, Wert1</strong>: Ermittelt den Arkuskosinus (die Zahl, deren Kosinus <em>Wert1</em> ist) als Bogenmaß. Falls <em>Wert1</em> kleiner als -1 oder größer als 1 ist, wird <em>AusgabeVar</em> leer gemacht. Dazugehörige Funktion: <a href="../Functions.htm#ACos">ACos(Zahl)</a>.</p>
      <p><strong>ATan, Wert1</strong>: Ermittelt den Arkustangens (die Zahl, deren Tangens <em>Wert1</em> ist) als Bogenmaß. Dazugehörige Funktion: <a href="../Functions.htm#ATan">ATan(Zahl)</a>.</p>
      <p>HINWEIS: Jede nachfolgende bitweise Operation kann innerhalb von Ausdrücken als <a href="../Variables.htm#bitwise">bitweiser Operator</a> angegeben werden.</p>
      <p><strong>BitNot, Wert1</strong>: Speichert die bit-invertierte Version von <em>Wert1</em> in <em>AusgabeVar</em> (falls <em>Wert1</em> eine Fließkommazahl ist, wird sie zu einem Integer gekürzt, bevor die Berechnung erfolgt). Wenn <em>Wert1</em> ein Zahl zwischen 0 und 4294967295 (0xffffffff) ist, wird sie als <u>vorzeichenlosen</u> 32-Bit-Wert behandelt. Ansonsten wird sie als <u>vorzeichenbehafteten</u> 64-Bit-Wert behandelt. Im folgenden Beispiel ist das Ergebnis 0xfffff0f0 (4294963440): <code>Transform, AusgabeVar, BitNot, 0xf0f</code>.</p>
      <p><strong>BitAnd, Wert1, Wert2</strong>: Ermittelt das Ergebnis des bitweisen UND's von <em>Wert1</em> und <em>Wert2</em> (Fließkommazahlen werden zu Integer gekürzt, bevor die Berechnung erfolgt). Im folgenden Beispiel ist das Ergebnis 0xff00 (65280): <code>Transform, AusgabeVar, BitAnd, 0xff0f, 0xfff0</code>.</p>
      <p><strong>BitOr, Wert1, Wert2</strong>: Ermittelt das Ergebnis des bitweisen ODER's von <em>Wert1</em> und <em>Wert2</em> (Fließkommazahlen werden zu Integer gekürzt, bevor die Berechnung erfolgt). Im folgenden Beispiel ist das Ergebnis 0xf0f0 (61680): <code>Transform, AusgabeVar, BitOr, 0xf000, 0x00f0</code>.</p>
      <p><strong>BitXOr, Wert1, Wert2</strong>: Ermittelt das Ergebnis des bitweisen Exklusiv-ODER's von <em>Wert1</em> und <em>Wert2</em> (Fließkommazahlen werden zu Integer gekürzt, bevor die Berechnung erfolgt). Im folgenden Beispiel ist das Ergebnis 0xff00 (65280): <code>Transform, AusgabeVar, BitXOr, 0xf00f, 0x0f0f</code>.</p>
      <p><strong>BitShiftLeft, Wert1, Wert2</strong>: Ermittelt das Ergebnis durch Verschieben von <em>Wert1</em> um <em>Wert2</em> Bit-Positionen nach links, das dem Multiplizieren von <em>Wert1</em> mit "2 potenziert mit <em>Wert2</em>" entspricht (Fließkommazahlen werden zu Integer gekürzt, bevor die Berechnung erfolgt). Im folgenden Beispiel ist das Ergebnis eine 8: <code>Transform, AusgabeVar, BitShiftLeft, 1, 3</code>.</p>
      <p><strong>BitShiftRight, Wert1, Wert2</strong>: Ermittelt das Ergebnis durch Verschieben von <em>Wert1</em> um <em>Wert2</em> Bit-Positionen nach rechts, das dem Dividieren von <em>Wert1</em> mit "2 potenziert mit <em>Wert2</em>" entspricht, bei dem der Rest gekürzt wird (Fließkommazahlen werden zu Integer gekürzt, bevor die Berechnung erfolgt). Im folgenden Beispiel ist das Ergebnis eine 2: <code>Transform, AusgabeVar, BitShiftRight, 17, 3</code>.</p>
      <h3>Bemerkungen</h3>
      <p>Unterbefehle, die numerische Parameter akzeptieren, können auch <a href="../Variables.htm#Expressions">Ausdrücke</a> für solche Parameter verwenden.</p>
      <p>Sobald <em>Wert1</em> oder <em>Wert2</em> eine Fließkommazahl ist, ermitteln folgende <em>Befehle</em> eine Fließkommazahl, anstatt ein Integer: Mod, Pow, Round und Abs. Die Anzahl der abgerufenen Dezimalstellen wird über <a href="SetFormat.htm">SetFormat</a> bestimmt.</p>
      <p>Um ein Bogenmaß in Grad umzuwandeln, kann es mit 180/pi (ungefähr 57.29578) multipliziert werden. Um ein Grad-Wert in Bogenmaß umzuwandeln, kann es mit pi/180 (ungefähr 0.01745329252) multipliziert werden.</p>
      <p>Der Wert von pi (ungefähr 3,141592653589793) ist viermal der Arkustangens von 1.</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="SetFormat.htm">SetFormat</a>, <a href="../Variables.htm#Expressions">Ausdrücke</a>, <a href="EnvMult.htm">EnvMult</a>, <a href="EnvDiv.htm">EnvDiv</a>, <a href="StringLower.htm">StringLower</a>, <a href="IfIs.htm">If Var is Typ</a></p>
      <h3>Beispiel</h3>
      <pre class="NoIndent">Transform, AusgabeVar, Asc, A  <em>; Ermittelt den ASCII-Code vom Buchstaben A.</em></pre>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>