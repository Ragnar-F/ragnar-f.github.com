<!DOCTYPE HTML>
<html>
<head>
<title>OnMessage</title>
<meta name="keywords" content="Befehl, Grafische Benutzeroberfl&auml;che">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>OnMessage()</h1>
      <p>Bestimmt eine <a href="../Functions.htm">Funktion</a>, die automatisch aufgerufen wird, sobald das Script die angegebene Nachricht empf&auml;ngt.</p>
      <pre class="Syntax">OnMessage(Nachrichtennummer [, "Funktionsname", MaxThreads])</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Nachrichtennummer</td>
          <td style="width: 85%;">Die Nummer der Nachricht zwischen 0 und 4294967295 (0xFFFFFFFF), die &uuml;berwacht oder abgefragt werden soll. Um die &Uuml;berwachung einer <a href="../misc/SendMessageList.htm">Systemnachricht</a> (eine unter 0x400) zu vermeiden, sollte am besten eine Nummer ausgew&auml;hlt werden, die gr&ouml;&szlig;er als 4096 (0x1000) ist. Dadurch verringert sich die Chance, dass St&ouml;rungen mit Nachrichten auftreten, die intern von den aktuellen oder zuk&uuml;nftigen AutoHotkey-Versionen verwendet werden.</td>
        </tr>
        <tr>
          <td>Funktionsname</td>
          <td>Der Name einer <a href="../Functions.htm">Funktion</a>, der in Anf&uuml;hrungszeichen gesetzt werden muss, falls dieser ein direkter String ist. Diese Funktion wird automatisch aufgerufen, sobald das Script die <em>Nachrichtennummer</em> empf&auml;ngt. Entf&auml;llt dieser und der n&auml;chste Parameter, wird der Name der Funktion ermittelt, die gerade <em>Nachrichtennummer</em> &uuml;berwacht (leer, wenn nicht vorhanden). Mit einem leeren String ("") oder einer leeren Variable wird die &Uuml;berwachung der <em>Nachrichtennummer</em> deaktiviert.</td>
        </tr>
        <tr>
          <td>MaxThreads<br>
            <span class="ver">[v1.0.47+]</span></td>
          <td id="MaxThreads">Dieser Integer wird normalerweise weggelassen, um die &Uuml;berwachungsfunktion jeweils auf einen einzigen <a href="../misc/Threads.htm">Thread</a> zu begrenzen. Diese Einstellung wird empfohlen, weil andere Werte dazu f&uuml;hren w&uuml;rden, dass die Nachrichten nicht mehr in chronologischer Reihenfolge abgearbeitet werden, sobald sich die &Uuml;berwachungsfunktion selbst unterbricht. Als Alternative zu <em>MaxThreads</em> sollte daher <em>Critical</em> in Betracht gezogen werden (siehe <a href="#Critical">unten</a>).</td>
        </tr>
      </table>
      <h3>R&uuml;ckgabewerte</h3>
      <p>Sobald die Parameter <em>Funktionsname</em> und <em>MaxThreads</em> weglassen werden, wird der Name der Funktion zur&uuml;ckgegeben, die zurzeit die <em>Nachrichtennummer</em> &uuml;berwacht (leer, wenn nicht vorhanden). &Auml;nderungen werden jedoch nicht vorgenommen.</p>
      <p>Falls der <em>Funktionsname</em> ausdr&uuml;cklich leer ist (d. h. ""), wird der Name der Funktion zur&uuml;ckgegeben, die zurzeit die <em>Nachrichtennummer</em> &uuml;berwacht (leer, wenn nicht vorhanden). Danach wird die &Uuml;berwachung der <em>Nachrichtennummer</em> deaktiviert.</p>
      <p>Wenn <em>Funktionsname</em> nicht leer ist: Falls <em>Nachrichtennummer</em> bereits &uuml;berwacht wird, wird der Name dieser Funktion zur&uuml;ckgegeben und danach die neue Funktion in Kraft gesetzt. Ansonsten wird <em>Funktionsname</em> dazu bestimmt, <em>Nachrichtennummer</em> zu &uuml;berwachen und danach den selben <em>Funktionsnamen</em> zur&uuml;ckzugeben. In jedem Fall wird bei Misserfolg ein leerer Wert zur&uuml;ckgegeben. Fehler treten auf, wenn <em>Funktionsname</em>: </p>
      <ul>
        <li>nicht existiert (vielleicht wegen fehlender Anf&uuml;hrungszeichen um <em>Funktionsnamen</em>).</li>
        <li>mehr als 4 Parameter akzeptiert.</li>
        <li><a href="../Functions.htm#ByRef">ByRef</a>- oder <a href="../Functions.htm#optional">optionale</a> Parameter hat.</li>
      </ul>
      <p>Es schl&auml;gt auch fehl, wenn das Script versucht, eine neue Nachricht zu &uuml;berwachen, in dem bereits 500 Nachrichten &uuml;berwacht werden.</p>
      <h3>Die Parameter der Funktion</h3>
      <p>Eine <a href="../Functions.htm">Funktion</a>, die eine oder mehrere Nachrichten &uuml;berwachen soll, kann bis zu vier Parameter akzeptieren:</p>
      <pre>EigeneNachrichten&uuml;berwachung(wParam, lParam, msg, hwnd)
{
    ... Funktionsbereich ...
}</pre>
      <p>Obwohl die Namensgebung f&uuml;r die Parameter keine Rolle spielt, werden folgende Informationen der Reihe nach zugewiesen:</p>
      <p>Parameter #1: WPARAM-Wert - ein Integer zwischen 0 und 4294967295.<br>
        Parameter #2: LPARAM-Wert - ein Integer zwischen 0 und 4294967295.<br>
        Parameter #3: Nachrichtennummer - n&uuml;tzlich, falls die Funktion mehrere Nachrichten &uuml;berwacht.<br>
        Parameter #4: HWND (eindeutige ID) des Fensters oder Steuerelements, zu dem die Nachricht gesendet wurde. Das HWND kann mit  <a href="../misc/WinTitle.htm#ahk_id">ahk_id</a> verwendet werden.</p>
      <p>Falls bestimmte Informationen nicht ben&ouml;tigt werden, k&ouml;nnen entsprechende Parameter am Listenende weggelassen werden. Zum Beispiel w&uuml;rde eine Funktion, definiert als <code>EigeneNachrichten&uuml;berwachung(wParam, lParam)</code>, nur die ersten zwei Parameter empfangen. Eine Funktion, definiert als <code>EigeneNachrichten&uuml;berwachung()</code>, w&uuml;rde hingegen keine Parameter empfangen.</p>
      <p>Wenn ein eingehender WPARAM oder LPARAM als signed Integer vorgesehen ist, k&ouml;nnen negative Zahlen zum Beispiel wie folgt offenbart werden:</p>
      <pre>If wParam &gt; 0x7FFFFFFF
    wParam := -(~wParam) - 1</pre>
      <h3>Weitere verf&uuml;gbare Informationen f&uuml;r die Funktion</h3>
      <p>Zus&auml;tzlich zu den oben genannten Parametern kann die Funktion auch auf die Werte der folgenden internen Variablen zur&uuml;ckgreifen:</p>
      <ul>
        <li><a href="../Variables.htm#Gui">A_Gui</a>: Leer, es sei denn, die Nachricht wurde an ein GUI-Fenster oder Steuerelement gesendet, in diesem Fall enth&auml;lt A_Gui die <a href="Gui.htm#MultiWin">Nummer des GUI-Fensters</a> (dieses Fenster wird auch das <a href="Gui.htm#DefaultWin">Standard-GUI-Fenster</a> der Funktion sein).</li>
        <li> <a href="../Variables.htm#GuiControl">A_GuiControl</a>: Leer, es sei denn, die Nachricht wurde an ein GUI-Steuerelement gesendet, in diesem Fall enth&auml;lt A_GuiControl den Variablennamen des Steuerelements oder andere Werte wie in <a href="../Variables.htm#GuiControl">A_GuiControl</a> beschrieben. Einige Steuerelemente k&ouml;nnen bestimmte Nachrichtentypen nie empfangen. Sobald der Benutzer beispielsweise ein <a href="GuiControls.htm#Text">Text-Steuerelement</a> anklickt, sendet das Betriebssystem WM_LBUTTONDOWN eher an das &uuml;bergeordnete Fenster, als an das Steuerelement (folglich ist A_GuiControl leer).</li>
        <li> <a href="../Variables.htm#GuiX">A_GuiX</a> und <a href="../Variables.htm#GuiX">A_GuiY</a>: Beide enthalten -2147483648, falls die eingehende Nachricht mit <a href="PostMessage.htm">SendMessage</a> gesendet wurde. Wenn die Nachricht mit <a href="PostMessage.htm">PostMessage</a> gesendet wurde, enthalten beide Variablen die Koordinaten des Mauszeigers (relativ zum Bildschirm).</li>
        <li> <a href="../Variables.htm#EventInfo">A_EventInfo</a>: Enth&auml;lt 0, wenn die eingehende Nachricht mit SendMessage gesendet wurde. Wenn die Nachricht mit PostMessage gesendet wurde, ist der <a href="../Variables.htm#TickCount">Tick-Count-Zeitpunkt</a> der Sendung enthalten.</li>
      </ul>
      <p>Das <a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a> einer &Uuml;berwachungsfunktion ist zu Beginn das &uuml;bergeordnete Fenster, zu dem die Nachricht gesendet wurde (auch dann, wenn die Nachricht an das Steuerelement gesendet wurde). Ist das Fenster versteckt, aber kein GUI-Fenster (z. B. das Hauptfenster des Scripts), muss <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> aktiviert werden, bevor es verwendet werden kann. Zum Beispiel:</p>
      <pre>DetectHiddenWindows On
MsgParentWindow := WinExist()  <em>; Speichert die eindeutige ID des Fensters, zum dem die Nachricht gesendet wurde.</em></pre>
      <h3>Was die Funktion zur&uuml;ckgeben sollte (<em>Return</em>)</h3>
      <p>Wenn eine &Uuml;berwachungsfunktion <a href="Return.htm">Return</a> ohne Parameter verwendet oder ein leerer Wert wie "" angegeben ist (oder Return &uuml;berhaupt nicht verwendet), wird die eingehende Nachricht normal verarbeitet, sobald die Funktion beendet wird. Das Gleiche passiert, wenn die Funktion mit <a href="Exit.htm">Exit</a> beendet wird oder einen Laufzeitfehler verursacht, wie z. B. das <a href="Run.htm">Ausf&uuml;hren</a> einer nicht vorhandenen Datei. Die R&uuml;ckgabe eines Integers zwischen -2147483648 und 4294967295 bewirkt hingegen, dass die Nummer sofort als Antwort gesendet wird. Das hei&szlig;t, dass das Programm die Nachricht nicht weiter verarbeiten wird. Zum Beispiel k&ouml;nnte eine Funktion, die WM_LBUTTONDOWN (0x201) &uuml;berwacht, ein Integer zur&uuml;ckgeben, um das Zielfenster daran zu hindern, benachrichtigt zu werden, dass ein Mausklick erfolgt ist. In vielen F&auml;llen (z. B. der Nachrichtenempfang &uuml;ber <a href="PostMessage.htm">PostMessage</a>) spielt es keine Rolle, welcher Integer zur&uuml;ckgegeben wird; im Zweifelsfall ist eine 0 aber am sichersten.</p>
      <h3 id="Remarks">Allgemeine Bemerkungen</h3>
      <p>Im Gegensatz zu einem normalen Funktionsaufruf ruft der Empfang einer &uuml;berwachten Nachricht die Funktion als neuen <a href="../misc/Threads.htm">Thread</a> auf. Aus diesem Grund beginnt die Funktion mit den Standardwerten f&uuml;r Einstellungen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>. Diese k&ouml;nnen im <a href="../Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> ge&auml;ndert werden.</p>
      <p>Nachrichten, die mit SendMessage (anstatt mit PostMessage) zu einem Steuerelement gesendet wurden, werden nicht &uuml;berwacht, weil diese direkt und unauff&auml;llig an das Steuerelement weitergeleitet werden. Auf systemgesteuerte Nachrichten trifft das nicht zu, weil die meisten von ihnen mit PostMessage gesendet werden.</p>
      <p>Sobald ein Script die OnMessage-Funktion aufruft, wird es automatisch <a href="_Persistent.htm">persistent</a>. Zudem kann das Script nur einmal vorkommen (Einzelinstanz), sofern das nicht mit <a href="_SingleInstance.htm">#SingleInstance</a> &uuml;berschrieben wird.</p>
      <p id="Critical">Falls eine Nachricht ankommt, w&auml;hrend ihre Funktion aufgrund eines vorherigen Aufrufs noch l&auml;uft, wird die Funktion nicht erneut aufgerufen (au&szlig;er wenn <a href="#MaxThreads">MaxThreads</a> gr&ouml;&szlig;er als 1 ist). Die Nachricht wird stattdessen als nicht &uuml;berwacht angesehen. Wenn das unerw&uuml;nscht ist, kann eine Nachricht gr&ouml;&szlig;er gleich 0x312 durch Angabe von <a href="Critical.htm">Critical</a> zwischengespeichert werden, bis deren Funktion vollst&auml;ndig ausgef&uuml;hrt wurde. Alternativ kann mit <a href="Thread.htm">Thread Interrupt</a> das gleiche erreicht werden, solange genug Zeit bleibt, die Funktion zu beenden. Eine Nachricht kleiner als 0x312 kann hingegen nicht mit Critical oder "Thread Interrupt" zwischengespeichert werden (seit v1.0.46 k&ouml;nnte Critical allerdings helfen, weil dieser Befehl die Nachrichten <a href="Critical.htm#Interval">nicht so h&auml;ufig</a> &uuml;berpr&uuml;ft, wodurch die Funktion mehr Zeit zum Beenden hat). Damit solche Nachrichten garantiert nicht verloren gehen k&ouml;nnen, muss sichergestellt werden, dass die Funktion nicht l&auml;nger als 6 Millisekunden ausgef&uuml;hrt wird (dieses Limit kann mit <a href="Critical.htm#Interval"><em>Critical 30</em></a> angehoben werden). Zum Beispiel kann daf&uuml;r ein zuk&uuml;nftiger Thread in die Warteschlange gesetzt werden, indem eine &uuml;berwachte Nachrichtennummer gr&ouml;&szlig;er als 0x312 an das eigene Script mit PostMessage <a href="PostMessage.htm">gesendet</a> wird. Die Funktion dieser Nachricht sollte <a href="Critical.htm">Critical</a> in der ersten Zeile verwenden, um sicherzustellen, dass deren Nachrichten zwischengespeichert werden.</p>
      <p>Wenn eine &uuml;berwachte Nachrichtennummer kleiner als 0x312 eintrifft, w&auml;hrend das Script absolut unterbrechungsfrei ist (z. B. w&auml;hrend ein <a href="Menu.htm">Men&uuml;</a> angezeigt wird, <a href="SetKeyDelay.htm">KeyDelay</a>/<a href="SetMouseDelay.htm">MouseDelay</a> im Gange ist oder die Zwischenablage <a href="_ClipboardTimeout.htm">offen</a> ist), wird die Nachrichtenfunktion nicht aufgerufen und die Nachricht als nicht &uuml;berwacht angesehen. &Uuml;berwachte Nachrichten gr&ouml;&szlig;er gleich 0x312 werden hingegen in diesen unterbrechungsfreien Perioden zwischengespeichert, das hei&szlig;t, dass die Funktion aufgerufen wird, sobald das Script wieder unterbrechbar ist.</p>
      <p>Wenn eine &uuml;berwachte Nachrichtennummer kleiner als 0x312 eintrifft, w&auml;hrend das Script aufgrund der Einstellungen von <a href="Thread.htm">Thread Interrupt</a> oder <a href="Critical.htm">Critical</a> unterbrechungsfrei ist, wird der aktuelle Thread unterbrochen, damit die Funktion aufgerufen werden kann. Eine &uuml;berwachte Nachricht gr&ouml;&szlig;er gleich 0x312 wird hingegen zwischengespeichert, bis der Thread endet oder unterbrechbar wird.</p>
      <p>Die <a href="../misc/Threads.htm">Priorit&auml;t</a> von OnMessage-Threads ist immer 0. Folglich werden Nachrichten weder &uuml;berwacht noch zwischengespeichert, wenn der aktuelle Thread eine Priorit&auml;t h&ouml;her als 0 hat.</p>
      <p>Bei der &Uuml;berwachung von Systemnachrichten ist Vorsicht geboten (solche unter 0x400). Wenn zum Beispiel eine &Uuml;berwachungsfunktion nicht schnell genug zum Abschluss kommt, kann die Reaktion auf die Nachricht l&auml;nger dauern als vom System erwartet, wodurch Nebeneffekte auftreten k&ouml;nnen. Diese k&ouml;nnen auch auftreten, wenn eine &Uuml;berwachungsfunktion ein Integer zur&uuml;ckgibt, um die weitere Verarbeitung einer Nachricht zu unterdr&uuml;cken, aber das System voraussichtlich eine andere Verarbeitung oder Reaktion erwartet.</p>
      <p>Sobald das Script ein Dialogfenster wie <a href="MsgBox.htm">MsgBox</a> anzeigt, werden gesendete Nachrichten an ein Steuerelement nicht l&auml;nger &uuml;berwacht. Wenn das Script zum Beispiel eine MsgBox anzeigt und der Benutzer eine Schaltfl&auml;che in einem GUI-Fenster anklickt, wird die WM_LBUTTONDOWN-Nachricht direkt zur Schaltfl&auml;che gesendet, ohne dabei die &Uuml;berwachungsfunktion aufzurufen.</p>
      <p>Obwohl ein externes Programm in der Lage w&auml;re, Nachrichten direkt mit PostThreadMessage() oder anderen API-Funktionen an ein Script-Thread zu senden, ist das nicht zu empfehlen, weil die Nachrichten dabei verloren gehen k&ouml;nnen, falls das Script ein Dialogfenster wie <a href="MsgBox.htm">MsgBox</a> anzeigt. Stattdessen ist es besser, PostMessage- oder SendMessage-Nachrichten an das Hauptfenster des Scripts oder dessen GUI-Fenster zu senden.</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="OnExit.htm">OnExit</a>, <a href="../misc/Clipboard.htm#OnClipboardChange">OnClipboardChange</a>, <a href="PostMessage.htm">Post/SendMessage</a>, <a href="../Functions.htm">Funktionen</a>, <a href="../misc/SendMessageList.htm">Liste mit Fensternachrichten</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Critical.htm">Critical</a>, <a href="DllCall.htm">DllCall()</a></p>
      <h3>Beispiele</h3>
      <pre class="NoIndent"><em>; Beispiel: Das folgende Script &uuml;berwacht Mausklicks innerhalb eines GUI-Fensters.
; Verwandtes Thema: <a href="Gui.htm#GuiContextMenu">GuiContextMenu</a></em>

Gui, Add, Text,, Irgendwo auf das Fenster klicken.
Gui, Add, Edit, w200 vEigenesEdit
Gui, Show
OnMessage(0x201, "WM_LBUTTONDOWN")
Return

WM_LBUTTONDOWN(wParam, lParam)
{
    X := lParam & 0xFFFF
    Y := lParam &gt;&gt; 16
    If A_GuiControl
        Steuerelement := "`n(im Steuerelement " . A_GuiControl . ")"
    ToolTip Sie haben im GUI-Fenster #%A_Gui% auf die Koordinaten %X%x%Y% geklickt.%Steuerelement%
}

GuiClose:
ExitApp</pre>
      <pre class="NoIndent" id="shutdown"><em>; Beispiel: Das folgende Script erkennt das Abmelden/Herunterfahren des Systems und erlaubt dem Benutzer, es abzubrechen (funktioniert NICHT in Windows Vista und h&ouml;her).
; Verwandtes Thema: <a href="OnExit.htm">OnExit</a></em>

<em>; Der folgende Aufruf von DllCall ist optional: dem OS wird mitgeteilt, <i>zuerst</i> das Script zu beenden (vor allen anderen Anwendungen).
; Dieser Aufruf funktioniert nicht in Windows 9x.</em>
DllCall("kernel32.dll\SetProcessShutdownParameters", UInt, 0x4FF, UInt, 0)
OnMessage(0x11, "WM_QUERYENDSESSION")
Return

WM_QUERYENDSESSION(wParam, lParam)
{
    ENDSESSION_LOGOFF = 0x80000000
    If (lParam & ENDSESSION_LOGOFF)  <em>; Benutzer meldet sich ab.</em>
        Ereignis = Abmeldung
    Else  <em>; System wird entweder heruntergefahren oder neu gestartet.</em>
        Ereignis = Herunterfahren
    MsgBox, 4,, %Ereignis% im Gange. Erlauben?
    IfMsgBox Yes
        Return true  <em>; Erlaubt dem OS, herunterzufahren/abzumelden.</em>
    Else
        Return false  <em>; Herunterfahren/Abmelden wird abgebrochen.</em>
}</pre>
      <pre class="NoIndent"><em>; Beispiel: Bewirkt, dass ein Script eine benutzerdefinierte Nachricht und bis zu zwei Zahlen von einem anderen Script oder Programm erh&auml;lt
; (um Strings anstelle von Zahlen zu senden, siehe n&auml;chstes Beispiel).</em>

OnMessage(0x5555, "MsgMonitor")
OnMessage(0x5556, "MsgMonitor")

MsgMonitor(wParam, lParam, msg)
{
    <em>; Da das schnelle Beenden wichtig ist, ist es besser, ein ToolTip zu verwenden,</em>
    <em>; anstatt eine MsgBox, die die Funktion daran hindert, zu beenden:</em>
    ToolTip Nachricht %msg% eingetroffen:`nWPARAM: %wParam%`nLPARAM: %lParam%
}

<em>; Die folgenden Zeilen k&ouml;nnen innerhalb eines anderen Scripts verwendet werden, um die Funktion im oberen Script auszuf&uuml;hren:</em>
SetTitleMatchMode 2
DetectHiddenWindows On
If WinExist("Empf&auml;nger.ahk ahk_class AutoHotkey")
    PostMessage, 0x5555, 11, 22  <em>; Die Nachricht wird aufgrund von WinExist() an das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" gesendet.</em>
DetectHiddenWindows Off  <em>; Muss nicht deaktiviert werden, bis nach PostMessage.</em></pre>
      <pre class="NoIndent" id="SendString"><em>; Beispiel: Sendet einen String mit beliebiger L&auml;nge von einem Script zum anderen. Das ist ein funktionierendes Beispiel.
; Um es zu verwenden, m&uuml;ssen beide folgende Scripts gespeichert und ausgef&uuml;hrt und danach Win+Leertaste gedr&uuml;ckt werden,
; um eine InputBox anzuzeigen, die den Benutzer auffordert, einen String einzugeben.</em>

<em>; Speichert das folgende Script als "<strong>Empf&auml;nger.ahk</strong>" und startet es:</em>
#SingleInstance
OnMessage(0x4a, "WM_COPYDATA_Empfangen")  <em>; 0x4a ist WM_COPYDATA</em>
Return

WM_COPYDATA_Empfangen(wParam, lParam)
{
    Stringadresse := NumGet(lParam + 2*A_PtrSize)  <em>; Ermittelt die Adresse vom lpData-Element in CopyDataStruct.</em>
    Datenkopie := StrGet(Stringadresse)  <em>; Kopiert den String aus der Struktur.</em>
    <em>; Mit ToolTip anzeigen, damit wir rechtzeitig zur&uuml;ckkehren k&ouml;nnen:</em>
    ToolTip %A_ScriptName%`nFolgender String empfangen:`n%Datenkopie%
    Return true  <em>; Die R&uuml;ckgabe von 1 (wahr) ist der traditionelle Weg, um diese Nachricht zu best&auml;tigen.</em>
}

<em>; Speichert das folgende Script als <strong>"Sender.ahk"</strong> und startet es:  Dr&uuml;ckt danach den Hotkey Win+Leertaste.</em>
Empf&auml;ngertitel = Empf&auml;nger.ahk ahk_class AutoHotkey

#space::  <em>; Hotkey: Win+Leertaste Dr&uuml;cken, um eine InputBox f&uuml;r die Eingabe eines String anzuzeigen.</em>
InputBox, StringSenden, Text mit WM_COPYDATA senden, Beliebigen Text eingeben:
If ErrorLevel  <em>; Benutzer hat die Abbrechen-Schaltfl&auml;che gedr&uuml;ckt.</em>
    Return
Ergebnis := WM_COPYDATA_Senden(StringSenden, Empf&auml;ngertitel)
If Ergebnis = FAIL
    MsgBox SendMessage fehlgeschlagen. Existiert der folgende Fenstertitel?:`n%Empf&auml;ngertitel%
Else If Ergebnis = 0
    MsgBox Nachricht gesendet, aber das Zielfenster hat mit 0 geantwortet (es ignoriert die Nachricht).
Return

WM_COPYDATA_Senden(ByRef StringSenden, ByRef Empf&auml;ngertitel)  <em>; ByRef spart in diesem Fall ein wenig Speicherplatz.
; Diese Funktion sendet den angegebenen String an das angegebene Fenster und gibt eine Anwort zur&uuml;ck.
; Die Antwort ist 1, wenn das Zielfenster die Nachricht verarbeitet hat oder 0, wenn die Nachricht ignoriert wurde.</em>
{
    VarSetCapacity(CopyDataStruct, 3*A_PtrSize, 0)  <em>; Bestimmt den Speicherbereich der Struktur.</em>
    <em>; Zuerst wird das cbData-Element der Struktur auf die Gr&ouml;&szlig;e des Strings gesetzt, einschlie&szlig;lich dem Null-Terminator.</em>
    Gr&ouml;&szlig;eInBytes := (StrLen(StringSenden) + 1) * (A_IsUnicode ? 2 : 1)
    NumPut(Gr&ouml;&szlig;eInBytes, CopyDataStruct, A_PtrSize)  <em>; OS setzt voraus, dass das getan werden muss.</em>
    NumPut(&amp;StringSenden, CopyDataStruct, 2)  <em>; lpData zeigt auf dem String selbst.</em>
    DetectHiddenWindows_Vorher := A_DetectHiddenWindows
    TitleMatchMode_Vorher := A_TitleMatchMode
    DetectHiddenWindows On
    SetTitleMatchMode 2
    SendMessage, 0x4a, 0, &amp;CopyDataStruct,, %Empf&auml;ngertitel%  <em>; 0x4a ist WM_COPYDATA. Verwendet Send, nicht Post.</em>
    DetectHiddenWindows %DetectHiddenWindows_Vorher%  <em>; Stellt die urspr&uuml;ngliche Einstellung wieder her.</em>
    SetTitleMatchMode %TitleMatchMode_Vorher%         <em>; Das Gleiche.</em>
    Return ErrorLevel  <em>; Die Antwort von SendMessage zur&uuml;ckgeben.</em>
}</pre>
      <pre class="NoIndent"><em>; Beispiel: Siehe <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Script</a>, wie OnMessage() verwendet werden kann,
; um Meldungen zu empfangen, wenn Daten in einer Netzwerkverbindung angekommen sind.</em></pre>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>