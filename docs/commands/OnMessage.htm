<!DOCTYPE HTML>
<html>
<head>
<title>OnMessage</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>OnMessage()</h1>

<p>Bestimmt eine <a href="../Functions.htm">Funktion</a>, die automatisch aufgerufen wird, sobald das Script die angegebene Nachricht empfängt.</p>

<pre class="Syntax">OnMessage(Nachrichtennummer [, "Funktionsname", MaxThreads])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Nachrichtennummer</dt>
  <dd><p>Die Nummer der Nachricht zwischen 0 und 4294967295 (0xFFFFFFFF), die überwacht oder abgefragt werden soll. Um die Überwachung einer <a href="../misc/SendMessageList.htm">Systemnachricht</a> (eine unter 0x400) zu vermeiden, sollte am besten eine Nummer ausgewählt werden, die größer als 4096 (0x1000) ist. Dadurch verringert sich die Chance, dass Störungen mit Nachrichten auftreten, die intern von den aktuellen oder zukünftigen AutoHotkey-Versionen verwendet werden.</p></dd>

  <dt>Funktionsname</dt>
  <dd><p>Der Name einer <a href="../Functions.htm">Funktion</a>, der in Anführungszeichen gesetzt werden muss, falls dieser ein direkter String ist. Diese Funktion wird automatisch aufgerufen, sobald das Script die <em>Nachrichtennummer</em> empfängt. Fehlt dieser Parameter, wird der Name der Funktion ermittelt, die gerade <em>Nachrichtennummer</em> überwacht (leer, wenn nicht vorhanden). Mit einem leeren String ("") oder einer leeren Variable wird die Überwachung der <em>Nachrichtennummer</em> deaktiviert.</p></dd>

  <dt>MaxThreads<br>
    <span class="ver">[v1.0.47+]</span></dt>
  <dd><p><a name="MaxThreads"></a>Dieser Integer wird normalerweise weggelassen, um die Überwachungsfunktion jeweils auf einen einzigen <a href="../misc/Threads.htm">Thread</a> zu begrenzen. Diese Einstellung wird empfohlen, weil andere Werte dazu führen würden, dass die Nachrichten nicht mehr in chronologischer Reihenfolge abgearbeitet werden, sobald sich die Überwachungsfunktion selbst unterbricht. Als Alternative zu <em>MaxThreads</em> sollte daher <em>Critical</em> in Betracht gezogen werden (siehe <a href="#Critical">unten</a>).</p></dd>

</dl>

<h3>Rückgabewerte</h3>
<p>Fehlt <em>Funktionsname</em>, wird der Name der Funktion zurückgegeben, die gerade <em>Nachrichtennummer</em> überwacht (leer, wenn keine).</p>
<p>Falls der <em>Funktionsname</em> ausdrücklich leer ist (d. h. ""), wird der Name der Funktion zurückgegeben, die zurzeit die <em>Nachrichtennummer</em> überwacht (leer, wenn nicht vorhanden). Danach wird die Überwachung der <em>Nachrichtennummer</em> deaktiviert.</p>
<p>Wenn <em>Funktionsname</em> nicht leer ist: Falls <em>Nachrichtennummer</em> bereits überwacht wird, wird der Name dieser Funktion zurückgegeben und danach die neue Funktion in Kraft gesetzt. Ansonsten wird <em>Funktionsname</em> dazu bestimmt, <em>Nachrichtennummer</em> zu überwachen und danach den selben <em>Funktionsnamen</em> zurückzugeben. In jedem Fall wird bei Misserfolg ein leerer Wert zurückgegeben. Fehler treten auf, wenn <em>Funktionsname</em>: 1) nicht existiert (vielleicht wegen fehlender Anführungszeichen um <em>Funktionsnamen</em>); 2) mehr als 4 Parameter akzeptiert; oder 3) v1.0.48.05 oder älter: <a href="../Functions.htm#ByRef">ByRef</a>- oder <a href="../Functions.htm#optional">optionale</a> Parameter hat. Es schlägt auch fehl, wenn das Script versucht, eine neue Nachricht zu überwachen, in dem bereits 500 Nachrichten überwacht werden.</p>

<h3>Die Parameter der Funktion</h3>
<p>Eine <a href="../Functions.htm">Funktion</a>, die eine oder mehrere Nachrichten überwachen soll, kann bis zu vier Parameter akzeptieren:</p>
<pre>EigeneNachrichtenüberwachung(wParam, lParam, msg, hwnd)
{
    ... Funktionsbereich ...
}</pre>
<p>Obwohl die Namensgebung für die Parameter keine Rolle spielt, werden folgende Informationen der Reihe nach zugewiesen:</p>
<p>Parameter #1: WPARAM-Wert der Nachricht.<br>
Parameter #2: LPARAM-Wert der Nachricht.<br>
Parameter #3: Nachrichtennummer - nützlich, falls die Funktion mehrere Nachrichten überwacht.<br>
Parameter #4: HWND (eindeutige ID) des Fensters oder Steuerelements, zu dem die Nachricht gesendet wurde. Das HWND kann mit <a href="../misc/WinTitle.htm#ahk_id">ahk_id</a> verwendet werden.</p>
<p>WPARAM und LPARAM sind vorzeichenlose 32-Bit-Integer (von 0 bis 2<sup>32</sup>-1) oder vorzeichenbehaftete 64-Bit-Integer (von -2<sup>63</sup> bis 2<sup>63</sup>-1), abhängig davon, ob die EXE-Datei, die das Script ausführt, 32- oder 64-Bit ist. Wenn bei 32-Bit-Scripts ein eingehender Parameter als vorzeichenbehafteter Integer vorgesehen ist, können negative Zahlen zum Beispiel wie folgt offenbart werden:</p>
<pre>If (A_PtrSize = 4 &amp;&amp; wParam &gt; 0x7FFFFFFF)  <em>; Das Überprüfen von <a href="../Variables.htm#PtrSize">A_PtrSize</a> stellt sicher, dass das Script 32-Bit ist.</em>
    wParam := -(~wParam) - 1</pre>
<p>Falls bestimmte Informationen nicht benötigt werden, können entsprechende Parameter am Listenende weggelassen werden. Zum Beispiel würde eine Funktion, definiert als <code>EigeneNachrichtenüberwachung(wParam, lParam)</code>, nur die ersten zwei Parameter empfangen. Eine Funktion, definiert als <code>EigeneNachrichtenüberwachung()</code>, würde hingegen keine Parameter empfangen.</p>

<h3>Weitere verfügbare Informationen für die Funktion</h3>
<p>Zusätzlich zu den oben genannten Parametern kann die Funktion auch auf die Werte der folgenden internen Variablen zurückgreifen:</p>
<ul>
  <li><a href="../Variables.htm#Gui">A_Gui</a>: Leer, es sei denn, die Nachricht wurde an ein GUI-Fenster oder Steuerelement gesendet, in diesem Fall enthält A_Gui die <a href="Gui.htm#MultiWin">Nummer des GUI-Fensters</a> (dieses Fenster wird auch das <a href="Gui.htm#DefaultWin">Standard-GUI-Fenster</a> der Funktion sein).</li>
  <li><a href="../Variables.htm#GuiControl">A_GuiControl</a>: Leer, es sei denn, die Nachricht wurde an ein GUI-Steuerelement gesendet, in diesem Fall enthält A_GuiControl den Variablennamen des Steuerelements oder andere Werte wie in <a href="../Variables.htm#GuiControl">A_GuiControl</a> beschrieben. Einige Steuerelemente können bestimmte Nachrichtentypen nie empfangen. Sobald der Benutzer beispielsweise ein <a href="GuiControls.htm#Text">Text-Steuerelement</a> anklickt, sendet das Betriebssystem WM_LBUTTONDOWN eher an das übergeordnete Fenster, als an das Steuerelement (folglich ist A_GuiControl leer).</li>
  <li><a href="../Variables.htm#GuiX">A_GuiX</a> und <a href="../Variables.htm#GuiX">A_GuiY</a>: Beide enthalten -2147483648, falls die eingehende Nachricht mit <a href="PostMessage.htm">SendMessage</a> gesendet wurde. Wenn die Nachricht mit <a href="PostMessage.htm">PostMessage</a> gesendet wurde, enthalten beide Variablen die Koordinaten des Mauszeigers (relativ zum Bildschirm).</li>
  <li><a href="../Variables.htm#EventInfo">A_EventInfo</a>: Enthält 0, wenn die eingehende Nachricht mit SendMessage gesendet wurde. Wenn die Nachricht mit PostMessage gesendet wurde, ist der <a href="../Variables.htm#TickCount">Tick-Count-Zeitpunkt</a> der Sendung enthalten.</li>
</ul>
<p>Das <a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a> einer Überwachungsfunktion ist zu Beginn das übergeordnete Fenster, zu dem die Nachricht gesendet wurde (auch dann, wenn die Nachricht an das Steuerelement gesendet wurde). Ist das Fenster versteckt, aber kein GUI-Fenster (z. B. das Hauptfenster des Scripts), muss <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> aktiviert werden, bevor es verwendet werden kann. Zum Beispiel:</p>
<pre>DetectHiddenWindows On
MsgParentWindow := WinExist()  <em>; Speichert die eindeutige ID des Fensters, zum dem die Nachricht gesendet wurde.</em></pre>

<h3>Was die Funktion per <em>Return</em> zurückgeben sollte</h3>
<p>Wenn eine Überwachungsfunktion <a href="Return.htm">Return</a> ohne Parameter verwendet oder ein leerer Wert wie "" angegeben ist (oder Return überhaupt nicht verwendet), wird die eingehende Nachricht normal verarbeitet, sobald die Funktion beendet wird. Das Gleiche passiert, wenn die Funktion mit <a href="Exit.htm">Exit</a> beendet wird oder einen Laufzeitfehler verursacht, wie z. B. das <a href="Run.htm">Ausführen</a> einer nicht vorhandenen Datei. Die Rückgabe eines Integers bewirkt hingegen, dass dieser sofort als Antwort gesendet wird. Das heißt, dass das Programm die Nachricht nicht weiter verarbeiten wird. Zum Beispiel könnte eine Funktion, die WM_LBUTTONDOWN (0x201) überwacht, ein Integer zurückgeben, um das Zielfenster daran zu hindern, benachrichtigt zu werden, dass ein Mausklick erfolgt ist. In vielen Fällen (z. B. der Nachrichtenempfang über <a href="PostMessage.htm">PostMessage</a>) spielt es keine Rolle, welcher Integer zurückgegeben wird; im Zweifelsfall ist eine 0 aber am sichersten.</p>
<p>Der Bereich von gültigen Rückgabewerten ist abhängig davon, ob die EXE-Datei, die das Script ausführt, 32- oder 64-Bit ist. Rückgabewerte ungleich 0 müssen bei 32-Bit-Scripts (<code><a href="../Variables.htm#PtrSize">A_PtrSize</a> = 4</code>) zwischen -2<sup>31</sup> und 2<sup>32</sup>-1 liegen, und bei 64-Bit-Scripts  (<code><a href="../Variables.htm#PtrSize">A_PtrSize</a> = 8</code>) zwischen -2<sup>63</sup> und 2<sup>63</sup>-1.</p>

<h3 id="Remarks">Allgemeine Bemerkungen</h3>
<p>Im Gegensatz zu einem normalen Funktionsaufruf ruft der Empfang einer überwachten Nachricht die Funktion als neuen <a href="../misc/Threads.htm">Thread</a> auf. Aus diesem Grund beginnt die Funktion mit den Standardwerten für Einstellungen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>. Diese können im <a href="../Scripts.htm#auto">automatischen Ausführungsbereich</a> geändert werden.</p>
<p>Nachrichten, die mit SendMessage (anstatt mit PostMessage) zu einem Steuerelement gesendet wurden, werden nicht überwacht, weil diese direkt und unauffällig an das Steuerelement weitergeleitet werden. Auf systemgesteuerte Nachrichten trifft das nicht zu, weil die meisten von ihnen mit PostMessage gesendet werden.</p>
<p>Sobald ein Script die OnMessage-Funktion aufruft, wird es automatisch <a href="_Persistent.htm">persistent</a>. Zudem kann das Script nur einmal vorkommen (Einzelinstanz), sofern das nicht mit <a href="_SingleInstance.htm">#SingleInstance</a> überschrieben wird.</p>
<p><a name="Critical"></a>Falls eine Nachricht ankommt, während ihre Funktion aufgrund eines vorherigen Aufrufs noch läuft, wird die Funktion nicht erneut aufgerufen (außer wenn <a href="#MaxThreads">MaxThreads</a> größer als 1 ist). Die Nachricht wird stattdessen als nicht überwacht angesehen. Wenn das unerwünscht ist, kann eine Nachricht größer gleich 0x312 durch Angabe von <a href="Critical.htm">Critical</a> zwischengespeichert werden, bis deren Funktion vollständig ausgeführt wurde. Alternativ kann mit <a href="Thread.htm">Thread Interrupt</a> das gleiche erreicht werden, solange genug Zeit bleibt, die Funktion zu beenden. Eine Nachricht kleiner als 0x312 kann hingegen nicht mit Critical oder "Thread Interrupt" zwischengespeichert werden (seit v1.0.46 könnte Critical allerdings helfen, weil dieser Befehl die Nachrichten <a href="Critical.htm#Interval">nicht so häufig</a> überprüft, wodurch die Funktion mehr Zeit zum Beenden hat). Damit solche Nachrichten garantiert nicht verloren gehen können, muss sichergestellt werden, dass die Funktion nicht länger als 6 Millisekunden ausgeführt wird (dieses Limit kann mit <a href="Critical.htm#Interval"><em>Critical 30</em></a> angehoben werden). Zum Beispiel kann dafür ein zukünftiger Thread in die Warteschlange gesetzt werden, indem eine überwachte Nachrichtennummer größer als 0x312 an das eigene Script mit PostMessage <a href="PostMessage.htm">gesendet</a> wird. Die Funktion dieser Nachricht sollte <a href="Critical.htm">Critical</a> in der ersten Zeile verwenden, um sicherzustellen, dass deren Nachrichten zwischengespeichert werden.</p>
<p>Wenn eine überwachte Nachrichtennummer kleiner als 0x312 eintrifft, während das Script absolut unterbrechungsfrei ist (z. B. während ein <a href="Menu.htm">Menü</a> angezeigt wird, <a href="SetKeyDelay.htm">KeyDelay</a>/<a href="SetMouseDelay.htm">MouseDelay</a> im Gange ist oder die Zwischenablage <a href="_ClipboardTimeout.htm">offen</a> ist), wird die Nachrichtenfunktion nicht aufgerufen und die Nachricht als nicht überwacht angesehen. Überwachte Nachrichten größer gleich 0x312 werden hingegen in diesen unterbrechungsfreien Perioden zwischengespeichert, das heißt, dass die Funktion aufgerufen wird, sobald das Script wieder unterbrechbar ist.</p>
<p>Wenn eine überwachte Nachrichtennummer kleiner als 0x312 eintrifft, während das Script aufgrund der Einstellungen von <a href="Thread.htm">Thread Interrupt</a> oder <a href="Critical.htm">Critical</a> unterbrechungsfrei ist, wird der aktuelle Thread unterbrochen, damit die Funktion aufgerufen werden kann. Eine überwachte Nachricht größer gleich 0x312 wird hingegen zwischengespeichert, bis der Thread endet oder unterbrechbar wird.</p>
<p>Die <a href="../misc/Threads.htm">Priorität</a> von OnMessage-Threads ist immer 0. Folglich werden Nachrichten weder überwacht noch zwischengespeichert, wenn der aktuelle Thread eine Priorität höher als 0 hat.</p>
<p>Bei der Überwachung von Systemnachrichten ist Vorsicht geboten (solche unter 0x400). Wenn zum Beispiel eine Überwachungsfunktion nicht schnell genug zum Abschluss kommt, kann die Reaktion auf die Nachricht länger dauern als vom System erwartet, wodurch Nebeneffekte auftreten können. Diese können auch auftreten, wenn eine Überwachungsfunktion ein Integer zurückgibt, um die weitere Verarbeitung einer Nachricht zu unterdrücken, aber das System voraussichtlich eine andere Verarbeitung oder Reaktion erwartet.</p>
<p>Sobald das Script ein Dialogfenster wie <a href="MsgBox.htm">MsgBox</a> anzeigt, werden gesendete Nachrichten an ein Steuerelement nicht länger überwacht. Wenn das Script zum Beispiel eine MsgBox anzeigt und der Benutzer eine Schaltfläche in einem GUI-Fenster anklickt, wird die WM_LBUTTONDOWN-Nachricht direkt zur Schaltfläche gesendet, ohne dabei die Überwachungsfunktion aufzurufen.</p>
<p>Obwohl ein externes Programm in der Lage wäre, Nachrichten direkt mit PostThreadMessage() oder anderen API-Funktionen an ein Script-Thread zu senden, ist das nicht zu empfehlen, weil die Nachrichten dabei verloren gehen können, falls das Script ein Dialogfenster wie <a href="MsgBox.htm">MsgBox</a> anzeigt. Stattdessen ist es besser, PostMessage- oder SendMessage-Nachrichten an das Hauptfenster des Scripts oder dessen GUI-Fenster zu senden.</p>
<h3>Siehe auch</h3>
<p><a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="OnExit.htm">OnExit</a>, <a href="../misc/Clipboard.htm#OnClipboardChange">OnClipboardChange</a>, <a href="PostMessage.htm">Post/SendMessage</a>, <a href="../Functions.htm">Funktionen</a>, <a href="../misc/SendMessageList.htm">Liste mit Fensternachrichten</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Critical.htm">Critical</a>, <a href="DllCall.htm">DllCall()</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel: Das folgende Script überwacht Mausklicks innerhalb eines GUI-Fensters.
; Verwandtes Thema: <a href="Gui.htm#GuiContextMenu">GuiContextMenu</a></em>

Gui, Add, Text,, Irgendwo auf das Fenster klicken.
Gui, Add, Edit, w200 vEigenesEdit
Gui, Show
OnMessage(0x201, "WM_LBUTTONDOWN")
Return

WM_LBUTTONDOWN(wParam, lParam)
{
    X := lParam &amp; 0xFFFF
    Y := lParam &gt;&gt; 16
    If A_GuiControl
        Steuerelement := "`n(im Steuerelement " . A_GuiControl . ")"
    ToolTip Sie haben im GUI-Fenster #%A_Gui% auf die Koordinaten %X%x%Y% geklickt.%Steuerelement%
}

GuiClose:
ExitApp</pre>

<pre class="NoIndent"><a name="shutdown"></a><em>; Beispiel: Das folgende Script erkennt das Abmelden/Herunterfahren des Systems und erlaubt dem Benutzer, es abzubrechen (funktioniert NICHT in Windows Vista und höher).
; Verwandtes Thema: <a href="OnExit.htm">OnExit</a></em>

<em>; Der folgende Aufruf von DllCall ist optional: dem OS wird mitgeteilt, <i>zuerst</i> das Script zu beenden (vor allen anderen Anwendungen).</em>
DllCall("kernel32.dll\SetProcessShutdownParameters", UInt, 0x4FF, UInt, 0)
OnMessage(0x11, "WM_QUERYENDSESSION")
Return

WM_QUERYENDSESSION(wParam, lParam)
{
    ENDSESSION_LOGOFF = 0x80000000
    If (lParam &amp; ENDSESSION_LOGOFF)  <em>; Benutzer meldet sich ab.</em>
        Ereignis = Abmeldung
    Else  <em>; System wird entweder heruntergefahren oder neu gestartet.</em>
        Ereignis = Herunterfahren
    MsgBox, 4,, %Ereignis% im Gange.  Erlauben?
    IfMsgBox Yes
        Return true  <em>; Erlaubt dem OS, herunterzufahren/abzumelden.</em>
    Else
        Return false  <em>; Herunterfahren/Abmelden wird abgebrochen.</em>
}</pre>

<pre class="NoIndent"><em>; Beispiel: Bewirkt, dass ein Script eine benutzerdefinierte Nachricht und bis zu zwei Zahlen von einem anderen Script oder Programm erhält
; (um Strings anstelle von Zahlen zu senden, siehe nächstes Beispiel).</em>

OnMessage(0x5555, "MsgMonitor")
OnMessage(0x5556, "MsgMonitor")

MsgMonitor(wParam, lParam, msg)
{
    <em>; Da das schnelle Beenden wichtig ist, ist es besser, ein ToolTip zu verwenden,</em>
    <em>; anstatt eine MsgBox, die die Funktion daran hindert, zu beenden:</em>
    ToolTip Nachricht %msg% eingetroffen:`nWPARAM: %wParam%`nLPARAM: %lParam%
}

<em>; Die folgenden Zeilen können innerhalb eines anderen Scripts verwendet werden, um die Funktion im oberen Script auszuführen:</em>
SetTitleMatchMode 2
DetectHiddenWindows On
If WinExist("Empfänger.ahk ahk_class AutoHotkey")
    PostMessage, 0x5555, 11, 22  <em>; Die Nachricht wird aufgrund von WinExist() an das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" gesendet.</em>
DetectHiddenWindows Off  <em>; Muss nicht deaktiviert werden, bis nach PostMessage.</em></pre>

<pre class="NoIndent"><a name="SendString"></a><em>; Beispiel: Sendet einen String mit beliebiger Länge von einem Script zum anderen.  Das ist ein funktionierendes Beispiel.
; Um es zu verwenden, müssen beide folgende Scripts gespeichert und ausgeführt und danach WIN+LEERTASTE gedrückt werden,
; um eine InputBox anzuzeigen, die den Benutzer auffordert, einen String einzugeben.</em>

<em>; Speichert das folgende Script als "<strong>Empfänger.ahk</strong>" und startet es:</em>
#SingleInstance
OnMessage(0x4a, "WM_COPYDATA_Empfangen")  <em>; 0x4a ist WM_COPYDATA</em>
Return

WM_COPYDATA_Empfangen(wParam, lParam)
{
    Stringadresse := NumGet(lParam + 2*A_PtrSize)  <em>; Ermittelt die Adresse vom lpData-Element in CopyDataStruct.</em>
    Datenkopie := StrGet(Stringadresse)  <em>; Kopiert den String aus der Struktur.</em>
    <em>; Mit ToolTip anzeigen, damit wir rechtzeitig zurückkehren können:</em>
    ToolTip %A_ScriptName%`nFolgender String empfangen:`n%Datenkopie%
    Return true  <em>; Die Rückgabe von 1 (wahr) ist der traditionelle Weg, um diese Nachricht zu bestätigen.</em>
}

<em>; Speichert das folgende Script als "<strong>Sender.ahk</strong>" und startet es:  Drückt danach den Hotkey WIN+LEERTASTE.</em>
Empfängertitel = Empfänger.ahk ahk_class AutoHotkey

#space::  <em>; Hotkey: WIN+LEERTASTE. Drücken, um eine InputBox für die Eingabe eines String anzuzeigen.</em>
InputBox, StringSenden, Text mit WM_COPYDATA senden, Beliebigen Text eingeben:
If ErrorLevel  <em>; Benutzer hat die Abbrechen-Schaltfläche gedrückt.</em>
    Return
Ergebnis := WM_COPYDATA_Senden(StringSenden, Empfängertitel)
If Ergebnis = FAIL
    MsgBox SendMessage fehlgeschlagen. Existiert der folgende Fenstertitel?:`n%Empfängertitel%
Else If Ergebnis = 0
    MsgBox Nachricht gesendet, aber das Zielfenster hat mit 0 geantwortet (es ignoriert die Nachricht).
Return

WM_COPYDATA_Senden(ByRef StringSenden, ByRef Empfängertitel)  <em>; ByRef spart in diesem Fall ein wenig Speicherplatz.
; Diese Funktion sendet den angegebenen String an das angegebene Fenster und gibt eine Anwort zurück.
; Die Antwort ist 1, wenn das Zielfenster die Nachricht verarbeitet hat oder 0, wenn die Nachricht ignoriert wurde.</em>
{
    VarSetCapacity(CopyDataStruct, 3*A_PtrSize, 0)  <em>; Bestimmt den Speicherbereich der Struktur.</em>
    <em>; Zuerst wird das cbData-Element der Struktur auf die Größe des Strings gesetzt, einschließlich dem Null-Terminator.</em>
    GrößeInBytes := (StrLen(StringSenden) + 1) * (A_IsUnicode ? 2 : 1)
    NumPut(GrößeInBytes, CopyDataStruct, A_PtrSize)  <em>; OS setzt voraus, dass das getan werden muss.</em>
    NumPut(&amp;StringSenden, CopyDataStruct, 2)  <em>; lpData zeigt auf dem String selbst.</em>
    DetectHiddenWindows_Vorher := A_DetectHiddenWindows
    TitleMatchMode_Vorher := A_TitleMatchMode
    DetectHiddenWindows On
    SetTitleMatchMode 2
    SendMessage, 0x4a, 0, &amp;CopyDataStruct,, %Empfängertitel%  <em>; 0x4a ist WM_COPYDATA. Verwendet Send, nicht Post.</em>
    DetectHiddenWindows %DetectHiddenWindows_Vorher%  <em>; Stellt die ursprüngliche Einstellung wieder her.</em>
    SetTitleMatchMode %TitleMatchMode_Vorher%         <em>; Das Gleiche.</em>
    Return ErrorLevel  <em>; Die Antwort von SendMessage zurückgeben.</em>
}</pre>

<pre class="NoIndent"><em>; Beispiel: Siehe <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Script</a>, wie OnMessage() verwendet werden kann,
; um Meldungen zu empfangen, wenn Daten in einer Netzwerkverbindung angekommen sind.</em></pre>

</body>
</html>
