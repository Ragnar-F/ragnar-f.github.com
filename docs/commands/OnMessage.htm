<!DOCTYPE HTML>
<html>
<head>
<title>OnMessage</title>
<meta name="keywords" content="Befehl, Grafische Benutzeroberfl&auml;che">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="wrapper">
  <div id="content"> 
    <script src="../navbar/NavScript.js" type="text/javascript"></script> 
    <script type="text/javascript">WriteNavLink(1);</script>
    <h1>OnMessage()</h1>
    <p>Ruft automatisch eine <a href="../Functions.htm">Funktion</a> auf, wenn das Script die angegebene Nachricht empf&auml;ngt.</p>
    <pre class="Syntax">OnMessage(Nachrichtennummer [, "Funktionsname", MaxThreads])</pre>
    <h3>Parameter</h3>
    <table class="info">
      <tr>
        <td style="width: 15%;">Nachrichtennummer</td>
        <td style="width: 85%;">Anzahl an Nachrichten zwischen 0 und 4294967295 (0xFFFFFFFF), die &uuml;berwacht oder abgefragt werden. Wenn es nicht erw&uuml;nscht ist, eine <a href="../misc/SendMessageList.htm">Systemnachricht</a> zu &uuml;berwachen (eine unter 0x400), verwendet eine Nummer gr&ouml;&szlig;er als 4096 (0x1000). Dadurch werden St&ouml;rungen mit Nachrichten der aktuellen oder zuk&uuml;nftigen Versionen von AutoHotkey reduziert, die intern verwendet werden.</td>
      </tr>
      <tr>
        <td>Funktionsname</td>
        <td>Der Name einer <a href="../Functions.htm">Funktion</a>, welcher in Anf&uuml;hrungszeichen gesetzt werden muss, wenn er ein direkt vorhandener String ist. Diese Funktion wird automatisch aufgerufen, wenn das Script eine <em>Nachrichtennummer</em> empf&auml;ngt. Diesen und den n&auml;chsten Parameter weglassen, um den Namen der Funktion zu ermitteln, welcher zurzeit die <em>Nachrichtennummer</em> &uuml;berwacht (leer, wenn nicht vorhanden). Verwendet einen leeren String ("") oder eine leere Variable, um die &Uuml;berwachung der <em>Nachrichtennummer</em> zu deaktivieren.</td>
      </tr>
      <tr>
        <td>MaxThreads<br>
          <span class="ver">[v1.0.47+]</span></td>
        <td id="MaxThreads">Dieser Integer wird normalerweise weggelassen, um die &Uuml;berwachungsfunktion auf einen <a href="../misc/Threads.htm">Thread</a> zu begrenzen. F&uuml;r gew&ouml;hnlich am besten, weil sonst das Script die Nachrichten nicht in chronologischer Reihenfolge bearbeitet, sobald die &Uuml;berwachungsfunktion sich selbst unterbricht. Daher kann im Gegensatz zu den <em>MaxThreads</em> der Befehl <em>Critical</em> als Alternative verwendet werden, wie <a href="#Critical">unten</a> beschrieben.</td>
      </tr>
    </table>
    <h3>R&uuml;ckgabewerte</h3>
    <p>Wenn der <em>Funktionsname</em> und die <em>MaxThreads</em> weglassen werden, dann wird der Name der Funktion zur&uuml;ckgegeben, welcher zurzeit die <em>Nachrichtennummer</em> &uuml;berwacht (leer, wenn nicht vorhanden). Es werden jedoch keine &Auml;nderungen vorgenommen.</p>
    <p>Wenn der <em>Funktionsname</em> eindeutig leer ist (z. B. ""), dann wird der Name der Funktion zur&uuml;ckgegeben, welcher zurzeit die <em>Nachrichtennummer</em> &uuml;berwacht (leer, wenn nicht vorhanden). Danach wird die &Uuml;berwachung der <em>Nachrichtennummer</em> deaktiviert.</p>
    <p>Wenn der <em>Funktionsname</em> nicht leer ist: Wenn die <em>Nachrichtennummer</em> bereits &uuml;berwacht wird, dann wird der Name der Funktion zur&uuml;ckgegeben und die neue Funktion aktiviert. Andernfalls wird der <em>Funktionsname</em> verwendet, die <em>Nachrichtennummer</em> zu &uuml;berwachen und den gleichen <em>Funktionsname</em> zur&uuml;ckzugeben. In jedem Fall wird bei Misserfolg ein leerer Wert zur&uuml;ckgegeben. Fehler treten auf, wenn der <em>Funktionsname</em>: 1) nicht existiert (vielleicht wegen fehlender Anf&uuml;hrungszeichen um <em>Funktionsnamen</em>); 2) mehr als 4 Parameter akzeptiert, oder 3) beliebige <a href="../Functions.htm#ByRef">ByRef</a>- oder <a href="../Functions.htm#optional">optionale</a> Parameter hat. Es schl&auml;gt auch fehl, wenn das Script versucht, eine neue Nachricht zu &uuml;berwachen, falls bereits 500 Nachrichten &uuml;berwacht werden.</p>
    <h3>Die Parameter der Funktion</h3>
    <p>Eine <a href="../Functions.htm">Funktion</a>, die beliebig viele Nachrichten &uuml;berwacht, kann bis zu vier Parameter akzeptieren:</p>
    <pre>EigeneNachrichten&uuml;berwachung(wParam, lParam, msg, hwnd)
{
    ... Funktionsbereich ...
}</pre>
    <p>Obwohl die Namensgebung f&uuml;r die Parameter keine Rolle spielt, wird die folgende Information nachfolgend zugewiesen:</p>
    <p>Parameter #1: Der WPARAM-Wert der Nachricht, eine Integer zwischen 0 und 4294967295.<br>
      Parameter #2: Der LPARAM-Wert der Nachricht, eine Integer zwischen 0 und 4294967295.<br>
      Parameter #3: Die Nummer der Nachricht, welche n&uuml;tzlich ist, falls die Funktion mehrere Nachrichten &uuml;berwacht.<br>
      Parameter #4: HWND (einzigartige ID) des Fensters oder Steuerelements, das die Nachricht empfangen hat. HWND kann mit <a href="../LastFoundWindow.htm#id">ahk_id</a> verwendet werden.</p>
    <p>Es k&ouml;nnen beliebig viele Parameter am Ende der Liste weggelassen werden, wenn die entsprechende Information nicht ben&ouml;tigt wird. Eine Funktion, definiert als <em>EigeneNachrichten&uuml;berwachung(wParam, lParam)</em>, empf&auml;ngt zum Beispiel nur die ersten zwei Parameter und eine Funktion, definiert als <em>EigeneNachrichten&uuml;berwachung()</em>, keinen Parameter.</p>
    <p>Wenn ein eingehender WPARAM oder LPARAM als signed Integer vorgesehen ist, dann k&ouml;nnen negative Zahlen mit dem folgenden Beispiel offenbart werden:</p>
    <pre>If wParam &gt; 0x7FFFFFFF
    wParam := -(~wParam) - 1</pre>
    <h3>Weitere verf&uuml;gbare Informationen f&uuml;r die Funktion</h3>
    <p>Zus&auml;tzlich zu den oben genannten Parametern kann die Funktion auch die Werte der folgenden internen Variablen abfragen:</p>
    <ul>
      <li><a href="../Variables.htm#Gui">A_Gui</a>: Leer, es sei denn, die Nachricht wurde an ein GUI-Fenster oder Steuerelement gesendet, in diesem Fall enth&auml;lt A_Gui die <a href="Gui.htm#MultiWin">Nummer des GUI-Fensters</a> (dieses Fenster wird auch als <a href="Gui.htm#DefaultWin">Standard-GUI-Fenster</a> der Funktion bestimmt).</li>
      <li> <a href="../Variables.htm#GuiControl">A_GuiControl</a>: Leer, es sei denn, die Nachricht wurde an ein GUI-Steuerelement gesendet, in diesem Fall enth&auml;lt A_GuiControl den Variablennamen des Steuerelements oder andere Werte wie in <a href="../Variables.htm#GuiControl">A_GuiControl</a> beschrieben. Einige Steuerelemente empfangen nie bestimmte Typen von Nachrichten. Wenn der Benutzer beispielsweise auf einem <a href="GuiControls.htm#Text">Text-Steuerelement</a> klickt, dann sendet das Betriebssystem WM_LBUTTONDOWN eher an das &uuml;bergeordnete Fenster, als an das Steuerelement (folglich ist A_GuiControl leer).</li>
      <li> <a href="../Variables.htm#GuiX">A_GuiX</a> und <a href="../Variables.htm#GuiX">A_GuiY</a>: Beide enthalten -2147483648, wenn die eingehende Nachricht mittels <a href="PostMessage.htm">SendMessage</a> gesendet wurde. Wenn es mittels <a href="PostMessage.htm">PostMessage</a> gesendet wurde, dann enthalten die beiden Variablen die Koordinaten des Mauszeigers (bezogen auf dem Bildschirm).</li>
      <li> <a href="../Variables.htm#EventInfo">A_EventInfo</a>: Enth&auml;lt 0, wenn die eingehende Nachricht mittels SendMessage gesendet wurde. Wenn mittels PostMessage gesendet wurde, dann enth&auml;lt diese Variable die <a href="../Variables.htm#TickCount">Tick-Count-Zeit</a>, wann die Nachricht gesendet wurde.</li>
    </ul>
    <p>Das <a href="../LastFoundWindow.htm">zuletzt gefundene Fenster</a> der &Uuml;berwachungsfunktion startet als das &uuml;bergeordnete Fenster, welches die Nachricht empfangen hat (selbst wenn die Nachricht an das Steuerelement gesendet wurde). Wenn das Fenster versteckt ist, aber kein GUI-Fenster (z. B. das Hauptfenster des Scripts), dann muss <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> aktiviert werden, damit es funktioniert. Zum Beispiel:</p>
    <pre>DetectHiddenWindows On
MsgParentWindow := WinExist()  <em>; Damit wird die eindeutige ID des Fensters gespeichert, welches die Nachricht empfangen hat.</em></pre>
    <h3>Was die Funktion <em>zur&uuml;ckgeben</em> sollte</h3>
    <p>Wenn eine &Uuml;berwachungsfunktion <a href="Return.htm">Return</a> ohne Parameter verwendet oder ein leerer Wert wie "" angegeben ist (oder &uuml;berhaupt nicht Return verwendet), dann wird die eingehende Nachricht normal verarbeitet, sobald die Funktion beendet wird. Das Gleiche passiert, wenn die Funktion mit <a href="Exit.htm">Exit</a> beendet wird oder einen Laufzeitfehler verursacht (z. B. eine nicht existierende Datei <a href="Run.htm">ausf&uuml;hren</a>). Die R&uuml;ckgabe eines Integers zwischen -2147483648 und 4294967295 bewirkt hingegen, dass die Nummer sofort als Antwort gesendet wird, das hei&szlig;t, dass das Programm die Nachricht nicht weiter verarbeitet. Zum Beispiel k&ouml;nnte eine Funktion beim &Uuml;berwachen von WM_LBUTTONDOWN (0x201) ein Integer zur&uuml;ckgeben, damit das Zielfenster nicht benachrichtigt werden kann, dass ein Mausklick erfolgt ist. In vielen F&auml;llen (z. B. beim Empfang einer Nachricht mittels <a href="PostMessage.htm">PostMessage</a>) spielt es keine Rolle, welcher Integer zur&uuml;ckgegeben wird; im Zweifelsfall ist eine 0 aber am sichersten.</p>
    <h3 id="Remarks">Allgemeine Bemerkungen</h3>
    <p>Im Gegensatz zu einem normalen Funktionsaufruf ruft der Empfang einer &uuml;berwachten Nachricht die Funktion als neuen <a href="../misc/Threads.htm">Thread</a> auf. Deshalb startet die Funktion mit den Standardwerten f&uuml;r die Einstellungen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>. Diese k&ouml;nnen im <a href="../Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> ge&auml;ndert werden.</p>
    <p>Nachrichten, die an einem Steuerelement mit SendMessage gesendet werden, werden nicht &uuml;berwacht, weil das System diese Nachrichten direkt zum Steuerelement hinter den Kulissen leitet. Das ist selten ein Problem f&uuml;r systemgesteuerte Nachrichten, weil die meisten von ihnen mit PostMessage gesendet werden.</p>
    <p>Jedes Script, das OnMessage irgendwo aufruft, wird automatisch <a href="_Persistent.htm">persistent</a>. Es kommt auch erst einzeln vor, wenn <a href="_SingleInstance.htm">#SingleInstance</a> verwendet wird.</p>
    <p id="Critical">Wenn eine Nachricht eintrifft, w&auml;hrend die Funktion noch durch einen fr&uuml;heren Empfang der gleichen Nachricht l&auml;uft, dann wird die Funktion nicht erneut aufgerufen (au&szlig;er wenn die <a href="#MaxThreads">MaxThreads</a> gr&ouml;&szlig;er als 1 sind), stattdessen wird die Nachricht nicht &uuml;berwacht. Wenn dies unerw&uuml;nscht ist, dann kann eine Nachricht gr&ouml;&szlig;er gleich 0x312 zwischengespeichert werden, bis die Funktion komplett ausgef&uuml;hrt wird, wenn <a href="Critical.htm">Critical</a> in der ersten Zeile steht. Alternativ bewirkt <a href="Thread.htm">Thread Interrupt</a> das Gleiche, solange die Funktion genug Zeit hat, sich zu beenden. Eine Nachricht kleiner als 0x312 kann hingegen nicht mit Critical oder "Thread Interrupt" zwischengespeichert werden (allerdings kann Critical seit v1.0.46 helfen, weil dadurch die Nachrichten <a href="Critical.htm#Interval">weniger h&auml;ufig</a> &uuml;berpr&uuml;ft werden, damit die Funktion mehr Zeit hat, sich zu beenden). Der einzige Weg, um zu garantieren, dass solche Nachrichten nicht verpasst werden, ist sicherzustellen, dass die Funktion unter 6 Millisekunden beendet wird (obwohl diese Grenze mittels <a href="Critical.htm#Interval"><em>Critical 30</em></a> angehoben werden kann). Zum Beispiel kann daf&uuml;r ein zuk&uuml;nftiger Thread in die Warteschlange gesetzt werden, wenn eine &uuml;berwachte Nachricht gr&ouml;&szlig;er als 0x312 an das eigene Script <a href="PostMessage.htm">gesendet</a> wird. Die Funktion dieser Nachricht sollte <a href="Critical.htm">Critical</a> in der ersten Zeile verwenden, damit die Nachrichten zur Sicherheit zwischengespeichert werden.</p>
    <p>Wenn eine &uuml;berwachte Nachricht kleiner als 0x312 empfangen wird, w&auml;hrend das Script absolut unterbrechungsfrei ist (z. B. w&auml;hrend ein <a href="Menu.htm">Men&uuml;</a> angezeigt wird, <a href="SetKeyDelay.htm">KeyDelay</a>/<a href="SetMouseDelay.htm">MouseDelay</a> im Gange ist oder die Zwischenablage <a href="_ClipboardTimeout.htm">offen</a> ist), dann wird die Funktion der Nachricht nicht aufgerufen und &uuml;berwacht.  Eine &uuml;berwachte Nachricht gr&ouml;&szlig;er gleich 0x312 wird hingegen in diesen unterbrechungsfreien Perioden zwischengespeichert, das hei&szlig;t, dass die Funktion aufgerufen wird, sobald das Script wieder unterbrechbar ist.</p>
    <p>Wenn eine &uuml;berwachte Nachricht kleiner als 0x312 eintrifft, w&auml;hrend das Script aufgrund der Einstellungen in <a href="Thread.htm">Thread Interrupt</a> oder <a href="Critical.htm">Critical</a> unterbrechungsfrei ist, dann wird der aktuelle Thread unterbrochen, damit die Funktion aufgerufen werden kann. Eine &uuml;berwachte Nachricht gr&ouml;&szlig;er gleich 0x312 wird hingegen zwischengespeichert, bis der Thread beendet oder unterbrechbar wird.</p>
    <p>Die <a href="../misc/Threads.htm">Priorit&auml;t</a> der OnMessage-Threads ist immer 0. Daher werden keine Nachrichten &uuml;berwacht oder zwischengespeichert, wenn der aktuelle Thread eine Priorit&auml;t h&ouml;her als 0 hat.</p>
    <p>Bei der &Uuml;berwachung von Systemnachrichten ist Vorsicht geboten (die unter 0x400). Wenn zum Beispiel eine &Uuml;berwachungsfunktion nicht schnell genug beendet wird, dann kann die Reaktion auf die Nachricht l&auml;nger dauern als vom System erwartet, was zu Nebenwirkungen f&uuml;hren kann. Unerw&uuml;nschtes Verhalten kann auch auftreten, wenn eine &Uuml;berwachungsfunktion ein Integer zur&uuml;ck gibt, um das Verarbeiten einer nachfolgenden Nachricht zu unterdr&uuml;cken, aber das System voraussichtlich eine andere Verarbeitung oder andere Reaktion erwartet.</p>
    <p>Wenn das Script ein System-Dialogfenster wie <a href="MsgBox.htm">MsgBox</a> anzeigt, dann wird jede gesendete Nachricht an einem Steuerelement nicht &uuml;berwacht. Wenn das Script zum Beispiel eine MsgBox anzeigt und der Benutzer auf eine Schaltfl&auml;che in einem GUI-Fenster klickt, dann wird die WM_LBUTTONDOWN-Nachricht direkt an die Schaltfl&auml;che gesendet, ohne dabei die &Uuml;berwachungsfunktion aufzurufen.</p>
    <p>Obwohl ein externes Programm mehrere Nachrichten mithilfe von PostThreadMessage() oder anderen API-Funktionen direkt an einem Thread des Scripts senden kann, ist das nicht zu empfehlen, weil die Nachrichten verloren gehen, sobald das Script ein System-Dialogfenster wie <a href="MsgBox.htm">MsgBox</a> anzeigt. Stattdessen ist es normalerweise am besten, Nachrichten an das Hauptfenster oder GUI-Fenster des Scripts zu senden.</p>
    <h3>Verwandte Befehle</h3>
    <p><a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="OnExit.htm">OnExit</a>, <a href="../misc/Clipboard.htm#OnClipboardChange">OnClipboardChange</a>, <a href="PostMessage.htm">Post/SendMessage</a>, <a href="../Functions.htm">Funktionen</a>, <a href="../misc/SendMessageList.htm">Liste mit Fensternachrichten</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Critical.htm">Critical</a>, <a href="DllCall.htm">DllCall()</a></p>
    <h3>Beispiele</h3>
    <pre class="NoIndent"><em>; Beispiel: Das folgende funktionierende Script &uuml;berwacht Mausklicks in einem GUI-Fenster.
; Verwandtes Thema: <a href="Gui.htm#GuiContextMenu">GuiContextMenu</a></em>

Gui, Add, Text,, Irgendwo auf das Fenster klicken.
Gui, Add, Edit, w200 vEigenesEdit
Gui, Show
OnMessage(0x201, "WM_LBUTTONDOWN")
Return

WM_LBUTTONDOWN(wParam, lParam)
{
    X := lParam & 0xFFFF
    Y := lParam &gt;&gt; 16
    If A_GuiControl
        Control := "`n(im Steuerelement " . A_GuiControl . ")"
    ToolTip Du hast im GUI-Fenster #%A_Gui% auf den Koordinaten %X%x%Y% geklickt.%Control%
}

GuiClose:
ExitApp</pre>
    <pre class="NoIndent" id="shutdown"><em>; Beispiel: Das folgende Script erkennt das Abmelden/Herunterfahren des Systems und erlaubt dem Benutzer, es abzubrechen (funktioniert NICHT in Windows Vista und h&ouml;her).
; Verwandtes Thema: <a href="OnExit.htm">OnExit</a></em>

<em>; Der folgende Aufruf von DllCall ist optional: Dem OS wird mitgeteilt, <i>zuerst</i> das Script zu beenden (vor allen anderen Anwendungen).
; Dieser Aufruf hat keine Wirkung in Windows 9x.</em>
DllCall("kernel32.dll\SetProcessShutdownParameters", UInt, 0x4FF, UInt, 0)
OnMessage(0x11, "WM_QUERYENDSESSION")
Return

WM_QUERYENDSESSION(wParam, lParam)
{
    ENDSESSION_LOGOFF = 0x80000000
    If (lParam & ENDSESSION_LOGOFF)  <em>; Benutzer meldet sich ab.</em>
        EventType = Logoff
    Else  <em>; System wird entweder heruntergefahren oder neu gestartet.</em>
        EventType = Shutdown
    MsgBox, 4,, %EventType% im Gange.  Erlauben?
    IfMsgBox Yes
        Return true  <em>; Erlaubt dem OS, herunterzufahren/abzumelden.</em>
    Else
        Return false  <em>; Herunterfahren/Abmelden wird abgebrochen.</em>
}</pre>
    <pre class="NoIndent"><em>; Beispiel: Damit empf&auml;ngt ein Script eine benutzerdefinierte Nachricht und bis zu zwei Zahlen von einigen anderen Scripts oder Programme
; (um Strings anstelle von Zahlen zu senden, siehe n&auml;chstes Beispiel).</em>

OnMessage(0x5555, "MsgMonitor")
OnMessage(0x5556, "MsgMonitor")

MsgMonitor(wParam, lParam, msg)
{
    <em>; Da das schnelle Zur&uuml;ckgeben wichtig ist, ist es besser, ein ToolTip zu verwenden, anstatt</em>
    <em>; sowas wie eine MsgBox, die die Funktion daran hindert, beendet zu werden:</em>
    ToolTip Nachricht %msg% eingetroffen:`nWPARAM: %wParam%`nLPARAM: %lParam%
}

<em>; Das Folgende kann innerhalb eines anderen Scripts verwendet werden, um die Funktion im oberen Script auszuf&uuml;hren:</em>
SetTitleMatchMode 2
DetectHiddenWindows On
If WinExist("Script-Name des Empf&auml;ngers.ahk ahk_class AutoHotkey")
    PostMessage, 0x5555, 11, 22  <em>; Die Nachricht wird durch WinExist() zum "<a href="../LastFoundWindow.htm">zuletzt gefundenen Fenster</a>" gesendet.</em>
DetectHiddenWindows Off  <em>; Muss nicht deaktiviert werden, bis nach PostMessage.</em></pre>
    <pre class="NoIndent" id="SendString"><em>; Beispiel: Sendet einen String mit beliebiger L&auml;nge von einem Script zum anderen.  Das ist ein funktionierendes Beispiel.
; Um es zu verwenden, speichert und startet folgende Scripts und dr&uuml;ckt danach Win+Leertaste,
; um eine InputBox anzuzeigen, die den Benutzer auffordert, einen String einzugeben.</em>

<em>; Speichert das folgende Script als "<strong>Empf&auml;nger.ahk</strong>" und startet es:</em>
#SingleInstance
OnMessage(0x4a, "WM_COPYDATA_Empfangen")  <em>; 0x4a ist WM_COPYDATA</em>
Return

WM_COPYDATA_Empfangen(wParam, lParam)
{
    Stringadresse := NumGet(lParam + 2*A_PtrSize)  <em>; Ermittelt die Adresse vom lpData-Element in CopyDataStruct.</em>
    Datenkopie := StrGet(Stringadresse)  <em>; Kopiert den String aus der Struktur.</em>
    <em>; Mit ToolTip anzeigen, damit wir rechtzeitig zur&uuml;ckkehren k&ouml;nnen:</em>
    ToolTip %A_ScriptName%`nFolgender String empfangen:`n%Datenkopie%
    Return true  <em>; Die R&uuml;ckgabe von 1 (wahr) ist der traditionelle Weg, um diese Nachricht zu best&auml;tigen.</em>
}

<em>; Speichert das folgende Script als <strong>"Sender.ahk"</strong> und startet es:  Dr&uuml;ckt danach den Hotkey Win+Leertaste.</em>
Empf&auml;ngertitel = Empf&auml;nger.ahk ahk_class AutoHotkey

#space::  <em>; Hotkey: Win+Leertaste Dr&uuml;cken, um eine InputBox f&uuml;r die Eingabe eines String anzuzeigen.</em>
InputBox, StringSenden, Text mit WM_COPYDATA senden, Beliebigen Text eingeben:
If ErrorLevel  <em>; Benutzer hat die Abbrechen-Schaltfl&auml;che gedr&uuml;ckt.</em>
    Return
Ergebnis := WM_COPYDATA_Senden(StringSenden, Empf&auml;ngertitel)
If Ergebnis = FAIL
    MsgBox SendMessage fehlgeschlagen. Existiert der folgende Fenstertitel?:`n%Empf&auml;ngertitel%
Else If Ergebnis = 0
    MsgBox Nachricht gesendet, aber das Zielfenster hat mit 0 geantwortet (es ignoriert die Nachricht).
Return

WM_COPYDATA_Senden(ByRef StringSenden, ByRef Empf&auml;ngertitel)  <em>; ByRef spart in diesem Fall ein wenig Speicherplatz.
; Diese Funktion sendet den angegebenen String an das angegebene Fenster und gibt eine Anwort zur&uuml;ck.
; Die Antwort ist 1, wenn das Zielfenster die Nachricht verarbeitet hat oder 0, wenn die Nachricht ignoriert wurde.</em>
{
    VarSetCapacity(CopyDataStruct, 3*A_PtrSize, 0)  <em>; Bestimmt den Speicherbereich der Struktur.</em>
    <em>; Zuerst wird das cbData-Element der Struktur auf die Gr&ouml;&szlig;e des Strings gesetzt, einschlie&szlig;lich dem Null-Terminator.</em>
    Gr&ouml;&szlig;eInBytes := (StrLen(StringSenden) + 1) * (A_IsUnicode ? 2 : 1)
    NumPut(Gr&ouml;&szlig;eInBytes, CopyDataStruct, A_PtrSize)  <em>; OS setzt voraus, dass das getan werden muss.</em>
    NumPut(&amp;StringSenden, CopyDataStruct, 2)  <em>; lpData zeigt auf dem String selbst.</em>
    DetectHiddenWindows_Vorher := A_DetectHiddenWindows
    TitleMatchMode_Vorher := A_TitleMatchMode
    DetectHiddenWindows On
    SetTitleMatchMode 2
    SendMessage, 0x4a, 0, &amp;CopyDataStruct,, %Empf&auml;ngertitel%  <em>; 0x4a ist WM_COPYDATA. Verwendet Send, nicht Post.</em>
    DetectHiddenWindows %DetectHiddenWindows_Vorher%  <em>; Stellt die urspr&uuml;ngliche Einstellung wieder her.</em>
    SetTitleMatchMode %TitleMatchMode_Vorher%         <em>; Das Gleiche.</em>
    Return ErrorLevel  <em>; Die Antwort von SendMessage zur&uuml;ckgeben.</em>
}</pre>
    <pre class="NoIndent"><em>; Beispiel: Siehe <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Script</a>, wie OnMessage() verwendet werden kann,
; um Meldungen zu empfangen, wenn Daten in einer Netzwerkverbindung angekommen sind.</em></pre>
  </div>
</div>
</body>
</html>