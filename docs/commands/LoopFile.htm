<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Loop (Dateien & Ordner)</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<script src="../../NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>


<h1>Loop (Dateien & Ordner)</h1>

<p>Ermittelt nacheinander die angegebenen Dateien oder Ordner.</p>

<pre class="Syntax">Loop, Dateimuster [, OrdnerEinbeziehen?, Rekursiv?] </pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Dateimuster</td>
    <td width="85%"><p>Der Name einer Datei, eines Ordners oder einer musterbasierten Suche wie C:\Temp\*.tmp. Das <em>Dateimuster</em> befindet sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist.</p>
    <p>Sowohl Sternchen als auch Fragezeichen werden als Platzhalter unterst&uuml;tzt. Eine &Uuml;bereinstimmung erfolgt, wenn das Muster mit dem langen/normalen oder <a href="#LoopFileShortName">8.3-kurzen</a> Dateinamen &uuml;bereinstimmt.</p>
    <p>Wenn dieser Parameter eine Datei oder einen Ordner enth&auml;lt (also ohne Platzhalter) und <em>Rekursiv</em> auf 1 gesetzt ist, dann werden mehrere &Uuml;bereinstimmungen gefunden, sobald der angegebene Dateiname in mehreren Ordnern vorkommt.</p></td>
  </tr>
  <tr>
    <td>OrdnerEinbeziehen?</td>
    <td><p>Eine folgende Ziffer benutzen oder leer lassen, um den Standardwert zu verwenden:<br> 0 (Standard) Ordner werden nicht ermittelt (nur Dateien).<br> 1 Alle Dateien und Ordner, die der musterbasierten Suche entsprechen, werden ermittelt.<br> 2 Nur Ordner werden ermittelt (keine Dateien).</p>    </td>
  </tr>
  <tr>
    <td>Rekursiv?</td>
    <td>Eine folgende Ziffer benutzen oder leer lassen, um den Standardwert zu verwenden:<br> 0 (Standard) Unterordner werden nicht rekursiv behandelt.<br> 1 Unterordner werden rekursiv behandelt, damit die enthaltenen Dateien und Unterordner ermittelt werden, wenn sie mit dem <em>Dateimuster</em> &uuml;bereinstimmen. Alle Unterordner werden rekursiv behandelt, nicht nur solche, die mit dem <em>Dateimuster</em> &uuml;bereinstimmen. </td>
  </tr>
</table>

<h3>Besondere Variablen innerhalb einer dateilesenden Schleife</h3>
<p>Die folgenden Variablen gibt es innerhalb jeder dateilesenden Schleife. Wenn eine innere dateilesende Schleife durch eine &auml;u&szlig;ere dateilesende Schleife eingeschlossen ist, dann hat die Datei innerhalb der Schleife Vorrang.</p>
<table class="info">
  <tr>
    <td>A_LoopFileName</td>
    <td><a name="LoopFileName" id="LoopFileName"></a>Der Name der Datei oder des Ordners, welche(r) zurzeit abgerufen wird (ohne den Pfad).</td>
  </tr>
  <tr>
    <td><a name="LoopFileExt"></a>A_LoopFileExt</td>
    <td>Die Dateierweiterung (z. B. TXT, DOC oder EXE). Der Punkt (.) ist nicht inbegriffen.</td>
  </tr>
  <tr>
    <td>A_LoopFileFullPath</td>
    <td><a name="LoopFileFullPath"></a>Der vollst&auml;ndige Pfad und Name der Datei/des Ordners, welche(r) zurzeit abgerufen wird. Wenn der <em>Dateimuster</em> allerdings einen relativen anstelle eines absoluten Pfads enth&auml;lt, dann ist dieser Pfad hier auch relativ. Dar&uuml;ber hinaus sind kurze (8.3) Ordnernamen im <em>Dateimuster</em> immer noch kurz (siehe n&auml;chsten Punkt, um die lange Version zu erhalten). </td>
  </tr>
  <tr>
    <td>A_LoopFileLongPath</td>
    <td><a name="LoopFileLongPath"></a>Diese Variable unterscheidet sich von A_LoopFileFullPath wie folgt: 1) Es enth&auml;lt immer den absoluten/kompletten Pfad der Datei, selbst wenn das <em>Dateimuster</em> einen relativen Pfad enth&auml;lt; 2) Jeder kurze (8.3) Ordnername im <em>Dateimuster</em> wird in einem langen Namen umgewandelt; 3) Zeichen im <em>Dateimuster</em> werden in Gro&szlig;- oder Kleinbuchstaben umgewandelt, damit sie mit den Zeichen im Dateisystem &uuml;bereinstimmen. Das ist f&uuml;r die Umwandlung von Dateinamen (die beispielsweise mittels Befehlszeilenparameter an das Script &uuml;bergeben werden) in ihre exakte Pfadnamen n&uuml;tzlich, wie sie vom Explorer angezeigt werden.</td>
  </tr>
  <tr>
    <td>A_LoopFileShortPath</td>
    <td><p><a name="LoopFileShortPath"></a>Der kurze Pfad (8.3) und Name der/des aktuell abgerufenen Ordners/Datei. Zum Beispiel: C:\MYDOCU~1\ADDRES~1.txt. Wenn der <em>Dateimuster</em> allerdings einen relativen anstelle eines absoluten Pfads enth&auml;lt, dann ist dieser Pfad hier auch relativ.</p>
      <p>Um den kompletten 8.3-Pfad und Namen einer Datei oder eines Ordners abzurufen, verwendet folgenden Namen im <em>Dateimuster</em>:</p>
<pre>Loop, C:\Eigene Dokumente\Address List.txt
    ShortPathName = %A_LoopFileShortPath%</pre>
        <p>HINWEIS: Diese Variable ist <strong>leer</strong>, wenn die Datei keinen kurzen Namen hat, dass in Betriebssystemen passieren kann, die NtfsDisable8dot3NameCreation in der Registrierung aktiv haben. Sie ist auch leer, wenn das Dateimuster einen relativen Pfad enth&auml;lt und der Schleifenk&ouml;rper <a href="SetWorkingDir.htm">SetWorkingDir</a> verwendet, um vom eigentlichen Arbeitsverzeichnis der Schleife selbst weg zuschalten.</p></td>
  </tr>
  <tr>
    <td>A_LoopFileShortName</td>
    <td><a name="LoopFileShortName"></a>Der 8.3-Kurzname oder alternative Name der Datei. Wenn die Datei keinen Kurznamen hat (falls der lange Name k&uuml;rzer als der 8.3-Name ist oder die Kurznamengenerierung auf einem NTFS-Dateisystem deaktiviert ist), dann wird stattdessen <em>A_LoopFileName</em> abgerufen. </td>
  </tr>
  <tr>
    <td>A_LoopFileDir</td>
    <td><a name="LoopFileDir"></a>Der vollst&auml;ndige Pfad des Verzeichnisses, in der sich <em>A_LoopFileName</em> befindet. Wenn der <em>Dateimuster</em> allerdings einen relativen anstelle eines absoluten Pfads enth&auml;lt, dann ist dieser Pfad hier auch relativ. Ein Hauptverzeichnis wird keinen nachfolgenden Backslash enthalten. Zum Beispiel: C:</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeModified</td>
    <td><a name="LoopFileTimeModified"></a>Wann die Datei bearbeitet wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeCreated</td>
    <td><a name="LoopFileTimeCreated"></a>Wann die Datei erstellt wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeAccessed</td>
    <td><a name="LoopFileTimeAccessed"></a>Wann die Datei aufgerufen wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileAttrib</td>
    <td><a name="LoopFileAttrib"></a>Die <a href="FileGetAttrib.htm">Attribute</a> der Datei, welche zurzeit abgerufen wird.</td>
  </tr>
  <tr>
    <td>A_LoopFileSize</td>
    <td><a name="LoopFileSize"></a>Die Byte-Gr&ouml;&szlig;e der Datei, welche zurzeit abgerufen wird. Dateien gr&ouml;&szlig;er als 4 Gigabyte werden ebenfalls unterst&uuml;tzt.</td>
  </tr>
  <tr>
    <td>A_LoopFileSizeKB</td>
    <td><a name="LoopFileSizeKB"></a>Die KB-Gr&ouml;&szlig;e der Datei, welche zurzeit abgerufen wird, abgerundet auf dem n&auml;chsten Integer-Wert. </td>
  </tr>
  <tr>
    <td>A_LoopFileSizeMB</td>
    <td><a name="LoopFileSizeMB"></a>Die MB-Gr&ouml;&szlig;e der Datei, welche zurzeit abgerufen wird, abgerundet auf dem n&auml;chsten Integer-Wert. </td>
  </tr>
</table>
<h3>Bemerkungen</h3>
<p>Eine dateilesende Schleife ist n&uuml;tzlich, wenn der Benutzer eine Sammlung von Dateien und/oder Ordner bearbeiten will.</p>
<p>Alle &uuml;bereinstimmenden Dateien werden ermittelt, einschlie&szlig;lich versteckte Dateien. OS-Funktionen wie der DIR-Befehl lassen hingegen versteckte Dateien standardm&auml;&szlig;ig weg. Um die Bearbeitung von versteckten, schreibgesch&uuml;tzten und/oder System-Dateien zu vermeiden, verwendet beispielsweise Folgendes in der Schleife:</p>
<pre>If A_LoopFileAttrib contains H,R,S  <em>; Jede Datei &uuml;berspringen, die H (versteckt), R (schreibgesch&uuml;tzt) oder S (vom System) ist. Hinweis: Keine Leerzeichen in "H,R,S".</em>
    continue  <em>; Diese Datei &uuml;berspringen und zur N&auml;chsten gehen</em></pre>
<p>Um die relativen anstelle der absoluten Pfade von Dateien w&auml;hrend einer rekursiven Suche zu ermitteln, &auml;ndert mit <a href="SetWorkingDir.htm">SetWorkingDir</a> den Grundordner vor der Schleife und lasst dann den Pfad in der Schleife weg (z. B. Loop, *.*, 0, 1). Dadurch enth&auml;lt <a href="#LoopFileFullPath">A_LoopFileFullPath</a> den relativen Pfad im Grundordner der Datei.</p>
<p>Eine dateilesende Schleife kann sich selbst unterbrechen, wenn sie Dateien oder Ordner innerhalb der eigenen Zust&auml;ndigkeit erstellt oder umbenennt. Wenn sie zum Beispiel Dateien mittels <a href="FileMove.htm">FileMove</a> umbenennt, dann wird jede dieser Datei zweimal gefunden: einmal mit dem alten Namen und nochmal mit dem neuen Namen. Als &Uuml;bergangsl&ouml;sung sollten die Dateien nur umbenannt werden, nachdem eine Liste von ihnen erstellt wurde. Zum Beispiel:</p>
<pre>Dateiliste =
Loop *.jpg
   Dateiliste = %Dateiliste%%A_LoopFileName%`n
Loop, parse, Dateiliste, `n
   FileMove, %A_LoopField%, unbenannt_%A_LoopField%</pre>
<p>Dateien in einem NTFS-Dateisystem werden wahrscheinlich immer in alphabetischer Reihenfolge abgerufen. Dateien in anderen Dateisystemen werden in keiner bestimmten Reihenfolge abgerufen. Um eine bestimmte Reihenfolge sicherzustellen, verwendet den Befehl <a href="Sort.htm">Sort</a>, wie unten im Abschnitt "Beispiele" gezeigt.</p>
<p>Dateien und Ordner mit einem kompletten Pfad l&auml;nger als 259 Zeichen werden ignoriert, als w&uuml;rde sie nicht existieren. Solche Dateien sind selten, weil normalerweise das Betriebssystem das Erstellen solcher Dateien verbietet.</p>
<p>Siehe <a href="Loop.htm">Loop</a> f&uuml;r Informationen &uuml;ber <a href="Block.htm">Blocks</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index (die gibt es in jeder Schleifenvariante).</p>
<h3>Verwandte Befehle</h3>
<p><a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blocks</a>, <a href="SplitPath.htm">SplitPath</a>, <a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel #1:</em>
Loop, %A_ProgramFiles%\*.txt, , 1  <em>; Rekursiv in Unterordner.</em>
{
    MsgBox, 4, , Dateiname = %A_LoopFileFullPath%`n`nFortfahren?
    IfMsgBox, No
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Berechnet die Gr&ouml;&szlig;e des Ordners, einschlie&szlig;lich seine Dateien und Unterordner:</em>
SetBatchLines, -1  <em>; F&uuml;hrt die Operation mit maximaler Geschwindigkeit aus.</em>
OrdnerGr&ouml;&szlig;eKB = 0
FileSelectFolder, Ordner  <em>; Fordert den Benutzer auf, einen Ordner auszuw&auml;hlen.</em>
Loop, %Ordner%\*.*, , 1
    OrdnerGr&ouml;&szlig;eKB += %A_LoopFileSizeKB%
MsgBox Der Ordner %Ordner% hat eine Gr&ouml;&szlig;e von %OrdnerGr&ouml;&szlig;eKB% KB.</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Ruft Dateinamen ab, die nach Namen sortiert sind (siehe n&auml;chstes Beispiel, um nach Datum zu sortieren):</em>
Dateiliste =  <em>; Leere Variable initialisieren.</em>
Loop, C:\*.*
    Dateiliste = %Dateiliste%%A_LoopFileName%`n
Sort, Dateiliste, R  <em>; Die R-Option sortiert in umgekehrter Richtung. Siehe <a href="Sort.htm">Sort</a> f&uuml;r andere Optionen.</em>
Loop, parse, Dateiliste, `n
{
    If A_LoopField =  <em>; Ignoriert das leere Element am Ende der Liste.</em>
        continue
    MsgBox, 4,, Dateinummer %A_Index% ist %A_LoopField%.  Weiter?
    IfMsgBox, No
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #4: Ruft Dateinamen ab, die nach Erstellungsdatum sortiert sind:</em>
Dateiliste =
Loop, %A_MyDocuments%\Fotos\*.*, 1
    Dateiliste = %Dateiliste%%A_LoopFileTimeModified%`t%A_LoopFileName%`n
Sort, Dateiliste  <em>; Nach Datum sortieren.</em>
Loop, parse, Dateiliste, `n
{
    If A_LoopField =  <em>; L&auml;sst das letzte LF-Zeichen (leeres Element) am Ende der Liste weg.</em>
        continue
    StringSplit, Dateielement, A_LoopField, %A_Tab%  <em>; In zwei Teile aufteilen.</em>
    MsgBox, 4,, Die n&auml;chste Datei ist (modifiziert am %Dateielement1%):`n%Dateielement2%`n`nWeiter?
    IfMsgBox, No
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #5: Kopiert nur Quelldateien ins Ziel, die neuer als ihr Gegenst&uuml;ck sind:</em>
KopierenWennNeuer:
<em>; Die Variablen KopieQuellmuster und KopieZiel wurden vorher gesetzt.</em>
Loop, %KopieQuellmuster%
{
    kopieren = n
    IfNotExist, %KopieZiel%\%A_LoopFileName%  <em>; Immer kopieren, wenn die Zieldatei noch nicht existiert.</em>
        kopieren = y
    Else
    {
        FileGetTime, Zeitstempel, %KopieZiel%\%A_LoopFileName%
        EnvSub, Zeitstempel, %A_LoopFileTimeModified%, seconds  <em>; Subtrahiert die Zeit der Quelldatei mit der Zeit der Zieldatei.</em>
        If Zeitstempel &lt; 0  <em>; Quelldatei ist neuer als Zieldatei.</em>
            kopieren = y
    }
    If kopieren = y
    {
        FileCopy, %A_LoopFileFullPath%, %KopieZiel%\%A_LoopFileName%, 1   <em>; Kopieren und &uuml;berschreiben.</em>
        If ErrorLevel
            MsgBox, "%A_LoopFileFullPath%" konnte nicht nach "%KopieZiel%\%A_LoopFileName%" kopiert werden.
    }
}
Return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #6: Konvertiert Dateinamen, die mittels Kommandozeilen-Parameter &uuml;bergeben wurden, in lange Namen,
; vervollst&auml;ndigt den Pfad und korrigiert die Gro&szlig;- und Kleinbuchstaben, wie sie im Dateisystem gespeichert sind.</em>
Loop %0%  <em>; F&uuml;r jede Datei, die auf das Script abgelegt wurde (oder als Parameter &uuml;bergeben wurde).</em>
{
    Pfadangabe := %A_Index%  <em>; Ermittelt den n&auml;chsten Befehlszeilenparameter.</em>
    Loop %Pfadangabe%, 1
        LangerPfad = %A_LoopFileLongPath%
    MsgBox Der zeichengenaue lange Pfadname der Datei `n%Pfadangabe%`n ist:`n%LangerPfad%
}</pre>

</body>
</html>