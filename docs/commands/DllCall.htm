<!DOCTYPE HTML>
<html>
<head>
<title>DllCall</title>
<meta name="keywords" content="Befehl, Funktion, Interoperabilit&auml;t">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>DllCall()</h1>
      <p>Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</p>
      <pre class="Syntax">Ergebnis := DllCall("[DllDatei\]Funktion" [, Typ1, Arg1, Typ2, Arg2, "Cdecl R&uuml;ckgabetyp"])</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Ergebnis</td>
          <td style="width: 85%;">DllCall gibt den aktuellen R&uuml;ckgabewert der Funktion zur&uuml;ck. Unterst&uuml;tzt die Funktion keinen R&uuml;ckgabewert, &uuml;bergibt sie einen undefinierten Integer-Wert. Wenn die Funktion durch einen <a href="#error">Fehler</a> nicht aufgerufen werden kann, ist der R&uuml;ckgabewert leer (ein leerer String).</td>
        </tr>
        <tr>
          <td>[DllDatei\]Funktion</td>
          <td><p>Der Name einer DLL- oder EXE-Datei gefolgt von einem Backslash und dem Funktionsnamen. Zum Beispiel: "EigeneDLL\EigeneFunktion" (die Dateierweiterung ".dll" kann standardm&auml;&szlig;ig weggelassen werden). Solange kein absoluter Pfad angegeben ist, befindet sich die <em>DllDatei</em> im System- oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Pfad.</p>
            <p><em id="std">DllDatei</em> kann weggelassen werden, wenn eine Funktion in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll aufgerufen wird. Zum Beispiel liefert "User32\IsWindowVisible" das gleiche Ergebnis wie "IsWindowVisible".</p>
            <p>Sobald keine Funktion gefunden wird, wird nach dem angegebenen Namen automatisch ein A (ANSI) oder W (Unicode) angef&uuml;gt, abh&auml;ngig davon, welche AutoHotkey-Version zurzeit l&auml;uft. Zum Beispiel ist "MessageBox" in ANSI-Versionen das gleiche wie "MessageBoxA" und in Unicode-Versionen das gleiche wie "MessageBoxW".<br>
            </p>
            <p>Die Performance kann bei <em>wiederholenden</em> Funktionsaufrufen erheblich verbessert werden, wenn die DLL <a href="#load">vorher geladen</a> wird.</p>
            <p>Seit v1.0.46.08 kann dieser Parameter auch einen Integer-Wert enthalten, der als Adresse der Funktion interpretiert wird. Quellen f&uuml;r solche Adressen sind <a href="#COM">COM</a> und <a href="RegisterCallback.htm">RegisterCallBack()</a>.</p></td>
        </tr>
        <tr>
          <td>Typ1, Arg1</td>
          <td>Dieses Paar stellt einen Parameter dar, der an die Funktion &uuml;bergeben wird. Die Anzahl an m&ouml;glichen Paaren ist unbegrenzt. F&uuml;r <em>Typ</em> kann die <a href="#types">Typentabelle</a> eingesehen werden. F&uuml;r <em>Arg</em> kann der zu &uuml;bergebende Wert angegeben werden.</td>
        </tr>
        <tr>
          <td>Cdecl R&uuml;ckgabetyp</td>
          <td><p id="cdecl">Das Wort <em>Cdecl</em> kann normalerweise weggelassen werden, weil die meisten Funktionen eher die Standard-Aufrufkonvention verwenden, als die C-Aufrufkonvention (Funktionen wie wsprintf, die eine unterschiedliche Anzahl an Argumenten akzeptieren, bilden solch eine Ausnahme). Wenn Cdecl weggelassen wird und <a href="#An">ErrorLevel A<strong>n</strong></a> enth&auml;lt (<strong>n</strong> ist die Gesamtgr&ouml;&szlig;e an &uuml;bergebenden Argumenten), wird <em>Cdecl</em> m&ouml;glicherweise ben&ouml;tigt. Beachtet, dass die meisten objektorientierten C++-Funktionen die <i>thiscall</i>-Konvention verwenden, welche nicht unterst&uuml;tzt wird.</p>
            <p>Falls vorhanden, sollte das Wort <em>Cdecl</em> vor dem R&uuml;ckgabetyp (falls vorhanden) stehen. Dabei muss jedes Wort mit einem Leer- oder Tabulatorzeichen getrennt werden. Zum Beispiel: "Cdecl Str"</p>
            <p><span class="ver">[AHK_L 53+]:</span> Da eine seperate C-Aufrufkonvention im 64-Bit-Code nicht zur Verf&uuml;gung steht, hat <i>Cdecl</i> in der 64-Bit-Version von AutoHotkey keine Wirkung.</p>
            <p><em>R&uuml;ckgabetyp</em>: Wenn die Funktion einen vorzeichenbehafteten 32-Bit-Integer (Int), BOOL oder nichts zur&uuml;ckgibt, kann <em>R&uuml;ckgabetyp</em> weggelassen werden. Ansonsten kann ein Argumenttyp aus der <a href="#types">Typentabelle</a> verwendet werden. Das <a href="#asterisk">Sternchen-Suffix</a> wird ebenfalls unterst&uuml;tzt.</p></td>
        </tr>
      </table>
      <h3 id="types">Argumenttypen und R&uuml;ckgabewerte</h3>
      <table class="info">
        <tr>
          <td>Str</td>
          <td><p id="str">Ein String wie "Blau" oder EigeneVar. Wenn die aufgerufene Funktion den String &auml;ndert und das Argument eine reine Variable ist, wird deren Inhalt aktualisiert. Zum Beispiel w&uuml;rde der folgende Aufruf den Inhalt von <em>EigeneVar</em> in Gro&szlig;buchstaben umwandeln: <code>DllCall("CharUpper", "Str", <i>EigeneVar</i>)</code></p>
            <p>Wenn die Funktion allerdings in der Lage ist, einen String gr&ouml;&szlig;er als die aktuelle Variablenkapazit&auml;t zu speichern, muss sichergestellt werden, dass die Variable vor dem Funktionsaufruf gro&szlig; genug ist. Das wird erreicht, indem <a href="VarSetCapacity.htm">VarSetCapacity(<em>EigeneVar</em>, 123)</a> aufgerufen wird, wobei 123 die neue L&auml;nge von <em>EigeneVar</em> ist.</p>
            <p>Ein <em>Str</em>-Argument darf kein <a href="../Variables.htm#Expressions">Ausdruck</a> sein, die eine Zahl berechnet (z. B. i+1). In diesem Fall wird die Funktion nicht aufgerufen und ErrorLevel auf -2 gesetzt.</p>
            <p>Die <a href="#asterisk">Sternchenvariable</a> "Str*" wird unterst&uuml;tzt, aber selten verwendet. Sie kann bei Funktionen verwendet werden, die so etwas erwarten wie "TCHAR **" oder "LPTSTR *".</p>
            <p>Hinweis: Bei der &Uuml;bergabe eines Strings an eine Funktion muss klar sein, welchen <a href="../Compat.htm#DllCall">String-<i>Typ</i></a> die Funktion erwartet.</p></td>
        </tr>
        <tr id="astr">
          <td id="wstr">AStr<br>
            WStr</td>
          <td><span class="ver">[AHK_L 42+]:</span> Ein <b>A</b>NSI- oder Unicode-String (<b>W</b>ide character). Siehe <a href="../Compat.htm#DllCall">Script-Kompatibilit&auml;t</a> f&uuml;r gleichwertige Win32-Typen und weitere Details.</td>
        </tr>
        <tr>
          <td>Int64</td>
          <td>Ein 64-Bit-Integer im Bereich von  -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</td>
        </tr>
        <tr>
          <td>Int</td>
          <td id="Int"><p>Ein 32-Bit-Integer (meistgenutzter Integer-Typ) im Bereich von -2147483648 (-0x80000000) bis 2147483647 (0x7FFFFFFF). Int wird manchmal auch als "Long" bezeichnet.</p>
            <p>Int sollte auch f&uuml;r jedes BOOL-Argument verwendet werden (ein BOOL-Wert enth&auml;lt entweder eine 1 oder 0).</p>
            <p>Ein <a href="#unsigned">vorzeichenloser</a> (unsigned) Integer (UInt) wird auch ziemlich oft genutzt, z. B. f&uuml;r DWORD.</p></td>
        </tr>
        <tr>
          <td>Short</td>
          <td>Ein 16-Bit-Integer im Bereich von -32768 (-0x8000) bis 32767 (0x7FFF). Ein <a href="#unsigned">vorzeichenloser</a> 16-Bit-Integer (UShort) kann bei Funktionen verwendet werden, die DWORD erwarten.</td>
        </tr>
        <tr>
          <td>Char</td>
          <td>Ein 8-Bit-Integer im Bereich von -128 (-0x80) bis 127 (0x7F). Ein <a href="#unsigned">vorzeichenloser</a> 8-Bit-Integer (UChar) kann bei Funktionen verwendet werden, die BYTE erwarten.</td>
        </tr>
        <tr>
          <td>Float</td>
          <td>Eine 32-Bit-Flie&szlig;kommazahl mit maximal 6 Stellen nach dem Komma. </td>
        </tr>
        <tr>
          <td>Double</td>
          <td>Eine 64-Bit-Flie&szlig;kommazahl mit maximal 15 Stellen nach dem Komma. </td>
        </tr>
        <tr>
          <td>Ptr</td>
          <td id="ptr"><p><span class="ver">[AHK_L 42+]:</span> Ein Integer in <a href="../Variables.htm#PtrSize">Pointergr&ouml;&szlig;e</a>, das das gleiche wie Int oder Int64 ist, abh&auml;ngig davon, ob die EXE-Datei, die das Script ausf&uuml;hrt, 32- oder 64-Bit ist. <i>Ptr</i> gilt f&uuml;r Pointer, die auf Arrays oder Strukturen (wie RECT* oder LPPOINT) verweisen, und f&uuml;r fast alle Handles (wie HWND, HBRUSH oder HBITMAP). Falls der Parameter ein Pointer ist, der auf einen einzelnen numerischen Wert wie LPDWORD oder int* verweist, sollte generell der Suffix * oder P anstelle von "Ptr" verwendet werden.</p>
            <p><i>Ptr</i> kann auch mit dem Suffix * oder P verwendet werden; es sollte mit Funktionen verwendet werden, die einen Pointer per LPVOID* oder &Auml;hnliches zur&uuml;ckgeben.</p>
            <p><i>UPTR</i> ist auch g&uuml;ltig, das aber nur in 32-Bit-Versionen vorzeichenlos ist, da AutoHotkey vorzeichenlose 64-Bit-Integer nicht unterst&uuml;tzt.</p>
            <p>Wenn die Kompatibilit&auml;t mit &auml;lteren Versionen von AutoHotkey erforderlich ist, kann ein Variablentyp wie folgt verwendet werden:</p>
            <pre>Ptr := A_PtrSize ? "Ptr" : "UInt" <em>; Wenn A_PtrSize nicht definiert ist, gilt stattdessen UInt.</em>
DllCall("DeleteFile", Ptr, &amp;Dateiname) <em>; Lasst die Anf&uuml;hrungszeichen bei Ptr weg.</em></pre>
            <p>Hinweis: Zum &Uuml;bergeben eines <strong>NULL</strong>-Handles oder -Pointers muss der Integer 0 verwendet werden.</p></td>
        </tr>
        <tr>
          <td>* oder P<br>
            (Suffix) </td>
          <td id="asterisk"><p>Ein Sternchen (optional mit einem Leerzeichen davor), das an einen beliebigen oben genannten Typ angef&uuml;gt wird, bewirkt, dass die Adresse des Arguments &uuml;bergeben wird, anstatt der Wert selbst (die aufgerufene Funktion muss dazu in der Lage sein, so etwas zu akzeptieren). Da sich der Wert eines solchen Arguments durch die Funktion &auml;ndern kann, w&auml;hrend eine reine Variable als Argument &uuml;bergeben wird, wird der Inhalt dieser Variable aktualisiert. Zum Beispiel w&uuml;rde der folgende Aufruf den Inhalt von EigeneVar per Adresse an EigeneFunktion &uuml;bergeben, aber auch EigeneVar aktualisieren, um &Auml;nderung an ihr durch EigeneFunktion widerzuspiegeln: DllCall("EigeneDLL\EigeneFunktion", "Int*", EigeneVar)</p>
            <p>In der Regel wird ein Sternchen verwendet, sobald eine Funktion ein Argumenttyp oder R&uuml;ckgabetyp hat, der mit "LP" beginnt. Das bekannteste Beispiel daf&uuml;r ist LPDWORD, das ein Pointer auf DWORD ist. Da DWORD ein vorzeichenloser 32-Bit-Integer ist, sollte f&uuml;r LPDWORD stattdessen "UInt*" oder "UintP" verwendet werden. Das Sternchen sollte nicht bei Stringtypen wie LPTSTR, Pointer auf Strukturen (z. B. LPRECT) oder Arrays verwendet werden; f&uuml;r diese sollte eher <a href="#str">"Str"</a> oder "Ptr" verwendet werden, abh&auml;ngig davon, ob du eine Variable oder deren Adresse &uuml;bergibst.</p>
            <p>Hinweis: "Char*" ist nicht das gleiche wie <a href="#str">"Str"</a>, weil "Char*" die Adresse einer 8-Bit-Zahl &uuml;bergibt, w&auml;hrend <a href="#str">"Str"</a> die Adresse einer Reihe von Zeichen &uuml;bergibt, die je nach AutoHotkey-Version 8-Bit (ANSI) oder 16-Bit (Unicode) gro&szlig; sind. Ebenso &uuml;bergibt "UInt*" die Adresse einer 32-Bit-Zahl, daher sollte das nicht verwendet werden, wenn die Funktion ein Array mit Werten oder eine Struktur gr&ouml;&szlig;er als 32 Bit erwartet.</p>
            <p>Da die Variablen in AutoHotkey keinen festen Typ haben, verweist die Adresse, die an die Funktion &uuml;bergeben wurde, auf einen tempor&auml;ren Speicher, anstatt auf die Variable selbst. Es ist nicht notwendig, <a href="VarSetCapacity.htm">VarSetCapacity</a> f&uuml;r die Variable aufzurufen, weil sie von DllCall korrekt aktualisiert wird, sobald die Funktion durchgef&uuml;hrt wurde.</p></td>
        </tr>
        <tr>
          <td>U (Pr&auml;fix)</td>
          <td><p id="unsigned">Setzt den Buchstaben vor einem der oberen Integer-Typen, damit dieser als vorzeichenloser Integer (UInt64, Uint, UShort und UChar) interpretiert wird. Streng genommen ist das nur f&uuml;r R&uuml;ckgabewerte und <a href="#asterisk">Sternchenvariablen</a> notwendig, da es keine Rolle spielt, ob ein Argument, der als Wert &uuml;bergeben wurde, vorzeichenbehaftet oder vorzeichenlos ist (au&szlig;er f&uuml;r Int64).</p>
            <p>Wenn ein negativer Integer f&uuml;r ein vorzeichenloses Argument angegeben wurde, wechselt der Integer in den vorzeichenlosen Bereich. Wenn zum Beispiel -1 als UInt gesendet wird, w&uuml;rde diese zu 0xFFFFFFFF werden.</p>
            <p><em>Vorzeichenlose</em> 64-Bit-Integer, die per Funktion erzeugt wurden, werden nicht unterst&uuml;tzt. Um deshalb mit Zahlen gr&ouml;&szlig;er gleich 0x8000000000000000 zu arbeiten, muss das U-Pr&auml;fix weggelassen und alle negativen Werte, die von der Funktion stammen, als gro&szlig;e Integer interpretiert werden. Zum Beispiel wird eine Funktion, die -1 als Int64 zur&uuml;ckgibt, in Wirklichkeit 0xFFFFFFFFFFFFFFFF als UInt64 zur&uuml;ckgeben, wenn sie dazu in der Lage ist.</p></td>
        </tr>
      </table>
      <p><strong>Hinweis</strong>: Wenn die Argument- oder R&uuml;ckgabetypen ohne Leerzeichen oder Sternchen angegeben werden, k&ouml;nnen die Anf&uuml;hrungszeichen weggelassen werden. Zum Beispiel ist es m&ouml;glich, Str anstelle von "Str" und CDecl anstelle von "CDecl" zu verwenden. Dar&uuml;ber hinaus kann f&uuml;r den Buchstaben P auch ein Sternchen verwendet werden, damit auch dort die Anf&uuml;hrungszeichen weggelassen werden k&ouml;nnen. Zum Beispiel: UIntP.</p>
      <h3 id="error">ErrorLevel</h3>
      <p><span class="ver">[v1.1.04+]</span> Diese Funktion ist in der Lage, bei Misserfolg eine Ausnahme auszul&ouml;sen. F&uuml;r mehr Informationen, siehe <a href="Catch.htm#RuntimeErrors">Laufzeitfehler</a>.</p>
      <p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> wird auf einen der folgenden Werte gesetzt, um den Erfolg oder Misserfolg des Aufrufs zu kennzeichnen.</p>
      <p><strong>0</strong>: Erfolgreich.</p>
      <p><strong>-1</strong>: Der <em>[DllDatei\]Funktion</em>-Parameter ist eine Flie&szlig;kommazahl. Es wird ein String oder ein positiver Integer ben&ouml;tigt.</p>
      <p><strong>-2</strong>: Der <a href="#types">R&uuml;ckgabetyp</a> oder einer der angegebenen <a href="#types">Argumenttypen</a> ist ung&uuml;ltig. Dieser Fehler kann auch auftreten, wenn ein <a href="../Variables.htm#Expressions">Ausdruck</a>, der eine Zahl errechnet, an ein String (<a href="#str">Str</a>) &uuml;bergeben wird.</p>
      <p><strong>-3</strong>: Die angegebene <em>DllDatei</em> ist nicht zugreifbar. Falls deren Pfad nicht ausdr&uuml;cklich angegeben wurde, muss sich die Datei im System- oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Pfad befinden. Dieser Fehler kann auch auftreten, wenn dem Benutzer die n&ouml;tigen Rechte fehlen, auf die Datei zu zugreifen.</p>
      <p><strong>-4</strong>: Die angegebene Funktion konnte innerhalb der DLL nicht gefunden werden.</p>
      <p><strong>N</strong> (beliebige positive Nummer): Der Aufruf der Funktion war erfolgreich, allerdings wurde diese mit dem schweren Ausnahmefehler Nummer <strong>N</strong> abgebrochen (z. B. 0xC0000005 bedeutet "Zugriffsverletzung"). In solchen F&auml;llen gibt die Funktion einen leeren String zur&uuml;ck, aber alle <a href="#asterisk">Sternchenvariablen</a> werden weiter aktualisiert. Zum Beispiel ist ein schwerer Ausnahmefehler die Dereferenzierung eines ung&uuml;ltigen Pointers, wie z. B. NULL. Da eine <a href="#cdecl">Cdecl</a>-Funktion nie einen <em>"An"</em>-Fehler aus dem n&auml;chsten Abschnitt erzeugen kann, k&ouml;nnte ein Ausnahmefehler auftreten, wenn zu wenig Argumente an diese Funktion &uuml;bergeben werden.</p>
      <p id="An"><strong>An</strong> (Buchstabe A, gefolgt von einem Integer <strong>n</strong>): Der Aufruf der Funktion war erfolgreich, allerdings wurden zu viel oder zu wenig Argumente &uuml;bergeben. "<strong>n</strong>" ist dabei die Anzahl an Bytes, mit denen die Argumentenliste falsch war. Ist <strong>n</strong> positiv, wurden zu viele Argumente (oder zu lange Argumente) &uuml;bergeben, oder der Aufruf erfordert <a href="#cdecl">CDecl</a>. Ist <strong>n</strong> negativ, wurden zu wenige Argumente &uuml;bergeben. Dieses Problem sollte behoben werden, um sicherzustellen, dass die Funktion richtig l&auml;uft. So ein Fehler k&ouml;nnten auch darauf hindeuten, dass ein Ausnahmefehler aufgetreten ist, in diesem Fall gibt die Funktion einen leeren Wert zur&uuml;ck. Beachte, dass 64-Bit-Versionen den ErrorLevel aufgrund der x64-Aufrufkonvention nie auf <b>An</b> setzen.</p>
      <h3 id="except">Ausnahmen und A_LastError</h3>
      <p>Trotz interner Ausnahmebehandlung ist es m&ouml;glich, dass ein Script mit DllCall abst&uuml;rzt. Das kann passieren, wenn eine Funktion nicht direkt ein Ausnahmefehler erzeugt, sondern etwas Unangebrachtes zur&uuml;ckgibt, wie z. B. ein schlechter Pointer oder ein nicht-terminierter String. Die Funktion ist nicht unbedingt daran Schuld, wenn das Script ihr einen ungeeigneten Wert &uuml;bergibt, wie z. B. einen schlechten Pointer oder ein <a href="#str">String</a> mit unzureichender Kapazit&auml;t. Ein Script kann auch abst&uuml;rzen, wenn ein ungeeigneter Argument- oder R&uuml;ckgabetyp angegeben wird, z.B. mit der Behauptung, dass ein gew&ouml;hnlicher Integer, der von einer Funktion zur&uuml;ckgegeben wurde, eine <a href="#asterisk">Sternchenvariable</a> oder ein <a href="#str">String</a> ist.</p>
      <p id="LastError">Die interne Variable <strong>A_LastError</strong> enth&auml;lt den R&uuml;ckgabewert der Systemfunktion GetLastError(), die sofort nach einem Funktionsaufruf aufgerufen wird (hat keine messbaren Auswirkungen auf die Performance). A_LastError enth&auml;lt eine Nummer zwischen 0 und 4294967295 (immer als Dezimalzahl). Wie bei <a href="../misc/ErrorLevel.htm">ErrorLevel</a> gilt A_LastError jeweils nur f&uuml;r einen Thread, das hei&szlig;t, dass Unterbrechungen durch andere <a href="../misc/Threads.htm">Threads</a> den Wert nicht &auml;ndern k&ouml;nnen. Allerdings wird A_LastError auch von <a href="Run.htm#LastError">Run/RunWait</a> ge&auml;ndert.</p>
      <h3 id="load">Performance</h3>
      <p>Die Performance kann bei mehrfachen Aufrufen einer DLL deutlich verbessert werden, indem sie direkt geladen wird (<em>das ist nicht f&uuml;r eine <a href="#std">Standard-DLL</a> wie User32 notwendig, weil diese dauerhaft im Arbeitsspeicher vorhanden ist</em>). Dadurch wird verhindert, dass f&uuml;r DllCall jedesmal LoadLibrary und FreeLibrary intern aufgerufen werden muss. Zum Beispiel:</p>
      <pre>hModule := DllCall("<strong>LoadLibrary</strong>", "Str", "EigeneFunktionen.dll", "Ptr")  <em>; Verhindert, dass DllCall() die Bibliothek in der Schleife laden muss.</em>
Loop, C:\Eigene Dokumente\*.*, , 1
    Ergebnis := DllCall("EigeneFunktionen\BackupFile", "Str", A_LoopFileFullPath)
DllCall("<strong>FreeLibrary</strong>", "Ptr", hModule)  <em>; Der DLL-Speicher wird freigeben.</em></pre>
      <p>Seit v1.0.46.08 kann eine noch schnellere Performance erreicht werden, wenn vorher die Adresse der Funktion ermittelt wird. Zum Beispiel:</p>
      <pre><em>; Wenn im folgenden Beispiel die DLL noch nicht geladen wurde, sollte LoadLibrary anstelle von GetModuleHandle verwenden werden.</em>
<strong>MulDivProc</strong> := DllCall("GetProcAddress", Ptr, DllCall("GetModuleHandle", Str, "<strong>kernel32</strong>", "Ptr"), AStr, "<strong>MulDiv</strong>", "Ptr")
Loop 500
    DllCall(<strong>MulDivProc</strong>, Int, 3, Int, 4, Int, 3)</pre>
      <p><span class="ver">[AHK_L 31+]:</span> Wenn der erste Parameter von DllCall ein direkter String wie <code>"MulDiv"</code> ist und die DLL mit der Funktion normal vor dem Scriptstart geladen wurde, wird der String automatisch in eine Funktionsadresse aufgel&ouml;st. Diese interne Optimierung ist effektiver als das oben gezeigte Beispiel.</p>
      <p>Auch das Hinzuf&uuml;gen von <a href="_NoEnv.htm">#NoEnv</a> irgendwo im Script verbessert die Performance, wenn Parametertypen ohne Anf&uuml;hrungszeichen verwendet werden (z. B. Int vs. "Int").</p>
      <p>Falls eine Stringvariable an eine Funktion &uuml;bergeben wird, bei der sich die L&auml;nge des Strings nicht &auml;ndert, kann die Performance verbessert werden, indem die Variable <a href="../Variables.htm#amp">per Adresse</a> &uuml;bergeben wird (z. B. &amp;EigeneVar) anstatt als "<a href="#str">str</a>" (besonders, wenn der String sehr lang ist). Das folgende Beispiel wandelt einen String in Gro&szlig;buchstaben um: <code>DllCall("CharUpper", <strong>Ptr</strong>, <em><strong>&amp;</strong>EigeneVar</em>, Ptr)</code>.</p>
      <h3 id="struct">Strukturen und Arrays</h3>
      <p>Eine Struktur ist eine Sammlung von <em>Elementen</em> (Feldern), die nebeneinander gespeichert sind. Die meisten Elemente sind Integer.</p>
      <p>Funktionen, die die Adresse einer Struktur (oder eines Speicher-Block-Arrays) akzeptieren, k&ouml;nnen aufgerufen werden, indem die bin&auml;ren Rohdaten der Struktur in eine normale Variable gespeichert werden. Die folgenden Schritte werden in der Regel durchgef&uuml;hrt:</p>
      <ol>
        <li><code><a href="VarSetCapacity.htm">VarSetCapacity</a>(EigeneStruktur, 123, 0)</code> aufrufen, um sicherzustellen, dass der Speicherumfang der Zielvariable gro&szlig; genug f&uuml;r die Struktur ist. Ersetze 123 mit einer Zahl, die mindestens so gro&szlig; wie die Strukturgr&ouml;&szlig;e ist. Die Null im letzten Parameter ist optional; dieser veranlasst, dass alle Elemente bin&auml;re Nullen sind, dadurch muss NumPut() nicht so oft im n&auml;chsten Schritt aufgerufen werden.</li>
        <li>Wenn die Zielfunktion die Werte anfangs in der Struktur verwendet, muss <code><a href="../Functions.htm#NumPut">NumPut</a>(123, EigeneStruktur, 4, "UInt")</code> aufgerufen werden, um jedes Element zu initialisieren, das ungleich 0 sein soll. Ersetze 123 mit einem Integer, um diesen in das Zielelement einzuf&uuml;gen (oder verwendet <code>&amp;Var</code>, um die <a href="../Variables.htm#amp">Adresse</a> einer Variable zu speichern). Ersetze 4 mit dem Offset des Zielelements (siehe Schritt #4, was ein "Offset" ist). Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</li>
        <li>Rufe die Zielfunktion auf, indem die <a href="../Variables.htm#amp">Adresse</a> von EigeneStruktur als UInt-Argument (oder seit AHK_L 42 als Ptr-Argument) &uuml;bergeben wird. Zum Beispiel: <code>DllCall("EigeneDLL\EigeneFunktion", Ptr, <strong>&amp;</strong>EigeneStruktur)</code>. Die Funktion wird einige Elemente &uuml;berpr&uuml;fen und/oder &auml;ndern.</li>
        <li>Verwende <code>EigeneInteger := <a href="../Functions.htm#NumGet">NumGet</a>(EigeneStruktur, 4, "UInt")</code>, um beliebige Integer von der Struktur abzurufen. Ersetze 4 mit dem Offset des Zielelements in der Struktur. Das erste Element ist immer bei Offset 0. Das zweite Element ist bei Offset 0 plus die Gr&ouml;&szlig;e des ersten Elements (in der Regel 4). Elemente nach dem zweiten sind bei dem Offset des vorherigen Feldes plus die Gr&ouml;&szlig;e des vorherigen Feldes. Die meisten Elemente wie DWORD, INT und <a href="#Int">andere Typen von 32-Bit-Integer</a> haben eine Gr&ouml;&szlig;e von 4 Bytes. Ersetze "UInt" mit dem geeigneten Typ oder lasse es weg, falls das Element ein Pointer oder Handle ist.</li>
      </ol>
      <p>Siehe <a href="#ExStruct">Strukturbeispiele</a> f&uuml;r weitere Verwendungsm&ouml;glichkeiten.</p>
      <h3 id="limits">Bekannte Einschr&auml;nkungen</h3>
      <p>Wenn die <a href="../Variables.htm#amp">Adresse einer Variable</a> (z. B. &amp;EigeneVar) an eine Funktion &uuml;bergeben wird und die Funktion die L&auml;nge des Variableninhalts &auml;ndert, verh&auml;lt sich die Variable bei nachfolgender Verwendung nicht mehr korrekt. Dieses Problem kann nur behoben werden, wenn einer der folgenden Punkte durchgef&uuml;hrt wird:</p>
      <ul>
        <li>&Uuml;bergebe EigeneVar als <a href="#str">"Str"</a>-Argument, anstatt als Ptr/Adresse.</li>
        <li>Seit v1.0.44.03 kann <a href="VarSetCapacity.htm#neg1">VarSetCapacity (EigeneVar, -1)</a> nach Aufruf von DllCall aufgerufen werden, um die intern gespeicherte L&auml;nge der Variable zu aktualisieren.</li>
      </ul>
      <p>Jeder bin&auml;re Null, die per Funktion in eine Variable gespeichert wurde, versteckt alle Daten, die rechts neben der Null vorkommen. Das hei&szlig;t, dass solche Daten weder zugreifbar sind noch von den meisten Befehlen und Funktionen ge&auml;ndert werden k&ouml;nnen. Allerdings k&ouml;nnen solche Daten mittels <a href="../Variables.htm#amp">Adressoperatoren</a>, <a href="../Functions.htm#NumPut">NumPut</a>/<a href="../Functions.htm#NumGet">NumGet</a> und DllCall selbst manipuliert werden.</p>
      <p>Es ist m&ouml;glich, dass eine Funktion, die die Adresse von einem der &uuml;bergebenen Strings zur&uuml;ckgibt, den selben String zur&uuml;ckgibt, nur auf einer anderen Speicheradresse. Zum Beispiel w&uuml;rde der Aufruf von <code>CharLower(CharUpper(EigeneVar))</code> in einer Programmiersprache dazu f&uuml;hren, dass der Inhalt von <em>EigeneVar</em> in Kleinbuchstaben umgewandelt wird. Wird das gleiche aber mit DllCall() gemacht, w&uuml;rde <em>EigeneVar</em> nach folgendem Aufruf gro&szlig;geschrieben sein, weil CharLower einen anderen/tempor&auml;ren String bearbeitet hat, dessen Inhalt identisch zu <em>EigeneVar</em> war:</p>
      <pre>EigeneVar = ABC
Ergebnis := DllCall("CharLower", <strong><u>str</u></strong>, DllCall("CharUpper", Str, EigeneVar, <strong><u>Str</u></strong>), Str)</pre>
      <p>Um dieses Problem zu umgehen, k&ouml;nnen die zwei unterstrichenen "Str"-Werte mit Ptr ersetzt werden. Dadurch wird der R&uuml;ckgabewert von CharUpper als reine Adresse interpretiert, der dann als Integer an CharLower &uuml;bergeben wird.</p>
      <p>Beim Umgang mit Strings k&ouml;nnen bestimmte Einschr&auml;nkungen auftreten. F&uuml;r weitere Informationen, siehe <a href="../Compat.htm#DllCall">Script-Kompatibilit&auml;t</a>.</p>
      <h3 id="COM">Component Object Model (COM)</h3>
      <p>COM-Objekte, die per VBScript und &auml;hnliche Sprachen zugreifbar sind, sind typischerweise auch &uuml;ber AutoHotkey via <a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjGet.htm">ComObjGet</a>, <a href="ComObjActive.htm">ComObjActive</a> und interner <a href="../Objects.htm#Usage_Objects">Objekt-Syntax</a> zugreifbar.</p>
      <p>COM-Objekte, die <a href="http://msdn.microsoft.com/en-us/library/ms221608.aspx">IDispatch</a> nicht unterst&uuml;tzen, k&ouml;nnen mit DllCall verwendet werden, indem die Adresse einer Funktion von der virtuellen Funktionstabelle des Objekt-Interfaces abgerufen wird. F&uuml;r weitere Details, siehe <a href="#ExTaskbar">das Beispiel</a> weiter unten.</p>
      <p>Auch der Gro&szlig;teil von .NET-Framework ist ist per COM und DllCall zugreifbar. Siehe <a href="http://www.autohotkey.com/forum/topic26191.html">http://www.autohotkey.com/forum/topic26191.html</a>. </p>
      <h3>Verwandte Befehle</h3>
      <p><a href="../Compat.htm#DllCall">Script-Kompatibilit&auml;t</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity</a>, <a href="../Functions.htm">Funktionen</a>, <a href="SysGet.htm">SysGet</a>, <a href="http://msdn.microsoft.com/library/">MSDN-Bibliothek</a></p>
      <h3>Beispiele</h3>
      <pre class="NoIndent"><em>; Beispiel: Ruft die Windows-API-Funktion "MessageBox" auf und meldet, welche Schaltfl&auml;che der Benutzer dr&uuml;ckt.</em>

WelcherButton := DllCall("MessageBox", "Int", "0", "Str", "Ja oder Nein dr&uuml;cken", "Str", "Titel der Box", "Int", 4)
MsgBox Sie haben die Schaltfl&auml;che #%WelcherButton% gedr&uuml;ckt.</pre>
      <pre class="NoIndent"><em>; Beispiel: Ersetzt das Desktop-Hintergrundbild mit der angegebenen Bitmap-Datei (.bmp).</em>

DllCall("SystemParametersInfo", UInt, 0x14, UInt, 0, Str, <i>A_WinDir <strong>.</strong> "\winnt.bmp"</i>, UInt, 2)</pre>
      <pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion "IsWindowVisible" auf, um herauszufinden, ob ein Editor-Fenster sichtbar ist.</em>

DetectHiddenWindows On
If not DllCall("IsWindowVisible", "Ptr", WinExist("Unbenannt - Editor"))  <em>; WinExist() gibt HWND zur&uuml;ck.</em>
    MsgBox Das Fenster ist nicht sichtbar.</pre>
      <pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion wsprintf() auf, um die Zahl 432 mit f&uuml;hrenden Nullen zu erweitern, insgesamt 10 Zeichen lang (0000000432).</em>

VarSetCapacity(ErweiterteZahl, 20)  <em>; Stellt sicher, dass die Variable gro&szlig; genug f&uuml;r den neuen String ist.</em>
DllCall("wsprintf", "Str", ErweiterteZahl, "Str", "%010d", "Int", 432, "Cdecl")  <em>; Ben&ouml;tigt die Cdecl-Aufrufkonvention.</em>
MsgBox %ZeroPaddedNumber%</pre>
      <pre class="NoIndent" id="QPC"><em>; Beispiel: Demonstriert QueryPerformanceCounter(), die eine h&ouml;here Pr&auml;zision als die 10 ms von <a href="../Variables.htm#TickCount">A_TickCount</a> bietet.</em>

DllCall("QueryPerformanceCounter", "Int64*", CounterDavor)
Sleep 1000
DllCall("QueryPerformanceCounter", "Int64*", CounterDanach)
MsgBox % "Die Differenz zwischen den Zeiten betr&auml;gt " . CounterDanach - CounterDavor</pre>
      <pre class="NoIndent"><em>; Beispiel: Dieser Hotkey verringert vor&uuml;bergehend die Geschwindigkeit des Mauszeigers, um eine genauere Positionierung zu erm&ouml;glichen.
Haltet die F1-Taste gedr&uuml;ckt, um den Mauszeiger zu verlangsamen. Lasst F1 los, um die originale Geschwindigkeit wiederherzustellen.</em>

F1::
SPI_GETMOUSESPEED = 0x70
SPI_SETMOUSESPEED = 0x71
<em>; Ermittelt die aktuelle Geschwindigkeit, um sie sp&auml;ter wiederherzustellen:</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_GETMOUSESPEED, UInt, 0, UIntP, OrigMausSpeed, UInt, 0)
<em>; Nun wird die Geschwindigkeit der Maus im vorletzten Parameter verringert (von 1 bis 20, 10 ist Standard):</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_SETMOUSESPEED, UInt, 0, Ptr, <strong>3</strong>, UInt, 0)
KeyWait F1  <em>; Dadurch wird verhindert, dass die Auto-Wiederholung von der Tastatur DllCall mehrmals aufruft.</em>
Return

F1 up::<strong>DllCall</strong>("SystemParametersInfo", UInt, 0x71, UInt, 0, Ptr, OrigMausSpeed, UInt, 0)  <em>; Stellt die urspr&uuml;ngliche Geschwindigkeit wieder her.</em></pre>
      <pre class="NoIndent" id="GetChildHWND"><em>; Beispiel: Wenn die eindeutige ID des Fensters und der Text oder ClassNN eines Steuerelements &uuml;bergeben wird,
; gibt die folgende Funktion das HWND (eindeutige ID) des Steuerelements zur&uuml;ck.
; v1.0.43.06+: Diese Funktion wurde von folgendem Befehl ersetzt, der genauer ist.</em>

<a href="ControlGet.htm#Hwnd">ControlGet, Ausgabevariable, Hwnd,, ClassNN, Fenstertitel</a></pre>
      <pre class="NoIndent"><em>; Beispiel: &Uuml;berwacht das aktive Fenster und zeigt die Position der vertikalen Bildlaufleiste
; im fokussierten Steuerelement an (mit Echzeit-Aktualisierung). Erfordert v1.0.43.06+, weil <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a> verwendet wird.</em>

#Persistent
SetTimer, BildlaufleisteBeobachten, 100
Return

BildlaufleisteBeobachten:
ActiveWindow := WinExist("A")
If not ActiveWindow  <em>; Kein aktives Fenster.</em>
    Return
ControlGetFocus, FokussiertesSteuerelement, ahk_id %ActiveWindow%
If not FokussiertesSteuerelement  <em>; Kein fokussiertes Steuerelement.</em>
    Return
<em>; Zeigt die vertikale oder horizontale Position der Bildlaufleiste in einem ToolTip an:</em>
ControlGet, ChildHWND, Hwnd,, %FokussiertesSteuerelement%, ahk_id %ActiveWindow%
ToolTip % <strong>DllCall</strong>("GetScrollPos", "Ptr", ChildHWND, "Int", 1)  <em>;  Im letzten Parameter kann 1 f&uuml;r SB_VERT und 0 f&uuml;r SB_HORZ angegeben werden.</em>
Return</pre>
      <pre class="NoIndent" id="file"><em>; Beispiel: Dieses Script schreibt etwas Text in eine Datei und liest diesen zur&uuml;ck in den Speicher (ben&ouml;tigt v1.0.34+).
; Diese Methode hilft der Performance, falls mehreren Dateien gleichzeitig gelesen oder geschrieben werden m&uuml;ssen.
; Seit AHK_L 42 kann das Gleiche mit <a href="FileOpen.htm">FileOpen</a> erreicht werden. Siehe dazu das <a href="FileOpen.htm#writeread">Beispiel</a>.</em>

FileSelectFile, Dateiname, S16,, Neue Datei erstellen:
If Dateiname =
    Return
GENERIC_WRITE = 0x40000000  <em>; Datei zum Schreiben &ouml;ffnen.</em>
CREATE_ALWAYS = 2  <em>; Neue Datei erstellen (&uuml;berschreibt eine vorhandene Datei).</em>
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_WRITE, UInt, 0, Ptr, 0, UInt, CREATE_ALWAYS, UInt, 0, Ptr, 0, Ptr)
If not hFile
{
    MsgBox Kann "%Dateiname%" nicht zum Schreiben &ouml;ffnen.
    Return
}
TestString = Das ist ein Teststring.`r`n  <em>; Wenn eine Datei auf diese Weise geschrieben wird, sollte `r`n anstelle von `n verwendet werden, um eine neue Zeile zu beginnen.</em>
<strong>DllCall</strong>("WriteFile", Ptr, hFile, Str, TestString, UInt, StrLen(TestString), UIntP, AktuellGeschriebeneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Datei schlie&szlig;en.</em>

<em>; Nachdem die Datei geschrieben wurde, soll deren Inhalt zur&uuml;ck in den Speicher gelesen werden.</em>
GENERIC_READ = 0x80000000  <em>; Datei zum Lesen &ouml;ffnen.</em>
OPEN_EXISTING = 3  <em>; Datei muss existieren, bevor sie ge&ouml;ffnet werden kann.</em>
FILE_SHARE_READ = 0x1 <em>; Diese und die n&auml;chste Variable bestimmen, ob andere Prozesse die Datei &ouml;ffnen k&ouml;nnen.</em>
FILE_SHARE_WRITE = 0x2
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_READ, UInt, FILE_SHARE_READ|FILE_SHARE_WRITE, Ptr, 0, UInt, OPEN_EXISTING, UInt, 0, Ptr, 0)
If not hFile
{
    MsgBox Kann "%Dateiname%" nicht zum Lesen &ouml;ffnen.
    Return
}
<em>; Macht die Variable f&uuml;r weitere Testzwecke leer, aber stellt sicher, das gen&uuml;gend Kapazit&auml;t zur Verf&uuml;gung steht:</em>
ZuLesendeBytes := VarSetCapacity(TestString, StrLen(TestString))
<strong>DllCall</strong>("ReadFile", Ptr, hFile, Str, TestString, UInt, ZuLesendeBytes, UIntP, AktuellGeleseneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Datei schlie&szlig;en.</em>
MsgBox Der folgende String wurde aus der Datei gelesen: %TestString%</pre>
      <pre class="NoIndent" id="HideCursor"><em>; Beispiel: Schaltet den Mauszeiger mit Win+C ein oder aus.
; Dieses Script stammt aus <a href="http://www.autohotkey.com/forum/topic6107.html">www.autohotkey.com/forum/topic6107.html</a></em>

OnExit, CursorAnzeigen  <em>; Stellt sicher, dass der Mauszeiger beim Beenden des Scripts wieder sichtbar gemacht wird.</em>
Return

CursorAnzeigen:
SystemCursor("On")
ExitApp

#c::SystemCursor("Toggle")  <em>; Win+C, um Mauszeiger ein- und auszuschalten.</em>

SystemCursor(OnOff=1)   <em>; INIT = "I","Init"; OFF = 0,"Off"; TOGGLE = -1,"T","Toggle"; ON = Andere</em>
{
    static AndMask, XorMask, $, h_cursor
        ,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13 <em>; Mauszeiger vom System</em>
        , b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13   <em>; Leere Mauszeiger</em>
        , h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13   <em>; Handles von Standardzeiger</em>
    If (OnOff = "Init" or OnOff = "I" or $ = "")       <em>; initialisieren, wenn ben&ouml;tigt oder erster Aufruf</em>
    {
        $ = h                                          <em>; aktive Standardzeiger</em>
        VarSetCapacity( h_cursor,4444, 1 )
        VarSetCapacity( AndMask, 32*4, 0xFF )
        VarSetCapacity( XorMask, 32*4, 0 )
        system_cursors = 32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650
        StringSplit c, system_cursors, `,
        Loop %c0%
        {
            h_cursor   := DllCall( "LoadCursor", "Ptr",0, "Ptr",c%A_Index% )
            h%A_Index% := DllCall( "CopyImage", "Ptr",h_cursor, "UInt",2, "Int",0, "Int",0, "UInt",0 )
            b%A_Index% := DllCall( "CreateCursor", "Ptr",0, "Int",0, "Int",0
                , "Int",32, "Int",32, "Ptr",&amp;AndMask, "Ptr",&amp;XorMask )
        }
    }
    If (OnOff = 0 or OnOff = "Off" or $ = "h" and (OnOff &lt; 0 or OnOff = "Toggle" or OnOff = "T"))
        $ = b  <em>; leere Mauszeiger benutzen</em>
    Else
        $ = h  <em>; gespeicherte Mauszeiger benutzen</em>

    Loop %c0%
    {
        h_cursor := DllCall( "CopyImage", "Ptr",%$%%A_Index%, "UInt",2, "Int",0, "Int",0, "UInt",0 )
        DllCall( "SetSystemCursor", "Ptr",h_cursor, "UInt",c%A_Index% )
    }
}</pre>
      <pre class="NoIndent" id="ExStruct"><em>; Struktur-Beispiel: &Uuml;bergibt die Adresse einer RECT-Struktur an GetWindowRect(), das die.
; Strukturelemente auf die Positionen der linken, oberen,
; rechten und unteren Seite des Fensters setzt (bezogen auf dem Bildschirm).</em>

Run Notepad
WinWait Unbenannt - Editor  <em>; Setzt auch das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" f&uuml;r das untere WinExist().</em>
VarSetCapacity(Rect, 16)  <em>; RECT ist eine Struktur, bestehend aus vier 32-Bit-Integer (d. h. 4 * 4 = 16).</em>
<strong>DllCall</strong>("GetWindowRect", Ptr, WinExist(), Ptr, &amp;Rect)  <em>; WinExist() gibt HWND zur&uuml;ck.</em>
MsgBox % "Links " . <a href="../Functions.htm#NumGet">NumGet</a>(Rect, 0, "Int") . " Oben " . NumGet(Rect, 4, "Int")
    . " Rechts " . NumGet(Rect, 8, "Int") . " Unten " . NumGet(Rect, 12, "Int")</pre>
      <pre class="NoIndent"><em>; Struktur-Beispiel: &Uuml;bergibt die Adresse einer RECT-Struktur an FillRect(), um den
; Bildschirm kurzzeitig rot zu f&auml;rben.</em>

VarSetCapacity(Rect, 16, 0)  <em>; Erm&ouml;glicht, dass die Variable vier 4-Byte-Integer enthalten kann und initialisiert sie alle mit Null.</em>
<a href="../Functions.htm#NumPut">NumPut</a>(A_ScreenWidth//2, Rect, 8, "Int")  <em>; Der dritte Integer in der Struktur ist "rect.right".</em>
NumPut(A_ScreenHeight//2, Rect, 12, "Int") <em>; Der vierte Integer in der Struktur ist "rect.bottom".</em>
hDC := <strong>DllCall</strong>("GetDC", "Ptr", 0, "Ptr")  <em>; &Uuml;bergibt 0, um den Ger&auml;tekontext vom Desktop zu ermitteln.</em>
hBrush := <strong>DllCall</strong>("CreateSolidBrush", "UInt", 0x0000FF, "Ptr")  <em>; Erstellt einen roten Pinsel (0x0000FF ist im BGR-Format).</em>
<strong>DllCall</strong>("FillRect", "Ptr", hDC, "Ptr", &amp;Rect, "Ptr", hBrush)  <em>; F&uuml;llt das angegebene Rechteck mithife des oberen Pinsels.</em>
<strong>DllCall</strong>("ReleaseDC", "Ptr", 0, "Ptr", hDC)  <em>; Speicher freigeben.</em>
<strong>DllCall</strong>("DeleteObject", "Ptr", hBrush)  <em>; Speicher freigeben.</em></pre>
      <pre class="NoIndent"><em>; Struktur-Beispiel: &Auml;ndert Datum und Zeit der Systemuhr. Aber Vorsicht: 
; Sobald die Uhr auf ein zuk&uuml;nftiges Datum gesetzt wird, kann es passieren, dass geplante Tasks vorzeitig ausgef&uuml;hrt werden!</em>

SystemzeitSetzen("20051008142211")  <em>; <a href="FileSetTime.htm#YYYYMMDD">Zeitstempel</a> &uuml;bergeben (lokal, nicht UTC).</em>

SystemzeitSetzen(YYYYMMDDHHMISS)
<em>; Setzt die Systemzeit auf das angegebene Datum und Zeit.
; Der Aufrufer muss sicherstellen, dass der eingehende Parameter ein g&uuml;ltiger Zeitstempel ist
; (lokale Zeit, nicht UTC). Bei Erfolg wird eine Zahl ungleich 0 zur&uuml;ckgegeben.</em>
{
    <em>; Konvertiert f&uuml;r SystemzeitSetzen() den Parameter von lokale Zeit in UTC.</em>
    UTC_Delta -= A_NowUTC, Seconds  <em>; Sekunden sind aufgrund des Rundungsproblems genauer.</em>
    UTC_Delta := Round(-UTC_Delta/60)  <em>; Auf die n&auml;chste Minute runden.</em>
    YYYYMMDDHHMISS += UTC_Delta, Minutes  <em>; Offset zur Konvertierung auf UTC hinzuf&uuml;gen.</em>

    VarSetCapacity(SystemTime, 16, 0)  <em>; Diese Struktur besteht aus 8 UShort-Werte (d. h. 8 * 2 = 16).</em>

    StringLeft, Int, YYYYMMDDHHMISS, 4    <em>; YYYY (Jahr)</em>
    <a href="../Functions.htm#NumPut">NumPut</a>(Int, SystemTime, 0, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 5, 2  <em>; MM (Monat des Jahrs, 1-12)</em>
    NumPut(Int, SystemTime, 2, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 7, 2  <em>; DD (Tag des Monats)</em>
    NumPut(Int, SystemTime, 6, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 9, 2  <em>; HH (Stunden im 24-Stunden-Format)</em>
    NumPut(Int, SystemTime, 8, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 11, 2 <em>; MI (Minuten)</em>
    NumPut(Int, SystemTime, 10, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 13, 2 <em>; SS (Sekunden)</em>
    NumPut(Int, SystemTime, 12, "UShort")

    Return <strong>DllCall</strong>("SetSystemTime", Ptr, &amp;SystemTime)
}</pre>
      <pre class="NoIndent"><em>/* <strong>Weitere Struktur-Befehle:</strong>

1) <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Script</a>: Ein DllCall()-Beispiel f&uuml;r die Erstellung einer Netzwerkverbindung
zu einem TCP/IP-Servers und von dort Daten empfangen werden k&ouml;nnen.

2) Das Betriebssystem besitzt Standard-Fensterdialoge zum Ausw&auml;hlen von Farben, Schriftarten oder Icons.
Solche Fensterdialoge verwenden Strukturen und werden in <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a> demonstriert.

*/</em></pre>
      <pre id="ExTaskbar" class="NoIndent"><em>/*
  Beispiel: Entfernt mit COM vor&uuml;bergehend das aktive Fenster von der Taskleiste.

  Methoden in der VTable der <a href="http://msdn.microsoft.com/en-us/library/bb774652.aspx">ITaskbarList</a>:
    IUnknown:
      0 QueryInterface  -- verwendet stattdessen <a href="ComObjQuery.htm">ComObjQuery</a>
      1 AddRef          -- verwendet stattdessen <a href="ObjAddRef.htm">ObjAddRef</a>
      2 Release         -- verwendet stattdessen <a href="ObjAddRef.htm">ObjRelease</a>
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Erstellt ein TaskbarList-Objekt und speichert dessen Adresse in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

activeHwnd := WinExist("A")

DllCall(vtable(tbl,3), "ptr", tbl)                     <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774650.aspx">HrInit</a>()</em>
DllCall(vtable(tbl,5), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
DllCall(vtable(tbl,4), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

<em>; Nicht-Dispatch-Objekte m&uuml;ssen immer manuell freigegeben werden.</em>
ObjRelease(tbl)

vtable(ptr, n) {
    <em>; NumGet(ptr+0) gibt die Adresse der virtuellen Funktionstabelle
    ; des Objekts zur&uuml;ck (kurz: vtable). Der Rest des Ausdrucks ermittelt
    ; die Adresse der n-ten Funktionsadresse von der vtable.</em>
    Return NumGet(NumGet(ptr+0), n*A_PtrSize)
}

</pre>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>