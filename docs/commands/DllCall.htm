<!DOCTYPE HTML>
<html>
<head>
<title>DllCall</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>DllCall()</h1>

<p>Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</p>

<pre class="Syntax">Ergebnis := DllCall("[DllDatei\]Funktion" [, Typ1, Arg1, Typ2, Arg2, "Cdecl Rückgabetyp"])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Ergebnis</dt>
  <dd><p>DllCall gibt den aktuellen Rückgabewert der Funktion zurück. Unterstützt die Funktion keinen Rückgabewert, übergibt sie einen undefinierten Integer-Wert. Wenn die Funktion durch einen <a href="#error">Fehler</a> nicht aufgerufen werden kann, ist der Rückgabewert leer (ein leerer String).</p></dd>

  <dt>[DllDatei\]Funktion</dt>
  <dd><p>Der Name einer DLL- oder EXE-Datei, gefolgt von einem umgekehrten Schrägstrich und dem Funktionsnamen. Zum Beispiel: <code>"MeineDLL\MeineFunktion"</code> (die Dateierweiterung ".dll" kann standardmäßig weggelassen werden). Solange kein absoluter Pfad angegeben ist, befindet sich die <em>DllDatei</em> im System- oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Pfad.</p>
      <p><em><a name="std"></a>DllDatei</em> kann weggelassen werden, wenn eine Funktion in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll aufgerufen wird. Zum Beispiel liefert <code>"User32\IsWindowVisible"</code> das gleiche Ergebnis wie <code>"IsWindowVisible"</code>.</p>
      <p>Sobald keine Funktion gefunden wird, wird nach dem angegebenen Namen automatisch ein A (ANSI) oder W (Unicode) angefügt, abhängig davon, welche AutoHotkey-Version zurzeit läuft. Zum Beispiel ist <code>"MessageBox"</code> in ANSI-Versionen das gleiche wie <code>"MessageBoxA"</code> und in Unicode-Versionen das gleiche wie <code>"MessageBoxW"</code>.</p>
      <p>Die Performance kann bei <em>wiederholenden</em> Funktionsaufrufen erheblich verbessert werden, wenn die DLL <a href="#load">vorher geladen</a> wird.</p>
    <p>Seit v1.0.46.08 kann dieser Parameter auch einen Integer-Wert enthalten, der als Adresse der Funktion interpretiert wird. Quellen für solche Adressen sind <a href="#COM">COM</a> und <a href="RegisterCallback.htm">RegisterCallBack()</a>.</p></dd>

  <dt>Typ1, Arg1</dt>
  <dd><p>Dieses Paar stellt einen Parameter dar, der an die Funktion übergeben wird. Die Anzahl an möglichen Paaren ist unbegrenzt. Für <em>Typ</em> kann die <a href="#types">Typentabelle</a> eingesehen werden. Für <em>Arg</em> kann der zu übergebende Wert angegeben werden.</p></dd>

  <dt>Cdecl Rückgabetyp</dt>
  <dd><p><a name="cdecl"></a>Das Wort <em>Cdecl</em> kann normalerweise weggelassen werden, weil die meisten Funktionen eher die Standard-Aufrufkonvention verwenden, als die C-Aufrufkonvention (Funktionen wie wsprintf, die eine unterschiedliche Anzahl an Argumenten akzeptieren, bilden solch eine Ausnahme). Wenn Cdecl weggelassen wird und <a href="#An">ErrorLevel A<strong>n</strong></a> enthält (<strong>n</strong> ist die Gesamtgröße an übergebenden Argumenten), wird <em>Cdecl</em> möglicherweise benötigt. Beachte, dass die meisten objektorientierten C++-Funktionen die nicht unterstützte <i>thiscall</i>-Konvention verwenden.</p>
      <p>Falls vorhanden, sollte das Wort <em>Cdecl</em> vor dem Rückgabetyp (falls vorhanden) stehen. Dabei muss jedes Wort mit einem Leer- oder Tabulatorzeichen getrennt werden. Zum Beispiel: <code>"Cdecl Str"</code>.</p>
      <p><span class="ver">[AHK_L 53+]:</span> Da eine seperate C-Aufrufkonvention im 64-Bit-Code nicht zur Verfügung steht, hat <i>Cdecl</i> im 64-Bit-Build von AutoHotkey keine Wirkung.</p>
      <p><em>Rückgabetyp</em>: Wenn die Funktion einen vorzeichenbehafteten 32-Bit-Integer (Int), BOOL oder nichts zurückgibt, kann <em>Rückgabetyp</em> weggelassen werden. Ansonsten kann ein Argumenttyp aus der <a href="#types">Typentabelle</a> verwendet werden. Das <a href="#asterisk">Sternchen-Suffix</a> wird ebenfalls unterstützt.</p></dd>

</dl>

<h3 id="types">Argumenttypen und Rückgabewerte</h3>
<table class="info">
<tr>
<td>Str</td>
<td><p><a name="str"></a>Ein String wie "Blau" oder MeineVar. Wenn die aufgerufene Funktion den String ändert und das Argument eine reine Variable ist, wird deren Inhalt aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von <em>MeineVar</em> in Großbuchstaben umwandeln: <code>DllCall("CharUpper", "Str", <i>MeineVar</i>)</code>.</p>
  <p>Wenn die Funktion allerdings in der Lage ist, einen String größer als die aktuelle Variablenkapazität zu speichern, muss sichergestellt werden, dass die Variable vor dem Funktionsaufruf groß genug ist. Das wird erreicht, indem <code><a href="VarSetCapacity.htm">VarSetCapacity(MeineVar, 123)</a></code> aufgerufen wird, wobei 123 die neue Länge von <em>MeineVar</em> ist.</p>
  <p>Ein <em>Str</em>-Argument darf kein <a href="../Variables.htm#Expressions">Ausdruck</a> sein, die eine Zahl berechnet (z. B. i+1). In diesem Fall wird die Funktion nicht aufgerufen und ErrorLevel auf -2 gesetzt.</p>
  <p>Die <a href="#asterisk">Sternchenvariable</a> "Str*" wird unterstützt, aber selten verwendet. Sie kann bei Funktionen verwendet werden, die so etwas erwarten wie "TCHAR **" oder "LPTSTR *".</p>
  <p>Hinweis: Bei der Übergabe eines Strings an eine Funktion muss klar sein, welchen <a href="../Compat.htm#DllCall">String-<i>Typ</i></a> die Funktion erwartet.</p></td>
</tr>
<tr>
  <td><a name="astr"></a><a name="wstr"></a>AStr<br>WStr</td>
  <td><span class="ver">[AHK_L 42+]:</span> Ein <b>A</b>NSI- oder Unicode-String (<b>W</b>ide character). Siehe <a href="../Compat.htm#DllCall">Script-Kompatibilität</a> für gleichwertige Win32-Typen und weitere Details.</td>
</tr>
<tr>
  <td>Int64</td>
  <td>Ein 64-Bit-Integer im Bereich von -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</td>
</tr>
<tr>
  <td>Int</td>
  <td id="Int"><p>Ein 32-Bit-Integer (meistgenutzter Integer-Typ) im Bereich von -2147483648 (-0x80000000) bis 2147483647 (0x7FFFFFFF). Int wird manchmal auch als "Long" bezeichnet.</p>
    <p>Int sollte auch für jedes BOOL-Argument verwendet werden (ein BOOL-Wert enthält entweder eine 1 oder 0).</p>
    <p>Ein <a href="#unsigned">vorzeichenloser</a> (unsigned) Integer (UInt) wird auch ziemlich oft genutzt, z. B. für DWORD.</p></td>
</tr>
<tr>
  <td>Short</td>
  <td>Ein 16-Bit-Integer im Bereich von -32768 (-0x8000) bis 32767 (0x7FFF). Ein <a href="#unsigned">vorzeichenloser</a> 16-Bit-Integer (UShort) kann bei Funktionen verwendet werden, die DWORD erwarten.</td>
</tr>
<tr>
  <td>Char</td>
  <td>Ein 8-Bit-Integer im Bereich von -128 (-0x80) bis 127 (0x7F). Ein <a href="#unsigned">vorzeichenloser</a> 8-Bit-Integer (UChar) kann bei Funktionen verwendet werden, die BYTE erwarten.</td>
</tr>
<tr>
  <td>Float</td>
  <td>Eine 32-Bit-Fließkommazahl mit maximal 6 Stellen nach dem Komma.</td>
</tr>
<tr>
  <td>Double</td>
  <td>Eine 64-Bit-Fließkommazahl mit maximal 15 Stellen nach dem Komma.</td>
</tr>
<tr>
  <td>Ptr</td>
  <td id="ptr"><p><span class="ver">[AHK_L 42+]:</span> Ein Integer in <a href="../Variables.htm#PtrSize">Pointergröße</a>, das das gleiche wie Int oder Int64 ist, abhängig davon, ob die EXE-Datei, die das Script ausführt, 32- oder 64-Bit ist. <i>Ptr</i> gilt für Pointer, die auf Arrays oder Strukturen (wie RECT* oder LPPOINT) verweisen, und für fast alle Handles (wie HWND, HBRUSH oder HBITMAP). Falls der Parameter ein Pointer ist, der auf einen einzelnen numerischen Wert wie LPDWORD oder int* verweist, sollte generell der Suffix * oder P anstelle von "Ptr" verwendet werden.</p>
  <p><i>Ptr</i> kann auch mit dem Suffix * oder P verwendet werden; es sollte mit Funktionen verwendet werden, die einen Pointer per LPVOID* oder Ähnliches zurückgeben.</p>
  <p><i>UPtr</i> ist auch gültig, das aber nur in 32-Bit-Builds vorzeichenlos ist, da AutoHotkey vorzeichenlose 64-Bit-Integer nicht unterstützt.</p>
  <p>Wenn die Kompatibilität mit älteren Versionen von AutoHotkey erforderlich ist, kann ein Variablentyp wie folgt verwendet werden:</p>
  <pre>Ptr := A_PtrSize ? "Ptr" : "UInt" <em>; Wenn A_PtrSize nicht definiert ist, gilt stattdessen UInt.</em>
DllCall("DeleteFile", Ptr, &amp;Dateiname) <em>; Lasst die Anführungszeichen bei Ptr weg.</em></pre>
  <p>Hinweis: Zum Übergeben eines <strong>NULL</strong>-Handles oder -Pointers muss der Integer 0 verwendet werden.</p></td>
</tr>
<tr>
  <td>* oder P<br>
    (Suffix)</td>
  <td id="asterisk"><p>Ein Sternchen (optional mit einem Leerzeichen davor), das an einen beliebigen oben genannten Typ angefügt wird, bewirkt, dass die Adresse des Arguments übergeben wird, anstatt der Wert selbst (die aufgerufene Funktion muss dazu in der Lage sein, so etwas zu akzeptieren). Da sich der Wert eines solchen Arguments durch die Funktion ändern kann, während eine reine Variable als Argument übergeben wird, wird der Inhalt dieser Variable aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von MeineVar per Adresse an MeineFunktion übergeben, aber auch MeineVar aktualisieren, um Änderung an ihr durch MeineFunktion widerzuspiegeln: <code>DllCall("MeineDLL\MeineFunktion", "Int*", MeineVar)</code>.</p>
    <p>In der Regel wird ein Sternchen verwendet, wann immer eine Funktion ein Argumenttyp oder Rückgabetyp hat, der mit "LP" beginnt. Das bekannteste Beispiel dafür ist LPDWORD, das ein Pointer ist, der auf ein DWORD verweist. Da DWORD ein vorzeichenloser 32-Bit-Integer ist, sollte für LPDWORD stattdessen "UInt*" oder "UintP" verwendet werden. Das Sternchen sollte nicht bei Stringtypen wie LPTSTR, Pointer, die auf Strukturen verweisen (z. B. LPRECT), oder Arrays verwendet werden; für diese sollte eher <a href="#str">"Str"</a> oder "Ptr" verwendet werden, abhängig davon, ob eine Variable oder deren Adresse übergeben werden soll.</p>
    <p>Hinweis: "Char*" ist nicht das gleiche wie <a href="#str">"Str"</a>, weil "Char*" die Adresse einer 8-Bit-Zahl übergibt, während <a href="#str">"Str"</a> die Adresse einer Reihe von Zeichen übergibt, die je nach AutoHotkey-Version 8-Bit (ANSI) oder 16-Bit (Unicode) groß sind. Ebenso übergibt "UInt*" die Adresse einer 32-Bit-Zahl, daher sollte das nicht verwendet werden, wenn die Funktion ein Array mit Werten oder eine Struktur größer als 32 Bit erwartet.</p>
    <p>Da die Variablen in AutoHotkey keinen festen Typ haben, verweist die Adresse, die an die Funktion übergeben wurde, auf einen temporären Speicher, anstatt auf die Variable selbst. Es ist nicht notwendig, <a href="VarSetCapacity.htm">VarSetCapacity</a> für die Variable aufzurufen, weil sie von DllCall korrekt aktualisiert wird, sobald die Funktion durchgeführt wurde.</p>
    </td>
</tr>
<tr>
  <td>U (Präfix)</td>
  <td><p><a name="unsigned"></a>Setzt den Buchstaben vor einem der oberen Integer-Typen, damit dieser als vorzeichenloser Integer (UInt64, Uint, UShort und UChar) interpretiert wird. Streng genommen ist das nur für Rückgabewerte und <a href="#asterisk">Sternchenvariablen</a> notwendig, da es keine Rolle spielt, ob ein Argument, der als Wert übergeben wurde, vorzeichenbehaftet oder vorzeichenlos ist (außer für Int64).</p>
    <p>Wenn ein negativer Integer für ein vorzeichenloses Argument angegeben wurde, wechselt der Integer in den vorzeichenlosen Bereich. Wenn zum Beispiel -1 als UInt gesendet wird, würde diese zu 0xFFFFFFFF werden.</p>
    <p><em>Vorzeichenlose</em> 64-Bit-Integer, die per Funktion erzeugt wurden, werden nicht unterstützt. Um deshalb mit Zahlen größer gleich 0x8000000000000000 zu arbeiten, muss das U-Präfix weggelassen und alle negativen Werte, die von der Funktion stammen, als große Integer interpretiert werden. Zum Beispiel wird eine Funktion, die -1 als Int64 zurückgibt, in Wirklichkeit 0xFFFFFFFFFFFFFFFF als UInt64 zurückgeben, wenn sie dazu in der Lage ist.</p></td>
</tr>
</TABLE>
<p><strong>Hinweis</strong>: Wenn die Argument- oder Rückgabetypen ohne Leerzeichen oder Sternchen angegeben werden, können die Anführungszeichen weggelassen werden. Zum Beispiel ist es möglich, <code>Str</code> anstelle von <code>"Str"</code> und <code>CDecl</code> anstelle von <code>"CDecl"</code> zu verwenden. Darüber hinaus kann für den Buchstaben P auch ein Sternchen verwendet werden, damit auch dort die Anführungszeichen weggelassen werden können. Zum Beispiel: <code>UIntP</code>.</p>

<h3 id="error">ErrorLevel</h3>
<p><span class="ver">[v1.1.04+]</span> Diese Funktion ist in der Lage, bei Misserfolg eine Ausnahme auszulösen. Für mehr Informationen, siehe <a href="Catch.htm#RuntimeErrors">Laufzeitfehler</a>.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> wird auf einen der folgenden Werte gesetzt, um den Erfolg oder Misserfolg des Aufrufs zu kennzeichnen.</p>
<p><strong>0</strong>: Erfolgreich.</p>
<p><strong>-1</strong>: Der <em>[DllDatei\]Funktion</em>-Parameter ist eine Fließkommazahl. Es wird ein String oder ein positiver Integer benötigt.</p>
<p><strong>-2</strong>: Der <a href="#types">Rückgabetyp</a> oder einer der angegebenen <a href="#types">Argumenttypen</a> ist ungültig. Dieser Fehler kann auch auftreten, wenn ein <a href="../Variables.htm#Expressions">Ausdruck</a>, der eine Zahl errechnet, an ein String (<a href="#str">Str</a>) übergeben wird.</p>
<p><strong>-3</strong>: Die angegebene <em>DllDatei</em> konnte weder zugegriffen noch geladen werden. Wenn kein expliziter Pfad bei <em>DllDatei</em> angegeben ist, muss sich die Datei im System- oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Pfad befinden. Dieser Fehler kann auch auftreten, wenn dem Benutzer die nötigen Zugriffsrechte für die Datei fehlen, oder wenn AutoHotkey im 32-Bit-Format und die DLL im 64-Bit-Format ist (oder umgekehrt).</p>
<p><strong>-4</strong>: Die angegebene Funktion konnte innerhalb der DLL nicht gefunden werden.</p>
<p><strong>N</strong> (beliebige positive Nummer): Der Aufruf der Funktion war erfolgreich, aber sie wurde mit dem schwerwiegenden Ausnahmefehler Nummer <strong>N</strong> abgebrochen (z. B. 0xC0000005 bedeutet "Zugriffsverletzung"). In solchen Fällen gibt die Funktion einen leeren String zurück, aber alle <a href="#asterisk">Sternchenvariablen</a> werden weiter aktualisiert. Zum Beispiel ist ein schwerer Ausnahmefehler die Dereferenzierung eines ungültigen Pointers, wie z. B. NULL. Da eine <a href="#cdecl">Cdecl</a>-Funktion nie einen <em>"An"</em>-Fehler aus dem nächsten Abschnitt erzeugen kann, könnte ein Ausnahmefehler auftreten, wenn zu wenig Argumente an diese Funktion übergeben werden.</p>
<p><strong><a name="An"></a>An</strong> (Buchstabe A, gefolgt von einem Integer <strong>n</strong>): Der Aufruf der Funktion war erfolgreich, allerdings wurden zu viel oder zu wenig Argumente übergeben. "<strong>n</strong>" ist dabei die Anzahl an Bytes, mit denen die Argumentenliste falsch war. Ist <strong>n</strong> positiv, wurden zu viele Argumente (oder zu lange Argumente) übergeben, oder der Aufruf erfordert <a href="#cdecl">CDecl</a>. Ist <strong>n</strong> negativ, wurden zu wenige Argumente übergeben. Dieses Problem sollte behoben werden, um sicherzustellen, dass die Funktion richtig läuft. So ein Fehler könnte auch darauf hindeuten, dass ein Ausnahmefehler aufgetreten ist - in diesem Fall gibt die Funktion einen leeren Wert zurück. Beachte, dass 64-Bit-Builds den ErrorLevel aufgrund der x64-Aufrufkonvention nie auf <b>An</b> setzen.</p>

<h3 id="except">Ausnahmen und A_LastError</h3>
<p>Trotz integrierter Ausnahmebehandlung ist es möglich, dass ein Script mit DllCall abstürzt. Das kann passieren, wenn eine Funktion nicht direkt ein Ausnahmefehler erzeugt, sondern etwas Unangebrachtes zurückgibt, wie z. B. ein schlechter Pointer oder ein nicht-terminierter String. Die Funktion ist nicht unbedingt daran Schuld, wenn das Script ihr einen ungeeigneten Wert übergibt, wie z. B. einen schlechten Pointer oder ein <a href="#str">"Str"</a> mit unzureichender Kapazität. Ein Script kann auch abstürzen, wenn ein ungeeigneter Argument- oder Rückgabetyp angegeben wird, z.B. mit der Behauptung, dass ein gewöhnlicher Integer, der von einer Funktion zurückgegeben wurde, eine <a href="#asterisk">Sternchenvariable</a> oder <a href="#str">Str</a> ist.</p>
<p><a name="LastError"></a>Die integrierte Variable <strong>A_LastError</strong> enthält den Rückgabewert der Systemfunktion GetLastError(), die sofort nach einem Funktionsaufruf aufgerufen wird (hat keine messbaren Auswirkungen auf die Performance). A_LastError enthält eine Nummer zwischen 0 und 4294967295 (immer als Dezimalzahl). Wie bei <a href="../misc/ErrorLevel.htm">ErrorLevel</a> gilt A_LastError jeweils nur für einen Thread, das heißt, dass Unterbrechungen durch andere <a href="../misc/Threads.htm">Threads</a> den Wert nicht ändern können. Allerdings wird A_LastError auch von <a href="Run.htm#LastError">Run/RunWait</a> geändert.</p>

<h3 id="load">Performance</h3>
<p>Die Performance kann bei mehrfachen Aufrufen einer DLL deutlich verbessert werden, indem sie explizit geladen wird (<em>das ist nicht für eine <a href="#std">Standard-DLL</a> wie User32 notwendig, weil diese dauerhaft im Arbeitsspeicher vorhanden ist</em>). Dadurch wird verhindert, dass für DllCall jedesmal LoadLibrary und FreeLibrary intern aufgerufen werden muss. Zum Beispiel:</p>
<pre>hModule := DllCall("<strong>LoadLibrary</strong>", "Str", "MeineFunktionen.dll", "Ptr")  <em>; Verhindert, dass DllCall() die Library in der Schleife laden muss.</em>
Loop, C:\Meine Dokumente\*.*, , 1
    Ergebnis := DllCall("MeineFunktionen\BackupFile", "Str", A_LoopFileFullPath)
DllCall("<strong>FreeLibrary</strong>", "Ptr", hModule)  <em>; Der DLL-Speicher wird freigeben.</em></pre>
<p>Seit v1.0.46.08 kann eine noch schnellere Performance erreicht werden, wenn vorher die Adresse der Funktion ermittelt wird. Zum Beispiel:</p>
<pre><em>; Wenn im folgenden Beispiel die DLL noch nicht geladen wurde, sollte LoadLibrary anstelle von GetModuleHandle verwenden werden.</em>
<strong>MulDivProc</strong> := DllCall("GetProcAddress", Ptr, DllCall("GetModuleHandle", Str, "<strong>kernel32</strong>", "Ptr"), AStr, "<strong>MulDiv</strong>", "Ptr")
Loop 500
    DllCall(<strong>MulDivProc</strong>, Int, 3, Int, 4, Int, 3)</pre>
<p><span class="ver">[AHK_L 31+]:</span> Wenn der erste Parameter von DllCall ein literaler String wie <code>"MulDiv"</code> ist und die DLL mit der Funktion normal vor dem Scriptstart geladen wurde, wird der String automatisch in eine Funktionsadresse aufgelöst. Diese integrierte Optimierung ist effektiver als das oben gezeigte Beispiel.</p>
<p>Auch das Hinzufügen von <a href="_NoEnv.htm">#NoEnv</a> irgendwo im Script verbessert die Performance, wenn Parametertypen ohne Anführungszeichen verwendet werden (z. B. Int vs. "Int").</p>
<p>Falls eine Stringvariable an eine Funktion übergeben wird, bei der sich die Länge des Strings nicht ändert, kann die Performance verbessert werden, indem man die Variable nicht als "<a href="#str">str</a>", sondern <a href="../Variables.htm#amp">per Adresse</a> (z. B. &amp;MeineVar) übergibt (besonders bei einem sehr langen String). Das folgende Beispiel wandelt einen String in Großbuchstaben um: <code>DllCall("CharUpper", <strong>Ptr</strong>, <strong>&amp;</strong>MeineVar, Ptr)</code>.</p>

<h3 id="struct">Strukturen und Arrays</h3>
<p>Eine Struktur ist eine Sammlung von <em>Elementen</em> (Feldern), die nebeneinander gespeichert sind. Die meisten Elemente sind Integer.</p>
<p>Funktionen, die die Adresse einer Struktur (oder eines Speicher-Block-Arrays) akzeptieren, können aufgerufen werden, indem die binären Rohdaten der Struktur in eine normale Variable gespeichert werden. Die folgenden Schritte werden in der Regel durchgeführt:</p>
<p>1) <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineStruktur, 123, 0)</code> aufrufen, um sicherzustellen, dass der Speicherumfang der Zielvariable groß genug für die Struktur ist. Ersetze 123 mit einer Zahl, die mindestens so groß wie die Strukturgröße ist. Die Null im letzten Parameter ist optional; dieser veranlasst, dass alle Elemente binäre Nullen sind, dadurch muss NumPut() nicht so oft im nächsten Schritt aufgerufen werden.</p>
<p>2) Wenn die Zielfunktion die Werte anfangs in der Struktur verwendet, muss <code><a href="NumPut.htm">NumPut</a>(123, MeineStruktur, 4, "UInt")</code> aufgerufen werden, um jedes Element zu initialisieren, das ungleich 0 sein soll. Ersetze 123 mit einem Integer, um diesen in das Zielelement einzufügen (oder verwendet <code>&amp;Var</code>, um die <a href="../Variables.htm#amp">Adresse</a> einer Variable zu speichern). Ersetze 4 mit dem Offset des Zielelements (siehe Schritt #4, was ein "Offset" ist). Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</p>
<p>3) Rufe die Zielfunktion auf, indem die <a href="../Variables.htm#amp">Adresse</a> von MeineStruktur als UInt-Argument (oder seit AHK_L 42 als Ptr-Argument) übergeben wird. Zum Beispiel: <code>DllCall("MeineDLL\MeineFunktion", Ptr, <strong>&amp;</strong>MeineStruktur)</code>. Die Funktion wird einige Elemente überprüfen und/oder ändern.</p>
<p>4) Verwende <code>MeinInteger := <a href="NumGet.htm">NumGet</a>(MeineStruktur, 4, "UInt")</code>, um beliebige Integer von der Struktur abzurufen. Ersetze 4 mit dem Offset des Zielelements in der Struktur. Das erste Element ist immer bei Offset 0. Das zweite Element ist bei Offset 0 plus die Größe des ersten Elements (in der Regel 4). Elemente nach dem zweiten sind bei dem Offset des vorherigen Feldes plus die Größe des vorherigen Feldes. Die meisten Elemente wie DWORD, INT und <a href="#Int">andere Typen von 32-Bit-Integer</a> haben eine Größe von 4 Bytes. Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</p>
<p>Siehe <a href="#ExStruct">Strukturbeispiele</a> für weitere Verwendungsmöglichkeiten.</p>
<h3 id="limits">Bekannte Einschränkungen</h3>
<p>Wenn die <a href="../Variables.htm#amp">Adresse einer Variable</a> (z. B. <code>&amp;MeineVar</code>) an eine Funktion übergeben wird und die Funktion die Länge des Variableninhalts ändert, verhält sich die Variable bei nachfolgender Verwendung nicht mehr korrekt. Dieses Problem kann nur behoben werden, wenn einer der folgenden Punkte durchgeführt wird: 1) Übergebe MeineVar nicht als Ptr/Adresse, sondern als <a href="#str">"Str"</a>-Argument; 2) Seit v1.0.44.03 kann <code><a href="VarSetCapacity.htm#neg1">VarSetCapacity (MeineVar, -1)</a></code> nach Aufruf von DllCall aufgerufen werden, um die intern gespeicherte Länge der Variable zu aktualisieren.</p>
<p>Jeder binäre Null, die per Funktion in eine Variable gespeichert wurde, versteckt alle Daten, die rechts neben der Null vorkommen. Das heißt, dass solche Daten weder zugreifbar sind noch von den meisten Befehlen und Funktionen geändert werden können. Allerdings können solche Daten mittels <a href="../Variables.htm#amp">Adressoperatoren</a>, <a href="NumPut.htm">NumPut</a>/<a href="NumGet.htm">NumGet</a> und DllCall selbst manipuliert werden.</p>
<p>Es ist möglich, dass eine Funktion, die die Adresse von einem der übergebenen Strings zurückgibt, den selben String zurückgibt, nur auf einer anderen Speicheradresse. Zum Beispiel würde der Aufruf von <code>CharLower(CharUpper(MeineVar))</code> in einer Programmiersprache dazu führen, dass der Inhalt von <em>MeineVar</em> in Kleinbuchstaben umgewandelt wird. Wird das gleiche aber mit DllCall() gemacht, würde <em>MeineVar</em> nach folgendem Aufruf großgeschrieben sein, weil CharLower einen anderen/temporären String bearbeitet hat, dessen Inhalt identisch zu <em>MeineVar</em> war:</p>
<pre>MeineVar = ABC
Ergebnis := DllCall("CharLower", <strong><u>str</u></strong>, DllCall("CharUpper", Str, MeineVar, <strong><u>Str</u></strong>), Str)</pre>
<p>Um dieses Problem zu umgehen, können die zwei unterstrichenen "Str"-Werte mit Ptr ersetzt werden. Dadurch wird der Rückgabewert von CharUpper als reine Adresse interpretiert, der dann als Integer an CharLower übergeben wird.</p>
<p>Beim Umgang mit Strings können bestimmte Einschränkungen auftreten. Für weitere Informationen, siehe <a href="../Compat.htm#DllCall">Script-Kompatibilität</a>.</p>
<h3 id="COM">Component Object Model (COM)</h3>
<p>COM-Objekte, die per VBScript und ähnliche Sprachen zugreifbar sind, sind typischerweise auch über AutoHotkey via <a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjGet.htm">ComObjGet</a>, <a href="ComObjActive.htm">ComObjActive</a> und integrierter <a href="../Objects.htm#Usage_Objects">Objekt-Syntax</a> zugreifbar.</p>
<p>COM-Objekte, die <a href="http://msdn.microsoft.com/en-us/library/ms221608.aspx">IDispatch</a> nicht unterstützen, können mit DllCall verwendet werden, indem die Adresse einer Funktion von der virtuellen Funktionstabelle des Objekt-Interfaces abgerufen wird. Für weitere Details, siehe <a href="#ExTaskbar">das Beispiel</a> weiter unten.</p>
<p>Auch der Großteil von .NET-Framework ist ist per COM und DllCall zugreifbar. Siehe <a href="http://www.autohotkey.com/forum/topic26191.html">http://www.autohotkey.com/forum/topic26191.html</a>.
</p>

<h3>Siehe auch</h3>
<p><a href="../Compat.htm#DllCall">Script-Kompatibilität</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity</a>, <a href="../Functions.htm">Funktionen</a>, <a href="SysGet.htm">SysGet</a>, <a href="http://msdn.microsoft.com/library/">MSDN Library</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel: Ruft die Windows-API-Funktion "MessageBox" auf und meldet, welchen Button der Benutzer drückt.</em>

WelcherButton := DllCall("MessageBox", "Int", "0", "Str", "Ja oder Nein drücken", "Str", "Titel der Box", "Int", 4)
MsgBox Sie haben den Button #%WelcherButton% gedrückt.</pre>

<pre class="NoIndent"><em>; Beispiel: Ersetzt das Desktop-Hintergrundbild mit der angegebenen Bitmap-Datei (.bmp).</em>

DllCall("SystemParametersInfo", UInt, 0x14, UInt, 0, Str, <i>A_WinDir <strong>.</strong> "\winnt.bmp"</i>, UInt, 2)</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion "IsWindowVisible" auf, um herauszufinden, ob ein Editor-Fenster sichtbar ist.</em>

DetectHiddenWindows On
if not DllCall("IsWindowVisible", "Ptr", WinExist("Unbenannt - Editor"))  <em>; WinExist() gibt HWND zurück.</em>
    MsgBox Das Fenster ist nicht sichtbar.</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion wsprintf() auf, um die Zahl 432 mit führenden Nullen zu erweitern, insgesamt 0000000432 Zeichen lang (20).</em>

VarSetCapacity(ErweiterteZahl, 20)  <em>; Stellt sicher, dass die Variable groß genug für den neuen String ist.</em>
DllCall("wsprintf", "Str", ErweiterteZahl, "Str", "%010d", "Int", 432, "Cdecl")  <em>; Benötigt die Cdecl-Aufrufkonvention.</em>
MsgBox %ZeroPaddedNumber%</pre>

<pre class="NoIndent"><a name="QPC"></a><em>; Beispiel: Demonstriert QueryPerformanceCounter(), die eine höhere Präzision als die 10 ms von <a href="../Variables.htm#TickCount">A_TickCount</a> bietet.</em>

DllCall("QueryPerformanceCounter", "Int64*", CounterDavor)
Sleep 1000
DllCall("QueryPerformanceCounter", "Int64*", CounterDanach)
MsgBox % "Die Differenz zwischen den Zeiten beträgt " . CounterDanach - CounterDavor</pre>

<pre class="NoIndent"><em>; Beispiel: Dieser Hotkey verringert vorübergehend die Geschwindigkeit des Mauszeigers, um eine genauere Positionierung zu ermöglichen.
; Halte die F1-Taste, um den Mauszeiger zu verlangsamen. Lasst F1 los, um die originale Geschwindigkeit wiederherzustellen.</em>

F1::
SPI_GETMOUSESPEED = 0x70
SPI_SETMOUSESPEED = 0x71
<em>; Ermittelt die aktuelle Geschwindigkeit, um sie später wiederherzustellen:</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_GETMOUSESPEED, UInt, 0, UIntP, OrigMausSpeed, UInt, 0)
<em>; Nun wird die Geschwindigkeit der Maus im vorletzten Parameter verringert (von 1 bis 20, 10 ist Standard):</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_SETMOUSESPEED, UInt, 0, Ptr, <strong>3</strong>, UInt, 0)
KeyWait F1  <em>; Dadurch wird verhindert, dass die Auto-Wiederholung von der Tastatur DllCall mehrmals aufruft.</em>
return

F1 up::<strong>DllCall</strong>("SystemParametersInfo", UInt, 0x71, UInt, 0, Ptr, OrigMausSpeed, UInt, 0)  <em>; Stellt die ursprüngliche Geschwindigkeit wieder her.</em></pre>

<pre class="NoIndent"><a name="GetChildHWND"></a><em>; Beispiel: Wenn die eindeutige ID des Fensters und der Text oder ClassNN eines Steuerelements übergeben wird,
; gibt die folgende Funktion das HWND (eindeutige ID) des Steuerelements zurück.
; v1.0.43.06+: Diese Funktion wurde von folgendem Befehl ersetzt, der genauer ist.</em>

<a href="ControlGet.htm#Hwnd">ControlGet, AusgabeVar, Hwnd,, ClassNN, Fenstertitel</a></pre>

<pre class="NoIndent"><em>; Beispiel: Überwacht das aktive Fenster und zeigt die Position der vertikalen Bildlaufleiste
; im fokussierten Steuerelement an (mit Echzeit-Aktualisierung). Erfordert v1.0.43.06+, weil <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a> verwendet wird.</em>

#Persistent
SetTimer, BildlaufleisteBeobachten, 100
return

BildlaufleisteBeobachten:
ActiveWindow := WinExist("A")
if not ActiveWindow  <em>; Kein aktives Fenster.</em>
    return
ControlGetFocus, FokussiertesSteuerelement, ahk_id %ActiveWindow%
if not FokussiertesSteuerelement  <em>; Kein fokussiertes Steuerelement.</em>
    return
<em>; Zeigt die vertikale oder horizontale Position der Bildlaufleiste in einem ToolTip an:</em>
ControlGet, ChildHWND, Hwnd,, %FokussiertesSteuerelement%, ahk_id %ActiveWindow%
ToolTip % <strong>DllCall</strong>("GetScrollPos", "Ptr", ChildHWND, "Int", 1)  <em>;  Im letzten Parameter kann 1 für SB_VERT und 0 für SB_HORZ angegeben werden.</em>
return</pre>

<pre class="NoIndent"><a name="file"></a><em>; Beispiel: Dieses Script schreibt etwas Text in eine Datei und liest diesen zurück in den Speicher (benötigt v1.0.34+).
; Diese Methode hilft der Performance, falls mehreren Dateien gleichzeitig gelesen oder geschrieben werden müssen.
; Seit AHK_L 42 kann das Gleiche mit <a href="FileOpen.htm#writeread">FileOpen</a> erreicht werden. Siehe dazu das <a href="FileOpen.htm">Beispiel</a>.</em>

FileSelectFile, Dateiname, S16,, Neue Datei erstellen:
if Dateiname =
    return
GENERIC_WRITE = 0x40000000  <em>; Datei zum Schreiben öffnen.</em>
CREATE_ALWAYS = 2  <em>; Neue Datei erstellen (überschreibt eine vorhandene Datei).</em>
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_WRITE, UInt, 0, Ptr, 0, UInt, CREATE_ALWAYS, UInt, 0, Ptr, 0, Ptr)
if not hFile
{
    MsgBox Kann "%Dateiname%" nicht zum Schreiben öffnen.
    return
}
TestString = Das ist ein Teststring.`r`n  <em>; Wenn eine Datei auf diese Weise geschrieben wird, sollte `r`n anstelle von `n verwendet werden, um eine neue Zeile zu beginnen.</em>
<strong>DllCall</strong>("WriteFile", Ptr, hFile, Str, TestString, UInt, StrLen(TestString), UIntP, AktuellGeschriebeneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Datei schließen.</em>

<em>; Nachdem die Datei geschrieben wurde, soll deren Inhalt zurück in den Speicher gelesen werden.</em>
GENERIC_READ = 0x80000000  <em>; Datei zum Lesen öffnen.</em>
OPEN_EXISTING = 3  <em>; Datei muss existieren, bevor sie geöffnet werden kann.</em>
FILE_SHARE_READ = 0x1 <em>; Diese und die nächste Variable bestimmen, ob andere Prozesse die Datei öffnen können.</em>
FILE_SHARE_WRITE = 0x2
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_READ, UInt, FILE_SHARE_READ|FILE_SHARE_WRITE, Ptr, 0, UInt, OPEN_EXISTING, UInt, 0, Ptr, 0)
if not hFile
{
    MsgBox Kann "%Dateiname%" nicht zum Lesen öffnen.
    return
}
<em>; Macht die Variable für weitere Testzwecke leer, aber stellt sicher, das genügend Kapazität zur Verfügung steht:</em>
ZuLesendeBytes := VarSetCapacity(TestString, StrLen(TestString))
<strong>DllCall</strong>("ReadFile", Ptr, hFile, Str, TestString, UInt, ZuLesendeBytes, UIntP, AktuellGeleseneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Datei schließen.</em>
MsgBox Der folgende String wurde aus der Datei gelesen: %TestString%</pre>

<pre class="NoIndent"><a name="HideCursor"></a><em>; Beispiel: Versteckt den Mauszeiger, wenn man WIN+C drückt. Um den Mauszeiger wieder sichtbar zu machen, drücke nochmals WIN+C.
; Dieses Script stammt aus <a href="http://www.autohotkey.com/forum/topic6107.html">www.autohotkey.com/forum/topic6107.html</a></em>

OnExit, CursorAnzeigen  <em>; Stellt sicher, dass der Mauszeiger beim Beenden des Scripts wieder sichtbar gemacht wird.</em>
return

CursorAnzeigen:
SystemCursor("On")
ExitApp

#c::SystemCursor("Toggle")  <em>; WIN+C, um Mauszeiger ein- und auszuschalten.</em>

SystemCursor(OnOff=1)   <em>; INIT = "I","Init"; OFF = 0,"Off"; TOGGLE = -1,"T","Toggle"; ON = Andere</em>
{
    static AndMask, XorMask, $, h_cursor
        ,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13 <em>; Mauszeiger vom System</em>
        , b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13   <em>; Leere Mauszeiger</em>
        , h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13   <em>; Handles von Standardzeiger</em>
    if (OnOff = "Init" or OnOff = "I" or $ = "")       <em>; initialisieren, wenn benötigt oder erster Aufruf</em>
    {
        $ = h                                          <em>; aktive Standardzeiger</em>
        VarSetCapacity( h_cursor,4444, 1 )
        VarSetCapacity( AndMask, 32*4, 0xFF )
        VarSetCapacity( XorMask, 32*4, 0 )
        system_cursors = 32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650
        StringSplit c, system_cursors, `,
        Loop %c0%
        {
            h_cursor   := DllCall( "LoadCursor", "Ptr",0, "Ptr",c%A_Index% )
            h%A_Index% := DllCall( "CopyImage", "Ptr",h_cursor, "UInt",2, "Int",0, "Int",0, "UInt",0 )
            b%A_Index% := DllCall( "CreateCursor", "Ptr",0, "Int",0, "Int",0
                , "Int",32, "Int",32, "Ptr",&amp;AndMask, "Ptr",&amp;XorMask )
        }
    }
    if (OnOff = 0 or OnOff = "Off" or $ = "h" and (OnOff &lt; 0 or OnOff = "Toggle" or OnOff = "T"))
        $ = b  <em>; leere Mauszeiger benutzen</em>
    else
        $ = h  <em>; gespeicherte Mauszeiger benutzen</em>

    Loop %c0%
    {
        h_cursor := DllCall( "CopyImage", "Ptr",%$%%A_Index%, "UInt",2, "Int",0, "Int",0, "UInt",0 )
        DllCall( "SetSystemCursor", "Ptr",h_cursor, "UInt",c%A_Index% )
    }
}</pre>

<pre class="NoIndent" id="ExStruct"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an GetWindowRect(), das die.
; Strukturelemente auf die Positionen der linken, oberen,
; rechten und unteren Seite des Fensters setzt (bezogen auf dem Bildschirm).</em>

Run Notepad
WinWait Unbenannt - Editor  <em>; Setzt auch das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" für das untere WinExist().</em>
VarSetCapacity(Rect, 16)  <em>; RECT ist eine Struktur, bestehend aus vier 32-Bit-Integer (d. h. 4 * 4 = 16).</em>
<strong>DllCall</strong>("GetWindowRect", Ptr, WinExist(), Ptr, &amp;Rect)  <em>; WinExist() gibt HWND zurück.</em>
MsgBox % "Links " . <a href="NumGet.htm">NumGet</a>(Rect, 0, "Int") . " Oben " . NumGet(Rect, 4, "Int")
    . " Rechts " . NumGet(Rect, 8, "Int") . " Unten " . NumGet(Rect, 12, "Int")</pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an FillRect(), um den
; Bildschirm kurzzeitig rot zu färben.</em>

VarSetCapacity(Rect, 16, 0)  <em>; Ermöglicht, dass die Variable vier 4-Byte-Integer enthalten kann und initialisiert sie alle mit Null.</em>
<a href="NumPut.htm">NumPut</a>(A_ScreenWidth//2, Rect, 8, "Int")  <em>; Der dritte Integer in der Struktur ist "rect.right".</em>
NumPut(A_ScreenHeight//2, Rect, 12, "Int") <em>; Der vierte Integer in der Struktur ist "rect.bottom".</em>
hDC := <strong>DllCall</strong>("GetDC", "Ptr", 0, "Ptr")  <em>; Übergibt 0, um den Gerätekontext vom Desktop zu ermitteln.</em>
hBrush := <strong>DllCall</strong>("CreateSolidBrush", "UInt", 0x0000FF, "Ptr")  <em>; Erstellt einen roten Pinsel (0x0000FF ist im BGR-Format).</em>
<strong>DllCall</strong>("FillRect", "Ptr", hDC, "Ptr", &amp;Rect, "Ptr", hBrush)  <em>; Füllt das angegebene Rechteck mithife des oberen Pinsels.</em>
<strong>DllCall</strong>("ReleaseDC", "Ptr", 0, "Ptr", hDC)  <em>; Speicher freigeben.</em>
<strong>DllCall</strong>("DeleteObject", "Ptr", hBrush)  <em>; Speicher freigeben.</em></pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Ändert Datum und Zeit der Systemuhr. Aber Vorsicht: 
; Sobald die Uhr auf ein zukünftiges Datum gesetzt wird, kann es passieren, dass geplante Tasks vorzeitig ausgeführt werden!</em>

SystemzeitSetzen("20051008142211")  <em>; <a href="FileSetTime.htm#YYYYMMDD">Zeitstempel</a> übergeben (lokal, nicht UTC).</em>

SystemzeitSetzen(YYYYMMDDHHMISS)
<em>; Setzt die Systemzeit auf das angegebene Datum und Zeit.
; Der Aufrufer muss sicherstellen, dass der eingehende Parameter ein gültiger Zeitstempel ist
; (lokale Zeit, nicht UTC). Bei Erfolg wird eine Zahl ungleich 0 zurückgegeben.</em>
{
    <em>; Konvertiert für SystemzeitSetzen() den Parameter von lokale Zeit in UTC.</em>
    UTC_Delta -= A_NowUTC, Seconds  <em>; Sekunden sind aufgrund des Rundungsproblems genauer.</em>
    UTC_Delta := Round(-UTC_Delta/60)  <em>; Auf die nächste Minute runden.</em>
    YYYYMMDDHHMISS += UTC_Delta, Minutes  <em>; Offset zur Konvertierung auf UTC hinzufügen.</em>

    VarSetCapacity(SystemTime, 16, 0)  <em>; Diese Struktur besteht aus 8 UShort-Werte (d. h. 8 * 2 = 16).</em>

    StringLeft, Int, YYYYMMDDHHMISS, 4    <em>; YYYY (Jahr)</em>
    <a href="NumPut.htm">NumPut</a>(Int, SystemTime, 0, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 5, 2  <em>; MM (Monat des Jahrs, 1-12)</em>
    NumPut(Int, SystemTime, 2, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 7, 2  <em>; DD (Tag des Monats)</em>
    NumPut(Int, SystemTime, 6, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 9, 2  <em>; HH (Stunden im 24-Stunden-Format)</em>
    NumPut(Int, SystemTime, 8, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 11, 2 <em>; MI (Minuten)</em>
    NumPut(Int, SystemTime, 10, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 13, 2 <em>; SS (Sekunden)</em>
    NumPut(Int, SystemTime, 12, "UShort")

    return <strong>DllCall</strong>("SetSystemTime", Ptr, &amp;SystemTime)
}</pre>

<pre class="NoIndent"><em>/* <strong>Weitere Struktur-Befehle:</strong>

1) <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Script</a>: Ein DllCall()-Beispiel für die Erstellung einer Netzwerkverbindung
zu einem TCP/IP-Servers und von dort Daten empfangen werden können.

2) Das Betriebssystem besitzt Standard-Fensterdialoge zum Auswählen von Farben, Schriftarten oder Icons.
Solche Fensterdialoge verwenden Strukturen und werden in <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a> demonstriert.

*/</em></pre>

<pre id="ExTaskbar" class="NoIndent"><em>/*
  Beispiel: Entfernt mit COM vorübergehend das aktive Fenster von der Taskleiste.

  Methoden in der VTable der <a href="http://msdn.microsoft.com/en-us/library/bb774652.aspx">ITaskbarList</a>:
    IUnknown:
      0 QueryInterface  -- verwendet stattdessen <a href="ComObjQuery.htm">ComObjQuery</a>
      1 AddRef          -- verwendet stattdessen <a href="ObjAddRef.htm">ObjAddRef</a>
      2 Release         -- verwendet stattdessen <a href="ObjAddRef.htm">ObjRelease</a>
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Erstellt ein TaskbarList-Objekt und speichert dessen Adresse in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

activeHwnd := WinExist("A")

DllCall(vtable(tbl,3), "ptr", tbl)                     <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774650.aspx">HrInit</a>()</em>
DllCall(vtable(tbl,5), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
DllCall(vtable(tbl,4), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

<em>; Nicht-Dispatch-Objekte müssen immer manuell freigegeben werden.</em>
ObjRelease(tbl)

vtable(ptr, n) {
    <em>; NumGet(ptr+0) gibt die Adresse der virtuellen Funktionstabelle
    ; des Objekts zurück (kurz: vtable). Der Rest des Ausdrucks ermittelt
    ; die Adresse der n-ten Funktionsadresse von der vtable.</em>
    return NumGet(NumGet(ptr+0), n*A_PtrSize)
}
</pre>

</body>
</html>
