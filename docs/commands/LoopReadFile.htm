<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Loop (Dateiinhalt)</title>
<meta name="keywords" content="Befehl, Ablaufsteuerung, Datei, Schleife">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28224374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<script src="../navbar/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(1);</script>


<h1>Loop (Dateiinhalt)</h1>

<p>Ermittelt nacheinander die Zeilen einer Textdatei (besser als <a href="FileReadLine.htm">FileReadLine</a>).</p>

<pre class="Syntax">Loop, Read, Eingabedatei [, Ausgabedatei]</pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Read</td>
    <td width="85%">Dieser Parameter muss das Wort READ sein.</td>
  </tr>
  <tr>
    <td>Eingabedatei</td>
    <td>Der Name der Textdatei, die sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis befindet, solange kein absoluter Pfad angegeben ist. Windows- und Unix-Formate werden unterst&uuml;tzt, d. h. die Zeilen einer Datei k&ouml;nnen mit CR-LF-Paaren (`r`n) oder nur mit LF-Zeichen (`n) enden.</td>
  </tr>
  <tr>
    <td>Ausgabedatei</td>
    <td><p>(Optional) Der Name der Datei, die w&auml;hrend der Schleife offen bleibt und sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis befindet, solange kein absoluter Pfad angegeben ist.</p>
      <p>Innerhalb der Schleife kann der Befehl <a href="FileAppend.htm">FileAppend</a> mit nur einem Parameter (der zu schreibende Text) verwendet werden, um der besonderen Datei den Text anzuf&uuml;gen. Das Anf&uuml;gen des Textes auf diese Weise ist besser als <a href="FileAppend.htm">FileAppend</a> mit dem zweiten Parameter, weil die Datei nicht erst bei jeder Operation geschlossen und neu ge&ouml;ffnet werden muss. Der Benutzer sollte nicht vergessen, ein LF-Zeichen (`n) je nach Bedarf an dem Text anzuf&uuml;gen.</p>
      <p>Die Datei wird nicht ge&ouml;ffnet, wenn nichts zu schreiben ist. Das passiert, wenn die Schleife keinen Durchlauf hat oder nie den Befehl <a href="FileAppend.htm">FileAppend</a> verwendet.</p>
      <p><strong>Bin&auml;rmodus:</strong> Um den Text im Bin&auml;rmodus anzuf&uuml;gen, stellt ein Sternchen vor dem Dateinamen. Dadurch wird jedes LF-Zeichen (`n) zu einem einzelnen Zeilenvorschub (LF) anstelle des Windows-Standards CR + LF. Zum Beispiel: <strong>*</strong>C:\Eigene Unix-Datei.txt. Selbst ohne Sternchen wird der Bin&auml;rmodus automatisch aktiviert, wenn <a href="FileAppend.htm">FileAppend</a> das erste Mal dazu verwendet wird, CR-LF-Paare (`r` n) zu schreiben.</p>
      <p><strong>Standard-Ausgabe (stdout):</strong> Enth&auml;lt die <em>Ausgabedatei</em> nur ein Sternchen (*), dann wird jeder beliebige Text zur Standard-Ausgabe (stdout) von <a href="FileAppend.htm">FileAppend</a> gesendet. Solche Texte k&ouml;nnen zu einer Datei oder EXE-Datei weitergeleitet werden oder von <a href="_ErrorStdOut.htm">originellen Texteditoren</a> abgefangen werden. Siehe <a href="FileAppend.htm">FileAppend</a> f&uuml;r mehr Details.</p>
      <p><strong>Gesch&uuml;tzte Kommas</strong>: Im Gegensatz zum letzten Parameter der meisten anderen Befehle m&uuml;ssen Kommas in der <em>Ausgabedatei</em> gesch&uuml;tzt werden (`,).</p></td>
  </tr>
</table>

<h3>Bemerkungen</h3>
<p>Eine dateilesende Schleife ist n&uuml;tzlich, wenn der Benutzer nacheinander jede Zeile in einer Text-Datei bearbeiten will. Sie ist besser als <a href="FileReadLine.htm">FileReadLine</a>, weil: 1) die Datei die ganze Zeit offen bleibt und 2) die Datei nicht jedes Mal neu eingelesen werden muss, um die gew&uuml;nschte Zeilennummer zu finden.</p>
<p><a name="LoopReadLine"></a>Die interne Variable <strong>A_LoopReadLine</strong> existiert in jeder dateilesenden Schleife. Sie enth&auml;lt den Inhalt der aktuellen Zeile, ohne CR- und LF-Zeichen (`r`n), die das Zeilenende markieren. Wenn eine innere dateilesende Schleife durch eine &auml;u&szlig;ere dateilesende Schleife eingeschlossen ist, dann hat die Zeile innerhalb der Schleife Vorrang.</p>
<p>Zeilen mit bis zu 65.534 Zeichen k&ouml;nnen gelesen werden. Wenn die L&auml;nge einer Zeile &uuml;berschritten wird, dann werden die restlichen Zeichen im n&auml;chsten Schleifendurchlauf eingelesen.</p>
<p><a href="StringSplit.htm">StringSplit</a> oder <a href="LoopParse.htm">Parsing-Schleife</a> wird h&auml;ufig in einer dateilesenden Schleife verwendet, um den Inhalt jeder Zeile in der <em>Eingabedatei</em> zu parsen. Wenn zum Beispiel jede Zeile in der <em>Eingabedatei</em> mehrere tab-getrennte Felder enth&auml;lt, dann k&ouml;nnen diese Felder wie in diesem Beispiel einzeln abgerufen werden:</p>
<pre>Loop, read, C:\Database Export.txt
{
    Loop, parse, A_LoopReadLine, %A_Tab%
    {
        MsgBox, Feldnummer %A_Index% ist %A_LoopField%.
    }
}</pre>
<p>Um die ganze Datei in eine Variable zu laden, verwendet <a href="FileRead.htm">FileRead</a>, weil dieser Befehl besser als eine Schleife ist (besonders f&uuml;r gro&szlig;e Dateien).</p>
<p>Damit mehrere Dateien gleichzeitig offen sein k&ouml;nnen, verwendet DllCall() wie in <a href="DllCall.htm#file">diesem Beispiel</a>.</p>
<p>Siehe <a href="Loop.htm">Loop</a> f&uuml;r Informationen &uuml;ber <a href="Block.htm">Blocks</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index (die gibt es in jeder Schleifenvariante).</p>
<p>Um die Kodierung einer Datei ohne Bytereihenfolge-Markierung zu kontrollieren, verwendet <a href="FileEncoding.htm">FileEncoding</a>.</p>

<h3>Verwandte Befehle</h3>
<p><a href="FileEncoding.htm">FileEncoding</a>, <a href="FileOpen.htm">FileOpen</a>/<a href="../objects/File.htm">Datei-Objekt</a>, <a href="FileRead.htm">FileRead</a>, <a href="FileReadLine.htm">FileReadLine</a>, <a href="FileAppend.htm">FileAppend</a>, <a href="Sort.htm">Sort</a>, <a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blocks, </a><a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>

<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel #1: Nur Zeilen in der ersten Datei, die das Wort FAMILY enthalten, werden in die zweite Datei geschrieben.
; Hebt die Kommentierung der ersten Zeile auf, um die Datei zu &uuml;berschreiben.
;FileDelete, C:\Dokumente\Familienadressen.txt</em>

Loop, read, C:\Dokumente\Adressliste.txt, C:\Dokumente\Familienadressen.txt
{
    IfInString, A_LoopReadLine, Familie, FileAppend, %A_LoopReadLine%`n
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Ermittelt die letzte Zeile einer Text-Datei.</em>
Loop, read, C:\Logdatei.txt
    letzteZeile := A_LoopReadLine  <em>; Wenn die Schleife endet, dann wird diese Variable die letzte Zeile beinhalten.</em></pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Ein funktionierendes Script, das versucht, alle FTP- und HTTP-URLs
; aus einer Text- oder HTML-Datei zu extrahieren:</em>
FileSelectFile, Quelldatei, 3,, Text- oder HTML-Datei zur Analyse ausw&auml;hlen:
If Quelldatei =
    Return  <em>; In diesem Fall beenden.</em>

SplitPath, Quelldatei,, Quelldateipfad,, Quelldateiname
Zieldatei = %Quelldateipfad%\%Quelldateiname% Extrahierte Links.txt

IfExist, %Zieldatei%
{
    MsgBox, 4,, Vorhandene Datei &uuml;berschreiben? Dr&uuml;cke Nein, um die Links anzuf&uuml;gen.`n`nDATEI: %Zieldatei%
    IfMsgBox, Yes
        FileDelete, %Zieldatei%
}

Linkz&auml;hlung = 0
Loop, read, %Quelldatei%, %Zieldatei%
{
    URLSuchstring = %A_LoopReadLine%
    Gosub, URLSuche
}
MsgBox %Linkz&auml;hlung% Links wurden gefunden und in "%Zieldatei%" geschrieben.
Return


URLSuche:
<em>; Es wird dieser bestimmte Weg verwendet, weil einige URLs andere URLs eingebettet haben:</em>
StringGetPos, URLStart1, URLSuchstring, http://
StringGetPos, URLStart2, URLSuchstring, ftp://
StringGetPos, URLStart3, URLSuchstring, www.

<em>; Findet die Startposition ganz links:</em>
URLStart = %URLStart1%  <em>; Standardwert setzen.</em>
Loop
{
    <em>; Es hilft der Performance (zumindest in einem Script mit vielen Variablen), wenn </em>
    <em>; "URLStart%A_Index%" nur einmal aufgel&ouml;st wird:</em>
    ArrayElement := URLStart%A_Index%
    If ArrayElement =  <em>; Ende des Arrays erreicht.</em>
        break
    If ArrayElement = -1  <em>; Dieses Element ist disqualifiziert.</em>
        continue
    If URLStart = -1
        URLStart = %ArrayElement%
    Else <em>; URLStart beinhaltet eine g&uuml;ltige Position,  also mit ArrayElement vergleichen.</em>
    {
        If ArrayElement &lt;&gt; -1
            If ArrayElement &lt; %URLStart%
                URLStart = %ArrayElement%
    }
}

If URLStart = -1  <em>; Keine URLs im URLSuchstring.</em>
    Return

<em>; Ansonsten diese URL extrahieren:</em>
StringTrimLeft, URL, URLSuchstring, %URLStart%  <em>; Beginnenden/irrelevanten Teil auslassen.</em>
Loop, parse, URL, %A_Tab%%A_Space%&lt;&gt;  <em>; erstes Leer-, Tab- oder Winkelzeichen finden.</em>
{
    URL = %A_LoopField%
    break  <em>; z. B. nur einen Schleifendurchlauf ausf&uuml;hren, um das erste "Feld" zu holen.</em>
}
<em>; Wenn die oben genannte Schleife keine Iteration hat, weil keine Endzeichen gefunden wurden,
; lasse den Inhalt der URL-Variable unber&uuml;hrt.</em>

<em>; Wenn die URL mit Anf&uuml;hrungszeichen endet, dann werden sie entfernt.  Erstmal wird StringReplace verwendet, aber
; beachtet, dass Anf&uuml;hrungszeichen durchaus innerhalb der URLs g&uuml;ltig sind, dadurch
; k&ouml;nnen sie zerst&ouml;rt werden:</em>
StringReplace, SaubereURL, URL, ",, All
FileAppend, %SaubereURL%`n
Linkz&auml;hlung += 1

<em>; Nachschauen, ob noch andere URLs in dieser Zeile vorhanden sind:</em>
StringLen, ZeichenAuslassen, URL
ZeichenAuslassen += %URLStart%
StringTrimLeft, URLSuchstring, URLSuchstring, %ZeichenAuslassen%
Gosub, URLSuche  <em>; Rekursiver Aufruf auf sich selbst.</em>
Return</pre>

</body>
</html>