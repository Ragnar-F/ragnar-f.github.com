<!DOCTYPE HTML>
<html>
<head>
<title>Loop (Dateiinhalt)</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Loop (Dateiinhalt)</h1>

<p>Ermittelt nacheinander die Zeilen einer Textdatei (leistungsfähiger als <a href="FileReadLine.htm">FileReadLine</a>).</p>

<pre class="Syntax">Loop, Read, Eingabedatei [, Ausgabedatei]</pre>
<h3>Parameter</h3>
<dl>

  <dt>Read</dt>
  <dd><p>Dieser Parameter muss das Wort READ sein.</p></dd>

  <dt>Eingabedatei</dt>
  <dd><p>Name der Textdatei, die sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis befindet, solange kein absoluter Pfad angegeben ist. Windows- und Unix-Formate werden unterstützt. Das heißt, dass die Zeilen einer Datei sowohl mit CR-LF-Paaren (`r`n) als auch mit LF-Zeichen (`n) enden können.</p></dd>

  <dt>Ausgabedatei</dt>
  <dd><p>(Optional) Name der Datei, die während der Schleife offen bleibt und sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis befindet, solange kein absoluter Pfad angegeben ist.</p>
      <p>Innerhalb der Schleife kann der Befehl <a href="FileAppend.htm">FileAppend</a> mit nur einem Parameter (der zu schreibende Text) verwendet werden, um der speziellen Datei den Text anzufügen. Das Anfügen des Textes auf diese Weise ist besser als <a href="FileAppend.htm">FileAppend</a> mit dem zweiten Parameter, weil die Datei nicht erst bei jeder Operation geschlossen und neu geöffnet werden muss. Vergesst nicht, ein LF-Zeichen (`n) nach dem Text einzufügen, falls notwendig.</p>
      <p>Die Datei wird nicht geöffnet, wenn nichts zu schreiben ist. Das passiert, wenn die Schleife nicht durchlaufen wird oder nie den Befehl <a href="FileAppend.htm">FileAppend</a> verwendet.</p>
      <p><strong>Binärmodus</strong>: Um den Text stattdessen im Binärmodus anzufügen, stellt ein Sternchen vor dem Dateinamen. Dadurch wird jedes LF-Zeichen (`n) als einzelner Zeilenvorschub (LF) geschrieben, anstatt standardmäßig CR+LF. Zum Beispiel: <code><strong>*</strong>C:\Meine Unix-Datei.txt</code>. Selbst ohne Sternchen wird der Binärmodus automatisch wirksam, wenn <a href="FileAppend.htm">FileAppend</a> das <u>erste</u> Mal in einer Schleife dazu verwendet wird, CR-LF-Paare (`r`n) zu schreiben.</p>      
      <p><strong>Standardausgabe (stdout)</strong>: Enthält <em>Ausgabedatei</em> nur ein Sternchen (*), wird jeder beliebige Text, der von <a href="FileAppend.htm">FileAppend</a> geschrieben wird, zur Standardausgabe (stdout) gesendet. Solche Texte können an eine Datei oder EXE-Datei weitergeleitet oder von <a href="_ErrorStdOut.htm">originellen Texteditoren</a> abgefangen werden. Siehe <a href="FileAppend.htm">FileAppend</a> für mehr Details.</p>
      <p><strong>Kommas mit einem Escapezeichen</strong>: Im Gegensatz zum letzten Parameter der meisten anderen Befehle müssen Kommas in der <em>Ausgabedatei</em> mit einem Escapezeichen versehen werden (`,).</p></dd>

</dl>

<h3>Bemerkungen</h3>
<p>Eine dateilesende Schleife ist nützlich, wenn jede Zeile in einer Textdatei nacheinander bearbeitet werden soll. Diese Schleife ist leistungsfähiger als <a href="FileReadLine.htm">FileReadLine</a>, weil: 1) die Datei erstens bei der Operation die ganze Zeit offen bleiben kann; und 2) die Datei nicht jedes Mal neu eingelesen werden, um die gewünschte Zeilennummer zu finden.</p>
<p><a name="LoopReadLine"></a>Die interne Variable <strong>A_LoopReadLine</strong> existiert in jeder dateilesenden Schleife. Sie enthält den Inhalt der aktuellen Zeile ohne CR-LF-Paar (`r`n), das das Zeilenende markiert. Wenn eine innere dateilesende Schleife von einer äußeren dateilesenden Schleife umschlossen ist, wird die Zeile von der innersten Schleife Vorrang haben.</p>
<p>Es können Zeilen gelesen werden, die bis zu 65.534 Zeichen lang sind. Falls diese Länge überschritten wird, werden die restlichen Zeichen beim nächsten Schleifendurchlauf eingelesen.</p>
<p><a href="StringSplit.htm">StringSplit</a> oder <a href="LoopParse.htm">Parsing-Schleife</a> wird häufig in einer dateilesenden Schleife verwendet, um den Inhalt jeder Zeile von der <em>Eingabedatei</em> zu parsen. Wenn zum Beispiel jede Zeile von der <em>Eingabedatei</em> aus mehreren tab-getrennten Feldern besteht, dann können diese Felder wie im folgenden Beispiel einzeln abgerufen werden:</p>
<pre>Loop, read, C:\Datenbank-Export.txt
{
    Loop, parse, A_LoopReadLine, %A_Tab%
    {
        MsgBox, Feldnummer %A_Index% ist %A_LoopField%.
    }
}</pre>
<p>Um die komplette Datei in eine Variable zu laden, sollte <a href="FileRead.htm">FileRead</a> verwendet werden, weil dieser Befehl leistungsfähiger als eine Schleife ist (besonders bei großen Dateien).</p>
<p>Damit mehrere Dateien gleichzeitig offen sein können, kann DllCall() wie in <a href="DllCall.htm#file">diesem Beispiel</a> verwendet werden.</p>
<p>Auf der <a href="Loop.htm">Loop</a>-Seite können Informationen zu <a href="Block.htm">Blöcke</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index gefunden werden (weil diese in jeder Schleifenvariante vorkommen).</p>
<p>Um die Kodierung einer Datei ohne Bytereihenfolge-Markierung zu bestimmen, sollte <a href="FileEncoding.htm">FileEncoding</a> verwendet werden.</p>

<h3>Siehe auch</h3>
<p><a href="FileEncoding.htm">FileEncoding</a>, <a href="FileOpen.htm">FileOpen</a>/<a href="../objects/File.htm">Datei-Objekt</a>, <a href="FileRead.htm">FileRead</a>, <a href="FileReadLine.htm">FileReadLine</a>, <a href="FileAppend.htm">FileAppend</a>, <a href="Sort.htm">Sort</a>, <a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blöcke</a>, <a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>

<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel #1: Es werden nur die Zeilen der ersten Datei, die das Wort FAMILY enthalten,
; in die zweite Datei geschrieben.
; Hebt die Kommentierung der ersten Zeile auf, um die Datei zu überschreiben,
; anstatt die Zeilen an eine vorhandene Datei anzufügen.
;FileDelete, C:\Dokumente\Familienadressen.txt</em>

Loop, read, C:\Dokumente\Adressliste.txt, C:\Dokumente\Familienadressen.txt
{
    IfInString, A_LoopReadLine, Familie, FileAppend, %A_LoopReadLine%`n
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Ermittelt die letzte Zeile einer Textdatei.</em>
Loop, read, C:\Logdatei.txt
    letzteZeile := A_LoopReadLine  <em>; Sobald die Schleife endet, wird diese Variable die letzte Zeile beinhalten.</em></pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Ein funktionierendes Script, das versucht, alle FTP- und HTTP-URLs
; aus einer Text- oder HTML-Datei zu extrahieren:</em>
FileSelectFile, Quelldatei, 3,, Text- oder HTML-Datei zur Analyse auswählen:
If Quelldatei =
    Return  <em>; In diesem Fall beenden.</em>

SplitPath, Quelldatei,, Quelldateipfad,, Quelldateiname
Zieldatei = %Quelldateipfad%\%Quelldateiname% Extrahierte Links.txt

IfExist, %Zieldatei%
{
    MsgBox, 4,, Vorhandene Datei überschreiben? Drücke Nein, um die Links anzufügen.`n`nDATEI: %Zieldatei%
    IfMsgBox, Yes
        FileDelete, %Zieldatei%
}

Linkanzahl = 0
Loop, read, %Quelldatei%, %Zieldatei%
{
    URLSuchstring = %A_LoopReadLine%
    Gosub, URLSuche
}
MsgBox %Linkanzahl% Links wurden gefunden und in "%Zieldatei%" geschrieben.
Return


URLSuche:
<em>; Das wird auf diese Weise gemacht, weil einige URLs andere URLs eingebettet haben:</em>
StringGetPos, URLStart1, URLSuchstring, http://
StringGetPos, URLStart2, URLSuchstring, ftp://
StringGetPos, URLStart3, URLSuchstring, www.

<em>; Findet die Startposition ganz links:</em>
URLStart = %URLStart1%  <em>; Standardwert setzen.</em>
Loop
{
    <em>; Es hilft der Performance (zumindest in einem Script mit vielen Variablen), wenn</em>
    <em>; "URLStart%A_Index%" nur einmal aufgelöst wird:</em>
    ArrayElement := URLStart%A_Index%
    If ArrayElement =  <em>; Ende des <a href="../misc/Arrays.htm#pseudo">Pseudo-Arrays</a> erreicht.</em>
        break
    If ArrayElement = -1  <em>; Dieses Element fällt weg.</em>
        continue
    If URLStart = -1
        URLStart = %ArrayElement%
    Else <em>; URLStart beinhaltet eine gültige Position, also mit ArrayElement vergleichen.</em>
    {
        If ArrayElement &lt;&gt; -1
            If ArrayElement &lt; %URLStart%
                URLStart = %ArrayElement%
    }
}

If URLStart = -1  <em>; Keine URLs im URLSuchstring.</em>
    Return

<em>; Ansonsten diese URL extrahieren:</em>
StringTrimLeft, URL, URLSuchstring, %URLStart%  <em>; Beginnenden/irrelevanten Teil auslassen.</em>
Loop, parse, URL, %A_Tab%%A_Space%&lt;&gt;  <em>; Erstes Leer-, Tab- oder Winkelzeichen finden (falls vorhanden).</em>
{
    URL = %A_LoopField%
    break  <em>; Nur einen Schleifendurchlauf ausführen, um das erste "Feld" zu holen.</em>
}
<em>; Wenn die obige Schleife keine Iteration hat, weil keine Endzeichen gefunden wurden,
; bleibt der Inhalt der URL-Variable unberührt.</em>

<em>; Wenn die URL mit einem Anführungszeichen endet, wird sie entfernt.  Fürs Erste wird StringReplace verwendet, aber
; beachtet, dass Anführungszeichen durchaus innerhalb der URLs gültig sind, folglich 
; könnte die URL dadurch unbrauchbar gemacht werden:</em>
StringReplace, SaubereURL, URL, ",, All
FileAppend, %SaubereURL%`n
Linkanzahl += 1

<em>; Nachschauen, ob noch andere URLs in dieser Zeile vorhanden sind:</em>
StringLen, ZeichenAuslassen, URL
ZeichenAuslassen += %URLStart%
StringTrimLeft, URLSuchstring, URLSuchstring, %ZeichenAuslassen%
Gosub, URLSuche  <em>; Rekursiver Aufruf auf sich selbst.</em>
Return</pre>

</body>
</html>
