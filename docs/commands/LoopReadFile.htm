<!DOCTYPE HTML>
<html>
<head>
<title>Loop (Dateiinhalt)</title>
<meta name="keywords" content="Befehl, Ablaufsteuerung, Datei, Schleife">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Loop (Dateiinhalt)</h1>
      <p>Ermittelt nacheinander die Zeilen einer Textdatei (leistungsf&auml;higer als <a href="FileReadLine.htm">FileReadLine</a>).</p>
      <pre class="Syntax">Loop, Read, Eingabedatei [, Ausgabedatei]</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Read</td>
          <td style="width: 85%;">Dieser Parameter muss das Wort READ sein.</td>
        </tr>
        <tr>
          <td>Eingabedatei</td>
          <td>Der Name der Textdatei, die sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis befindet, solange kein absoluter Pfad angegeben ist. Windows- und Unix-Formate werden unterst&uuml;tzt, d. h. die Zeilen einer Datei k&ouml;nnen mit CR-LF-Paaren (`r`n) oder nur mit LF-Zeichen (`n) enden.</td>
        </tr>
        <tr>
          <td>Ausgabedatei</td>
          <td><p>(Optional) Der Name der Datei, die w&auml;hrend der Schleife offen bleibt und sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis befindet, solange kein absoluter Pfad angegeben ist.</p>
            <p>Innerhalb der Schleife kann der Befehl <a href="FileAppend.htm">FileAppend</a> mit nur einem Parameter (der zu schreibende Text) verwendet werden, um der speziellen Datei den Text anzuf&uuml;gen. Das Anf&uuml;gen des Textes auf diese Weise ist besser als <a href="FileAppend.htm">FileAppend</a> mit dem zweiten Parameter, weil die Datei nicht erst bei jeder Operation geschlossen und neu ge&ouml;ffnet werden muss. Vergesst nicht, ein LF-Zeichen (`n) nach dem Text einzuf&uuml;gen, falls notwendig.</p>
            <p>Die Datei wird nicht ge&ouml;ffnet, wenn nichts zu schreiben ist. Das passiert, wenn die Schleife nicht durchlaufen wird oder nie den Befehl <a href="FileAppend.htm">FileAppend</a> verwendet.</p>
            <p><strong>Bin&auml;rmodus:</strong> Um den Text im Bin&auml;rmodus anzuf&uuml;gen, muss ein Sternchen vor dem Dateinamen gesetzt werden. Dadurch wird jedes LF-Zeichen (`n) als einzelner Zeilenvorschub (LF) geschrieben, anstatt standardm&auml;&szlig;ig von Windows als CR + LF. Zum Beispiel: <strong>*</strong>C:\Eigene Unix-Datei.txt. Selbst ohne Sternchen wird der Bin&auml;rmodus automatisch wirksam, wenn <a href="FileAppend.htm">FileAppend</a> das erste Mal in einer Schleife dazu verwendet wird, CR-LF-Paare (`r`n) zu schreiben.</p>
            <p><strong>Standardausgabe (stdout):</strong> Enth&auml;lt <em>Ausgabedatei</em> nur ein Sternchen (*), wird jeder beliebige Text, der von <a href="FileAppend.htm">FileAppend</a> geschrieben wird, zur Standardausgabe (stdout) gesendet. Solche Texte k&ouml;nnen an eine Datei oder EXE-Datei weitergeleitet oder von <a href="_ErrorStdOut.htm">originellen Texteditoren</a> abgefangen werden. Siehe <a href="FileAppend.htm">FileAppend</a> f&uuml;r mehr Details.</p>
            <p><strong>Gesch&uuml;tzte Kommas</strong>: Im Gegensatz zum letzten Parameter der meisten anderen Befehle m&uuml;ssen Kommas in der <em>Ausgabedatei</em> gesch&uuml;tzt werden (`,).</p></td>
        </tr>
      </table>
      <h3>Bemerkungen</h3>
      <p>Eine dateilesende Schleife ist n&uuml;tzlich, wenn jede Zeile in einer Textdatei nacheinander bearbeitet werden soll. Diese Schleife ist leistungsf&auml;higer als <a href="FileReadLine.htm">FileReadLine</a>, weil die Datei erstens bei der Operation die ganze Zeit offen bleiben kann, und zweitens nicht jedes Mal neu eingelesen werden, um die gew&uuml;nschte Zeilennummer zu finden.</p>
      <p id="LoopReadLine">Die interne Variable <strong>A_LoopReadLine</strong> existiert in jeder dateilesenden Schleife. Sie enth&auml;lt den Inhalt der aktuellen Zeile ohne CR-LF-Paar (`r`n), das das Zeilenende markiert. Wenn eine innere dateilesende Schleife von einer &auml;u&szlig;eren dateilesenden Schleife umschlossen ist, wird die Zeile von der innersten Schleife Vorrang haben.</p>
      <p>Es k&ouml;nnen Zeilen mit einer L&auml;nge von bis zu 65.534 Zeichen eingelesen werden. Falls diese L&auml;nge &uuml;berschritten wird, werden die restlichen Zeichen beim n&auml;chsten Schleifendurchlauf eingelesen.</p>
      <p><a href="StringSplit.htm">StringSplit</a> oder <a href="LoopParse.htm">Parsing-Schleife</a> wird h&auml;ufig in einer dateilesenden Schleife verwendet, um den Inhalt jeder Zeile von der <em>Eingabedatei</em> zu parsen. Wenn zum Beispiel jede Zeile von der <em>Eingabedatei</em> aus mehreren tab-getrennten Feldern besteht, dann k&ouml;nnen diese Felder wie im folgenden Beispiel einzeln abgerufen werden:</p>
      <pre>Loop, read, C:\Datenbank-Export.txt
{
    Loop, parse, A_LoopReadLine, %A_Tab%
    {
        MsgBox, Feldnummer %A_Index% ist %A_LoopField%.
    }
}</pre>
      <p>Um die komplette Datei in eine Variable zu laden, sollte <a href="FileRead.htm">FileRead</a> verwendet werden, weil dieser Befehl leistungsf&auml;higer als eine Schleife ist (besonders bei gro&szlig;en Dateien).</p>
      <p>Damit mehrere Dateien gleichzeitig offen sein k&ouml;nnen, kann DllCall() wie in <a href="DllCall.htm#file">diesem Beispiel</a> verwendet werden.</p>
      <p>Auf der <a href="Loop.htm">Loop</a>-Seite k&ouml;nnen Informationen zu <a href="Block.htm">Blocks</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index gefunden werden (weil diese in jeder Schleifenvariante vorkommen).</p>
      <p>Um die Kodierung einer Datei ohne Bytereihenfolge-Markierung zu bestimmen, sollte <a href="FileEncoding.htm">FileEncoding</a> verwendet werden.</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="FileEncoding.htm">FileEncoding</a>, <a href="FileOpen.htm">FileOpen</a>/<a href="../objects/File.htm">File-Objekt</a>, <a href="FileRead.htm">FileRead</a>, <a href="FileReadLine.htm">FileReadLine</a>, <a href="FileAppend.htm">FileAppend</a>, <a href="Sort.htm">Sort</a>, <a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blocks, </a><a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>
      <h3>Beispiele</h3>
      <pre class="NoIndent"><em>; Beispiel #1: Es werden nur die Zeilen der ersten Datei, die das Wort FAMILY enthalten,
; in die zweite Datei geschrieben.
; Hebt die Kommentierung der ersten Zeile auf, um die Datei zu &uuml;berschreiben,
; anstatt die Zeilen an eine vorhandene Datei anzuf&uuml;gen.
;FileDelete, C:\Dokumente\Familienadressen.txt</em>

Loop, read, C:\Dokumente\Adressliste.txt, C:\Dokumente\Familienadressen.txt
{
    IfInString, A_LoopReadLine, Familie, FileAppend, %A_LoopReadLine%`n
}</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #2: Ermittelt die letzte Zeile einer Textdatei.</em>
Loop, read, C:\Logdatei.txt
    letzteZeile := A_LoopReadLine  <em>; Sobald die Schleife endet, wird diese Variable die letzte Zeile beinhalten.</em></pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #3: Ein funktionierendes Script, das versucht, alle FTP- und HTTP-URLs
; aus einer Text- oder HTML-Datei zu extrahieren:</em>
FileSelectFile, Quelldatei, 3,, Text- oder HTML-Datei zur Analyse ausw&auml;hlen:
If Quelldatei =
    Return  <em>; In diesem Fall beenden.</em>

SplitPath, Quelldatei,, Quelldateipfad,, Quelldateiname
Zieldatei = %Quelldateipfad%\%Quelldateiname% Extrahierte Links.txt

IfExist, %Zieldatei%
{
    MsgBox, 4,, Vorhandene Datei &uuml;berschreiben? Dr&uuml;cke Nein, um die Links anzuf&uuml;gen.`n`nDATEI: %Zieldatei%
    IfMsgBox, Yes
        FileDelete, %Zieldatei%
}

Linkanzahl = 0
Loop, read, %Quelldatei%, %Zieldatei%
{
    URLSuchstring = %A_LoopReadLine%
    Gosub, URLSuche
}
MsgBox %Linkanzahl% Links wurden gefunden und in "%Zieldatei%" geschrieben.
Return


URLSuche:
<em>; Das wird auf diese Weise gemacht, weil einige URLs andere URLs eingebettet haben:</em>
StringGetPos, URLStart1, URLSuchstring, http://
StringGetPos, URLStart2, URLSuchstring, ftp://
StringGetPos, URLStart3, URLSuchstring, www.

<em>; Findet die Startposition ganz links:</em>
URLStart = %URLStart1%  <em>; Standardwert setzen.</em>
Loop
{
    <em>; Es hilft der Performance (zumindest in einem Script mit vielen Variablen), wenn </em>
    <em>; "URLStart%A_Index%" nur einmal aufgel&ouml;st wird:</em>
    ArrayElement := URLStart%A_Index%
    If ArrayElement =  <em>; Ende des Arrays erreicht.</em>
        break
    If ArrayElement = -1  <em>; Dieses Element f&auml;llt weg.</em>
        continue
    If URLStart = -1
        URLStart = %ArrayElement%
    Else <em>; URLStart beinhaltet eine g&uuml;ltige Position, also mit ArrayElement vergleichen.</em>
    {
        If ArrayElement &lt;&gt; -1
            If ArrayElement &lt; %URLStart%
                URLStart = %ArrayElement%
    }
}

If URLStart = -1  <em>; Keine URLs im URLSuchstring.</em>
    Return

<em>; Ansonsten diese URL extrahieren:</em>
StringTrimLeft, URL, URLSuchstring, %URLStart%  <em>; Beginnenden/irrelevanten Teil auslassen.</em>
Loop, parse, URL, %A_Tab%%A_Space%&lt;&gt;  <em>; Erstes Leer-, Tab- oder Winkelzeichen finden (falls vorhanden).</em>
{
    URL = %A_LoopField%
    break  <em>; Nur einen Schleifendurchlauf ausf&uuml;hren, um das erste "Feld" zu holen.</em>
}
<em>; Wenn die obige Schleife keine Iteration hat, weil keine Endzeichen gefunden wurden,
; bleibt der Inhalt der URL-Variable unber&uuml;hrt.</em>

<em>; Wenn die URL mit einem Anf&uuml;hrungszeichen endet, wird sie entfernt. F&uuml;rs Erste wird StringReplace verwendet, aber
; beachtet, dass Anf&uuml;hrungszeichen durchaus innerhalb der URLs g&uuml;ltig sind, folglich 
; k&ouml;nnte die URL dadurch unbrauchbar gemacht werden:</em>
StringReplace, SaubereURL, URL, ",, All
FileAppend, %SaubereURL%`n
Linkanzahl += 1

<em>; Nachschauen, ob noch andere URLs in dieser Zeile vorhanden sind:</em>
StringLen, ZeichenAuslassen, URL
ZeichenAuslassen += %URLStart%
StringTrimLeft, URLSuchstring, URLSuchstring, %ZeichenAuslassen%
Gosub, URLSuche  <em>; Rekursiver Aufruf auf sich selbst.</em>
Return</pre>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>