<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>RegExMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>RegExMatch() <span class="ver">[v1.0.45+]</span></h1>

<p>Bestimmt, ob ein String ein Muster enthält (regulärer Ausdruck).</p>

<pre class="Syntax">Fundposition := RegExMatch(Heuhaufen, NadelRegEx [, NichtZitierteAusgabevariable = "", Startposition = 1])</pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Fundposition</td>
    <td width="85%">RegExMatch() gibt die Position der <em>NadelRegEx</em> zurück, dass ganz links im <em>Heuhaufen</em>-String vorkommt. Position 1 ist das erste Zeichen. Eine 0 wird zurückgegeben, wenn das Muster nicht gefunden wird. Wenn ein Fehler auftritt (z. B. ein Syntaxfehler in der <em>NadelRegEx</em>), dann wird ein leerer String zurückgegeben und ErrorLevel auf einen <a href="#ErrorLevel">unten genannten</a> Wert anstelle von 0 gesetzt.</td>
  </tr>
  <tr>
    <td>Heuhaufen</td>
    <td>Der String, dessen Inhalt durchsucht wird.</td>
  </tr>
  <tr>
    <td>NadelRegEx</td>
    <td>Das zu suchende Muster, welches ein Perl-kompatibler regulärer Ausdruck (PCRE) ist. Die <a href="../misc/RegEx-QuickRef.htm">Optionen</a> des Musters (falls vorhanden) müssen am Anfang des Strings stehen, gefolgt von einer schließenden Klammer. Zum Beispiel wird das Muster "<span class="red">i)</span>abc.*123" die Abhängigkeit von der Groß- und Kleinschreibung deaktivieren und nach "abc", null oder mehr Zeichen und "123" suchen. Wenn keine Optionen vorhanden sind, dann ist ")" optional; zum Beispiel ist ")abc" gleichbedeutend mit "abc".</td>
  </tr>
  <tr>
    <td><span class="CommandSyntax">NichtZitierteAusgabevariable</span></td>
    <td><p><strong>Modus 1 (Standard):</strong> Der Name der <em>Ausgabevariable</em> ohne Anführungszeichen, in der der Teil vom <em>Heuhaufen</em> gespeichert wird, der dem gesamten Muster entsprach. Wenn das Muster nicht gefunden wird (also wenn die Funktion 0 zurückgibt), dann werden diese Variable und alle Array-Elemente darunter leer gemacht.</p>
      <p><a name="Array"></a>Wenn <a href="../misc/RegEx-QuickRef.htm#subpat">Teilausdrücke</a> in der <em>NadelRegEx</em> vorhanden sind, dann werden ihre Übereinstimmungen in einem <a href="../misc/Arrays.htm">Array</a> mit dem Basisnamen <em>Ausgabevariable</em> gespeichert. Wenn zum Beispiel die Variable <em>Match</em> heißt, dann wird der Teilstring, der dem ersten Teilausdruck entspricht, in <em>Match1</em> gespeichert, der Zweite wird in <em>Match2</em> gespeichert und so weiter. Die Ausnahme bilden <a href="#NamedSubPat">benannte Teilausdrücke</a>: sie werden mit einem Namen anstatt einer Zahl gespeichert. Zum Beispiel: der Teilstring, der mit dem benannten Teilausdruck <em>(?P<Year>\d{4})</em> übereinstimmt, wird in <em>MatchYear</em> gespeichert. Wenn keine Übereinstimmung eines bestimmten Teilausdrucks erfolgt (oder die Funktion 0 zurückgibt), dann wird die entsprechende Variable leer gemacht.</p>
      <p>Um einen globalen anstelle eines lokalen Arrays innerhalb einer <a href="../Functions.htm">Funktion</a> zu erstellen, <a href="../Functions.htm#Global">deklariert</a> den Basisnamen des Arrays (z. B. Match) vorher als globale Variable. Das Gegenteil davon gilt für <a href="../Functions.htm#AssumeGlobal">global-angesehene</a> Funktionen.</p>
      <p><a name="PosMode"></a><strong>Modus 2 (Position und Länge):</strong> Wenn der Großbuchstabe P in den Optionen von RegEx vorhanden ist (z. B. "<span class="red">P)</span>abc.*123"), dann wird die <em>Länge</em> der gesamten Musterübereinstimmung in <em>Ausgabevariable</em> gespeichert (oder 0, wenn keine Übereinstimmung). Wenn <a href="../misc/RegEx-QuickRef.htm#subpat">Teilausdrücke</a> vorhanden sind, dann wird deren Position und Länge in zwei Arrays gespeichert: <em>AusgabevariablePos</em> und <em>AusgabevariableLen</em>. Wenn zum Beispiel der Basisname der Variable <em>Match</em> ist, dann dann wird die <em>Position</em> der ersten Übereinstimmung eines Teilausdrucks in <em>MatchPos1</em> gespeichert und die Länge in <em>MatchLen1</em> (sie sind leer, wenn der Teilausdruck nicht übereinstimmt oder die Funktion 0 zurückgibt) .  Die Ausnahme bilden <a href="#NamedSubPat">benannte Teilausdrücke</a>: sie werden mit einem Namen anstatt einer Zahl gespeichert (z. B. <em>MatchPosYear</em> und <em>MatchLenYear</em>).</p>
    </td>
  </tr>
  <tr>
    <td>Startposition</td>
    <td><p>Wenn die <em>Startposition</em> weggelassen wird, dann standardmäßig eine 1 (der Anfang vom <em>Heuhaufen</em>). Verwendet andernfalls eine 2, um beim zweiten Zeichen beginnen, eine 3, um beim Dritten zu beginnen und so weiter. Wenn die <em>Startposition</em> die Länge des <em>Heuhaufens</em> überschreitet, dann beginnt die Suche bei einem leeren String, welcher sich am Ende des <em>Heuhaufens</em> befindet (ergibt typischerweise keine Übereinstimmung).</p>
      <p>Wenn die <em>Startposition</em> kleiner als 1 ist, dann ist es das Offset vom Ende des <em>Heuhaufens</em>. Zum Beispiel beginnt 0 beim letzten Zeichen und -1 beim vorletzten Zeichen. Wenn die <em>Startposition</em> das linke Ende des <em>Heuhaufens</em> überschreitet, dann wird alles vom <em>Heuhaufen</em> durchsucht.</p>
      <p>Unabhängig von der <em>Startposition</em> bezieht sich der Rückgabewert immer auf das erste Zeichen des <em>Heuhaufens</em>. Zum Beispiel ist die Position von "abc" in "123abc789" immer 4.</p>    </td>
  </tr>
</table>
<h3 id="ErrorLevel">ErrorLevel</h3>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> kann Folgendes enthalten:</p>
<ul>
  <li>0, was bedeutet, dass kein Fehler aufgetreten ist.</li>
  <li>Einen String in folgender Form: <em>Compile error N at offset M: Beschreibung</em>. In diesem String ist <em>N</em> die PCRE-Fehlernummer, <em>M</em> die Position des betroffenen Zeichens im regulären Ausdruck und <em>Beschreibung</em> ein Text, der den Fehler beschreibt.</li>
  <li>Eine negative Zahl, was bedeutet, dass ein Fehler während der <em>Ausführung</em> des regulären Ausdrucks aufgetreten ist. Obwohl solche Fehler selten sind, sind die häufigsten auftretenden Fehler  "zu viele mögliche Übereinstimmungen mit leeren Strings" (-22), "Rekursion zu tief" (-21) und "Limit der Übereinstimmung erreicht" (-8). In diesem Fall sollte das Muster soweit wie möglich umgestaltet werden, damit es restriktiver ist, zum Beispiel * mit ?, + oder eine Begrenzung wie {0,3} ersetzen.</li>
</ul>
<h3>Optionen</h3>
<p>Siehe <a href="../misc/RegEx-QuickRef.htm#Options">Optionen</a> für Modifikatoren wie "<span class="red">i)</span>abc", um die Abhängigkeit von Groß- und Kleinschreibung im Muster "abc" zu deaktivieren.</p>
<h3>Performance</h3>
<p>Um einen einfachen Teilstring innerhalb eines größeren Strings zu suchen, verwendet <a href="../Functions.htm#InStr">InStr()</a>, weil es schneller als RegExMatch() ist.</p>
<p>Um die Performance zu verbessern, werden die 100 aktuellsten regulären Ausdrücken im Speicher zwischengespeichert (in kompilierter Form).</p>
<p>Die <a href="../misc/RegEx-QuickRef.htm#Study">S-Option</a> kann manchmal die Performance eines regulären Ausdrucks verbessern, welches oft verwendet wird (z. B. in einer Schleife).</p>
<h3>Bemerkungen</h3>
<p><a name="NamedSubPat"></a>Ein Teilausdruck kann einen Namen wie das Wort <em>Year</em> im Muster <em>(?P<Year>\d{4})</em> erhalten. Diese Namen können aus bis zu 32 alphanumerischen Zeichen und Unterstriche bestehen. Obwohl benannte Teilausdrücke auch während einer RegEx-Operation über ihre Nummern erhältlich sind (z. B. ist \1 eine Rückreferenz auf den String, der zurzeit mit dem ersten Teilausdruck übereinstimmt), werden sie <em>nur</em> in dem <a href="#Array">Ausgabe-Array</a> mit dem Namen gespeichert (nicht mit der Nummer). Wenn zum Beispiel der erste Teilausdruck "Year" heißt, dann enthält <em>AusgabevariableYear</em> den übereinstimmenden Teilstring und nicht <em>Ausgabevariable1</em> (es enthält den vorherigen Wert, falls vorhanden). Wenn jedoch ein <a href="../misc/RegEx-QuickRef.htm#subpat">unbenannter Teilausdruck</a> nach "Year" erfolgt, dann wird dieser in <em>Ausgabevariable2</em> gespeichert und nicht in <em>Ausgabevariable1</em>.</p>
<p>Die meisten Zeichen wie abc123 können direkt in einem regulären Ausdruck verwendet werden. Allerdings müssen die Zeichen <strong>\.*?+[{|()^$</strong> mit einem Backslash vorangestellt werden, damit sie direkt verwendet werden. Zum Beispiel ist <strong>\.</strong> ein direkt vorhandener Punkt und <strong>\\</strong> ist ein direkt vorhandener Backslash. Das Schützen kann mit \Q...\E verhindert werden. Zum Beispiel: \QDirekt vorhandener Text\E.</p>
<p>Innerhalb eines regulären Ausdrucks können bestimmte Sonderzeichen wie Tabulatoren und Zeilenumbrüche mit einem Akzent- (`) oder Backslash-Zeichen (\) geschützt werden. Zum Beispiel ist `t das gleiche wie \t, es sei denn, die <b>x</b>-Option wird verwendet.</p>
<p>Um die Grundlagen von regulären Ausdrücken kennenzulernen (oder das Gedächtnis ein wenig aufzufrischen), siehe <a href="../misc/RegEx-QuickRef.htm">RegEx-Kurzübersicht</a>.</p>
<p>Die regulären Ausdrücke von AutoHotkey verwenden Perl-kompatible reguläre Ausdrücke (PCRE) von <a href="http://www.pcre.org/">www.pcre.org</a>.</p>
<h3>Verwandte Befehle</h3>
<p><a href="RegExReplace.htm">RegExReplace()</a>, <a href="../misc/RegEx-QuickRef.htm">RegEx-Kurzübersicht</a>, <a href="../misc/RegExCallout.htm">Callouts in regulären Ausdrücken</a>, <a href="../Functions.htm#InStr">InStr()</a>, <a href="IfInString.htm">IfInString</a>, <a href="StringGetPos.htm">StringGetPos</a>, <a href="../Functions.htm#SubStr">SubStr()</a>, <a href="SetTitleMatchMode.htm#RegEx">SetTitleMatchMode RegEx</a>, <a href="http://www.autohotkey.com/forum/topic16164.html">Global matching and Grep (Forum-Link)</a></p>
<p>Häufige Quellen von Textdaten: <a href="FileRead.htm">FileRead</a>, <a href="UrlDownloadToFile.htm">UrlDownloadToFile</a>, <a href="../misc/Clipboard.htm">Clipboard</a>, <a href="GuiControls.htm#Edit">GUI-Edit-Steuerelemente</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent">Fundposition := RegExMatch("xxxabc123xyz", "abc.*xyz")  <em>; Gibt 4 zurück, weil es die Position ist, wo die Übereinstimmung gefunden wurde.</em>
Fundposition := RegExMatch("abc123123", "123$")  <em>; Gibt 7 zurück, weil $ die Übereinstimmung am Ende benötigt.</em>
Fundposition := RegExMatch("abc123", "i)^ABC")  <em>; Gibt 1 zurück, weil eine Übereinstimmung durch die Unabhängigkeit von Groß- und Kleinschreibung gefunden wurde.</em>
Fundposition := RegExMatch("abcXYZ123", "abc(.*)123", SubPat)  <em>; Gibt 1 zurück und speichert "XYZ" in SubPat1.</em>
Fundposition := RegExMatch("abc123abc456", "abc\d+", "", 2)  <em>; Gibt 7 anstelle von 1 zurück, wegen der 2 in der Startposition.</em>

<em>; Allgemeine RegEx-Beispiele können in der <a href="../misc/RegEx-QuickRef.htm">RegEx-Kurzübersicht</a> gefunden werden.</em></pre>

</body>
</html>
