<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>WinGetText</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>WinGetText</h1>

<p>Ermittelt den Text des angegebenen Fensters.</p>

<pre class="Syntax">WinGetText, Ausgabevariable [, Fenstertitel, Fenstertext, Titelausnahme, Textausnahme]</pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Ausgabevariable</td>
    <td width="85%">Der Name der Variable, die den ermittelten Text enthält.</td>
  </tr>
  <tr>
    <td>Fenstertitel</td>
    <td>Der Titel oder Teiltitel des Fensters (das Übereinstimmungsverhalten wird mit <a href="SetTitleMatchMode.htm">SetTitleMatchMode</a> bestimmt). Wenn dieser und die nächsten 3 Parameter nicht vorhanden sind, dann wird das <a href="../LastFoundWindow.htm">zuletzt gefundene Fenster</a> verwendet. Wenn dieser den Buchstaben A enthält und die nächsten 3 Parameter nicht vorhanden sind, dann wird das aktive Fenster verwendet. Bei Verwendung einer Fensterklasse muss ahk_class ExakterKlassenname angegeben werden (wird von Windows Spy angezeigt). Bei Verwendung einer <a href="Process.htm">Prozess-Kennung (PID)</a> muss ahk_pid %VariableMitPID% angegeben werden. Bei Verwendung einer <a href="GroupAdd.htm">Fenstergruppe</a> muss ahk_group Gruppenname angegeben werden. Bei Verwendung einer <a href="WinGet.htm">eindeutigen ID-Nummer</a> eines Fensters muss ahk_id %VariableMitID% angegeben werden. Die Suche kann durch Angabe <a href="../LastFoundWindow.htm#multi">mehrerer Kriterien</a> eingeschränkt werden. Zum Beispiel: <em>Eigene Datei.txt ahk_class Notepad</em></td>
  </tr>
  <tr>
    <td>Fenstertext</td>
    <td>Wenn vorhanden, dann muss dieser Parameter einen Teil der einzelnen Textelemente des Fensters enthalten (wird von Windows Spy angezeigt). Versteckte Textelemente werden erfasst, wenn <a href="DetectHiddenText.htm">DetectHiddenText</a> aktiv ist.</td>
  </tr>
  <tr>
    <td>Titelausnahme</td>
    <td>Fenstertitel mit diesem Wert werden nicht berücksichtigt.</td>
  </tr>
  <tr>
    <td>Textausnahme</td>
    <td>Fenstertexte mit diesem Wert werden nicht berücksichtigt.</td>
  </tr>
</table>

<h3>ErrorLevel</h3>
<p>Bei Problemen wird <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf 1 gesetzt, ansonsten enthält ErrorLevel eine 0.</p>
<h3>Bemerkungen</h3>
<p>Der Text ist für gewöhnlich der Text, der im Windows Spy für das Fenster angezeigt wird. Wenn <a href="DetectHiddenText.htm">DetectHiddenText</a> ausgeschaltet wurde, dann wird der versteckte Text in der <em>Ausgabevariable</em> weggelassen.</p>
<p>Jedes Textelement endet mit einem CR- und LF-Zeichen, die im Script als `r`n dargestellt werden können. Um bestimmte Zeilen oder Teilstrings zu extrahieren, verwendet Befehle wie <a href="StringGetPos.htm">StringGetPos</a> und <a href="StringMid.htm">StringMid</a>. Eine <a href="LoopParse.htm">Parsing-Schleife</a> kann auch verwendet werden, um jede Zeile oder jedes Wort nacheinander zu überprüfen.</p>
<p>Wenn der ermittelte Text scheinbar unvollständig ist, versucht es mit <a href="VarSetCapacity.htm">VarSetCapacity(Ausgabevariable, 55)</a> vor WinGetText [ersetzt 55 mit einer Größe, die wesentlich länger als der gekürzte Text ist]. Das ist notwendig, weil einige Anwendungen nicht richtig auf die WM_GETTEXTLENGTH-Nachricht reagieren, dass zur Folge hat, dass AutoHotkey die Ausgabevariable zu klein macht, um den ganzen Text zu speichern.</p>
<p>Die Menge des ermittelten Textes ist auf die Maximalkapazität einer Variable begrenzt (die über die <a href="_MaxMem.htm">#MaxMem</a>-Anweisung geändert werden kann). Folglich könnte dieser Befehl eine große Menge an RAM erzeugen, wenn das Zielfenster (z. B. ein Editor mit einem geöffneten umfangreichen Dokument) eine große Menge an Text beinhaltet. Es ist möglich, mit <a href="ControlGetText.htm">ControlGetText</a> nur Teile des Fenstertextes abzurufen, um dieses Problem zu umgehen. In jedem Fall kann der Speicher der Variable nach ihrer Verwendung freigegeben werden, indem man ihr nichts zuweist, z. B. Ausgabevariable =</p>
<p>Windows 95/98/ME limitiert möglicherweise einige Textelemente von bestimmten Fenstern auf 64 KB.</p>
<p>Um eine Liste mit Steuerelementen von einem Fenster zu erhalten, befolgt dieses Beispiel: <a href="WinGet.htm">WinGet</a>, Ausgabevariable, Steuerelementliste, Fenstertitel</p>
<p>Fenstertitel und -texte sind von der Groß- und Kleinschreibung abhängig. Solange <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a> deaktiviert ist, werden versteckte Fenster nicht wahrgenommen.</p>

<h3>Verwandte Befehle</h3>
<p><a href="ControlGetText.htm">ControlGetText</a>, <a href="WinGetActiveStats.htm">WinGetActiveStats</a>, <a href="WinGetActiveTitle.htm">WinGetActiveTitle</a>, <a href="WinGetTitle.htm">WinGetTitle</a>, <a href="WinGetPos.htm">WinGetPos</a>, <a href="_MaxMem.htm">#MaxMem</a></p>
<h3>Beispiel</h3>
<pre class="NoIndent">Run, Calc.exe
WinWait, Rechner
WinGetText, Text <em>; Das zuletzt gefundene Fenster wird verwendet.</em>
MsgBox, Der Text ist:`n%text%</pre>

</body>
</html>
