<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>RegisterCallback</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>RegisterCallback() <span class="ver">[v1.0.47+]</span></h1>

<p>Erstellt eine Maschinencode-Adresse, die beim Aufrufen den Aufruf zu einer <a href="../Functions.htm">Funktion</a> im Script umleitet.</p>

<pre class="Syntax">Adresse := RegisterCallback("Funktionsname" [, Optionen = "", Parameteranzahl = Formalanzahl, Ereignisinfo = Adresse])</pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td>Adresse</td>
    <td><span class="CommandSyntax">Bei Erfolg gibt RegisterCallback()</span> eine numerische Adresse zur&uuml;ck, die mit <a href="DllCall.htm">DllCall()</a> oder &Auml;hnlichem aufgerufen werden kann. Bei Misserfolg wird ein leerer String zur&uuml;ckgegeben. Fehler treten auf, wenn der <em>Funktionsname</em>: 1) nicht existiert, 2) zu viele oder zu wenig Parameter entsprechend der <em>Parameteranzahl</em> akzeptiert oder 3) einen beliebigen <a href="../Functions.htm#ByRef">ByRef-Parameter</a> akzeptiert.</td>
  </tr>
  <tr>
    <td>Funktionsname</td>
    <td>Der Name einer <a href="../Functions.htm">Funktion</a>, welcher in Anf&uuml;hrungszeichen gesetzt werden muss, wenn er ein direkter String ist. Diese Funktion wird automatisch aufgerufen, sobald die <em>Adresse</em> aufgerufen wird. Die Funktion ermittelt auch die Parameter, die an die <em>Adresse</em> &uuml;bergeben wurden.</td>
  </tr>
  <tr>
    <td>Optionen</td>
    <td><p>Verwendet keine oder mehrere folgende W&ouml;rter. Die Optionen werden mit einem Leerzeichen getrennt (z.B. "C Fast").</p>
    <p><strong><a name="Fast" id="Fast"></a>Fast</strong> oder <strong>F</strong>: Verhindert, dass jedes Mal ein neuer <a href="../misc/Threads.htm">Thread</a> gestartet wird, wenn der <em>Funktionsname</em> aufgerufen wird. Obwohl das zu besseren Ergebnissen f&uuml;hrt, muss es vermieden werden, sobald der aufgerufene Thread von der <em>Adresse</em> variiert (wenn der Callback beispielsweise von einer eingehenden Nachricht ausgel&ouml;st wird). Denn der <em>Funktionsname</em> wird in der Lage sein, globale Einstellungen wie <a href="../misc/ErrorLevel.htm">ErrorLevel</a>, <a href="../Variables.htm#LastError">A_LastError</a>, sowie das <a href="../LastFoundWindow.htm">zuletzt gefundene Fenster</a> f&uuml;r jeden Thread, der beim Aufruf gestartet wird, zu &auml;ndern. Weitere Informationen k&ouml;nnen bei den <a href="#Threads">Bemerkungen</a> gefunden werden.</p>
    <p><strong>CDecl</strong> oder <strong>C</strong>: Passt die <em>Adresse</em> an die "C"-Aufrufkonvention an. Das wird normalerweise weggelassen, da die Standard-Aufrufkonvention f&uuml;r Callbacks gebr&auml;uchlicher ist.</p></td>
  </tr>
  <tr>
    <td>Parameteranzahl</td>
    <td>Die Anzahl der Parameter, die dem Aufrufer von der <em>Adresse</em> &uuml;bergeben werden. Wenn ganz weggelassen, dann wird standardm&auml;&szlig;ig die Anzahl der vorgeschriebenen Parameter in der <a href="../Functions.htm#define">Definition</a> von <em>Funktionsname</em> verwendet. In jedem Fall sollte sichergestellt werden, dass der Aufrufer genau diese Anzahl von Parametern &uuml;bergibt.</td>
  </tr>
  <tr>
    <td>EventInfo</td>
    <td>Ein Integer zwischen 0 und 4294967295, der vom <em>Funktionsnamen</em> in <a href="../Variables.htm#EventInfo">A_EventInfo</a> gesehen wird, sobald mit dieser <em>Adresse</em> aufgerufen. Das ist n&uuml;tzlich, wenn der <em>Funktionsname</em> von mehreren <em>Adressen</em> aufgerufen wird. Wenn nicht vorhanden, dann standardm&auml;&szlig;ig die <em>Adresse</em>. Hinweis: Im Gegensatz zu anderen globalen Einstellungen wird A_EventInfo des <a href="../misc/Threads.htm">aktuellen Threads</a> nicht vom <a href="#Fast">schnellen Modus</a> beeinflusst.</td>
  </tr>
</table>

<h3>Die Parameter der Callback-Funktion</h3>
<p>Eine <a href="../Functions.htm">Funktion</a>, die einer Callback-Adresse zugewiesen ist, kann bis zu 31 Parameter akzeptieren. <a href="../Functions.htm#optional">Optionale Parameter</a> sind erlaubt und n&uuml;tzlich, wenn die Funktion von mehreren Aufrufern aufgerufen wird.</p>
<p><strong>32-Bit:</strong> Alle eingehenden Parameter sind unsigned 32-Bit-Integer. Wenn ein eingehender Parameter als signed Integer vorgesehen ist, dann k&ouml;nnen negative Zahlen mit einem der folgenden Beispielen offenbart werden:</p>
<pre><em>; Methode #1</em>
If wParam &gt; 0x7FFFFFFF
    wParam := -(~wParam) - 1

<em>; Methode #2: Falls AutoHotkey von Haus aus signed 64-Bit-Integers verwendet.</em>
wParam := wParam &lt;&lt; 32 &gt;&gt; 32</pre>
<p><strong>64-Bit:</strong> Alle eingehenden Parameter sind signed 64-Bit-Integer. AutoHotkey unterst&uuml;tzt von Haus aus keine unsigned 64-Bit-Integers.</p>
<p>Wenn ein eingehender Parameter vom Aufrufer als String vorgesehen ist, dann wird die aktuelle Adresse des Strings abgerufen. Um den String selbst abzurufen, verwendet <a href="StrPutGet.htm">StrGet</a>:</p>
<pre>EigenerString := StrGet(EigenerParameter)  <em>; AHK_L 46+</em></pre>
<p>Wenn ein eingehender Parameter die Adresse einer Struktur ist, dann k&ouml;nnen einzelne Elemente extrahiert werden, wenn die Schritte in "<a href="DllCall.htm#struct">DllCall-Strukturen</a>" befolgt werden.</p>
<p id="Indirect"><span class="ver">[AHK_L 60+]:</span> Ist die Funktion <a href="../Functions.htm#Variadic">variadisch</a>, dann wird der letzte Parameter der <i>Adresse</i> des ersten Callback-Parameters zugewiesen, welche nicht einem Script-Parameter zugeordnet ist. Zum Beispiel:</p>
<pre>callback := RegisterCallback("Func", "F", 1)  <em>; Parameteranzahl muss angegeben werden.</em>
Func("Funktion wurde direkt aufgerufen.")  <em>; Funktion direkt aufrufen.</em>
DllCall(callback, float, 10.5)  <em>; Funktion mit Callback aufrufen.</em>
Func(params*) {
    If IsObject(params)
        MsgBox % params[1]
    Else
        MsgBox % <a href="../Functions.htm#NumGet">NumGet</a>(params+0, 0, "float")
}</pre>
<p>Die meisten Callbacks verwenden die <i>stdcall</i>-Aufrufkonvention, die eine feste Anzahl an Parametern voraussetzt. In diesem Fall muss die <i>Parameteranzahl</i> beim Erstellen des Callbacks angegeben werden. Die <i>Parameteranzahl</i> kann bei 64-Bit-Konstruktionen und bei <i>Cdecl</i>-Callbacks in 32-Bit-Konstruktionen weggelassen werden. In solchen F&auml;llen erhalten alle optionalen Parameter ihre Standardwerte und werden zum Zweck der Adressenberechnung ignoriert, die in <i>params</i> gespeichert werden.</p>
<h3>Was die Funktion <em>zur&uuml;ckgeben</em> sollte</h3>
<p>Wenn die Funktion ein <a href="Return.htm">Return</a> ohne Parameter verwendet oder ein leerer Wert wie "" angegeben ist (oder &uuml;berhaupt nicht Return verwendet), dann wird eine 0 zum Aufrufer der <em>Adresse</em> zur&uuml;ckgegeben. Ansonsten sollte die Funktion einen Integer zwischen -2147483648 und 4294967295 zur&uuml;ckgeben, der anschlie&szlig;end zum Aufrufer der <em>Adresse</em> zur&uuml;ckgegeben wird.</p>
<h3 id="Threads">Fast und Slow</h3>
<p>Der Standard-/langsame Modus startet die Funktion mit Standardwerten von Einstellungen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>. Diese k&ouml;nnen im <a href="../Scripts.htm#auto">automatischen Ausf&uuml;hrungsbereich</a> ge&auml;ndert werden.</p>
<p>Im Gegensatz dazu &uuml;bernimmt der <a href="#Fast">schnelle Modus</a> die globalen Einstellungen, immer wenn ein <a href="../misc/Threads.htm">Thread</a> beim Aufruf gestartet wird. Dar&uuml;ber hinaus werden &Auml;nderungen der Funktion an den globalen Einstellungen (einschlie&szlig;lich <a href="../misc/ErrorLevel.htm">ErrorLevel</a> und das <a href="../LastFoundWindow.htm">zuletzt gefundene Fenster</a>) f&uuml;r den <a href="../misc/Threads.htm">aktuellen Thread</a> wirksam. Folglich sollte der schnelle Modus nur verwendet werden, wenn genau bekannt ist, welche(n) Thread(s) die Funktion aufrufen wird.</p>
<p>Damit sich ein Callback nicht selbst unterbricht (oder von einem anderen Thread), verwendet <a href="Critical.htm">Critical</a> als erste Zeile. Das tritt jedoch nicht komplett in Kraft, wenn die Funktion indirekt von einer eingehenden Nachricht kleiner als 0x312 aufgerufen wird (die Erh&ouml;hung des <a href="Critical.htm#Interval">Intervalls</a> von Critical k&ouml;nnte helfen). Dar&uuml;ber hinaus hindert <a href="Critical.htm">Critical</a> die Funktion nicht daran, sich indirekt selbst aufrufen zu k&ouml;nnen (z. B. <a href="PostMessage.htm">SendMessage</a> oder <a href="DllCall.htm">DllCall</a> aufrufen).</p>
<h3>Speicher</h3>
<p>Beim Verwenden von RegisterCallback() wird eine kleine Speichermenge (32 Bytes plus System-Overhead) reserviert. Da das Betriebssystem diesen Speicher automatisch beim Beenden des Scripts freigibt, muss jedes Script, das eine kleine <em>feste</em> Anzahl an Callbacks reserviert, nicht unbedingt den Speicher freigegeben. Im Gegensatz dazu sollte ein Script, das RegisterCallback() unendlich oft aufruft, folgendes bei unbenutzten Callbacks direkt aufrufen:</p>
<pre>DllCall("GlobalFree", "Ptr", Adresse)</pre>
<h3>Verwandte Befehle</h3>
<p><a href="DllCall.htm">DllCall()</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="OnExit.htm">OnExit</a>, <a href="../misc/Clipboard.htm#OnClipboardChange">OnClipboardChange</a>, <a href="Sort.htm#callback">Callback von Sort</a>, <a href="Critical.htm">Critical</a>, <a href="PostMessage.htm">Post/SendMessage</a>, <a href="../Functions.htm">Funktionen</a>, <a href="../misc/SendMessageList.htm">Liste mit Fensternachrichten</a>, <a href="../misc/Threads.htm">Threads</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Das folgende Beispiel ist ein funktionierendes Script, das eine Zusammenfassung aller Fenster auf h&ouml;chster Ebene anzeigt.</em>

<em>; Zur Erhaltung der Performance und des Speichers wird RegisterCallback() nur einmal f&uuml;r einen bestimmten Callback aufgerufen:</em>
If not EnumAdresse  <em>; schneller Modus ist okay, weil er nur vom diesen Thread aufgerufen wird:</em>
    EnumAdresse := <strong>RegisterCallback</strong>("EnumWindowsProc", "Fast")

DetectHiddenWindows On  <em>; Durch den schnellen Modus wird diese Einstellung auch f&uuml;r Callback wirksam.</em>

<em>; Kontrolle an EnumWindows() &uuml;bergeben, die Callback mehrmals aufruft:</em>
DllCall("EnumWindows", Ptr, EnumAdresse, Ptr, 0)
MsgBox %Ausgabe%  <em>; Zeigt die gesammelten Informationen von Callback an.</em>

EnumWindowsProc(hwnd, lParam)
{
    global Ausgabe
    WinGetTitle, Titel, ahk_id %hwnd%
    WinGetClass, Klasse, ahk_id %hwnd%
    If Titel
        Ausgabe .= "HWND: " . hwnd . "`tTitel: " . Titel . "`tKlasse: " . Klasse . "`n"
    Return true  <em>; Setzt EnumWindows() fort, bis alle Fenster abgearbeitet wurden.</em>
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Das folgende Beispiel ist ein funktionierendes Script, dass zeigt, wie Unterklassen f&uuml;r ein GUI-Fenster
; gebildet werden, indem WindowProc zu einem neuen WindowProc weitergeleitet wird. In diesem Fall wird die Hintergrundfarbe
; des Text-Steuerelements in eine benutzerdefinierte Farbe umge&auml;ndert.</em>

Texthintergrundfarbe := 0xFFBBBB  <em>; Eine benutzerdefinierte Farbe im BGR-Format.</em>
Pinsel := DllCall("CreateSolidBrush", UInt, Texthintergrundfarbe)

Gui, Add, Text, HwndEigenerTextHwnd, Hier ein Text mit einer`nbenutzerdefinierter Hintergrundfarbe.
Gui +LastFound
GuiHwnd := WinExist()

<em>; 64-Bit-Scripts m&uuml;ssen SetWindowLongPtr anstelle von SetWindowLong aufrufen:</em>
SetWindowLong := A_PtrSize=8 ? "SetWindowLongPtr" : "SetWindowLong"

WindowProcNew := <strong>RegisterCallback</strong>("WindowProc", ""  <em>; Verwendet "", um den schnellen Modus f&uuml;r die Unterklasse zu verhindern.</em>
    , <strong>4</strong>, EigenerTextHwnd)  <em>; Parameteranzahl muss exakt angegeben werden, wenn der Ereignisinfo-Parameter vorhanden ist.</em>
WindowProcOld := DllCall(SetWindowLong, Ptr, GuiHwnd, Int, -4  <em>; -4 ist GWL_WNDPROC</em>
    , Ptr, WindowProcNew, Ptr)  <em>; Wert muss auf Ptr oder UPtr anstelle von Int gesetzt werden.</em>

Gui Show
Return

WindowProc(hwnd, uMsg, wParam, lParam)
{
    Critical
    global Texthintergrundfarbe, Pinsel, WindowProcOld
    If (uMsg = 0x138 && lParam = A_EventInfo)  <em>; 0x138 ist WM_CTLCOLORSTATIC.</em>
    {
        DllCall("SetBkColor", UInt, wParam, Ptr, Texthintergrundfarbe)
        Return Pinsel  <em>; Gibt HBRUSH zur&uuml;ck, um dem OS mitzuteilen, dass wir HDC &auml;ndern.</em>
    }
    <em>; Ansonsten (wenn nichts zur&uuml;ckgegeben wird) werden alle unbehandelten Ereignisse an dem originalen WindowProc &uuml;bergeben.</em>
    Return DllCall("CallWindowProc", Ptr, WindowProcOld, Ptr, hwnd, UInt, uMsg, Ptr, wParam, Ptr, lParam)
}

GuiClose:
ExitApp</pre>

</body>
</html>