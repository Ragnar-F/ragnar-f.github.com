<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Loop (Dateien & Ordner)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Loop (Dateien & Ordner)</h1>

<p>Ermittelt nacheinander die angegebenen Dateien oder Ordner.</p>

<pre class="Syntax">Loop, Dateimuster [, OrdnerEinbeziehen?, Rekursiv?] </pre>
<h3>Parameter</h3>
<table class="info">
  <tr>
    <td width="15%">Dateimuster</td>
    <td width="85%"><p>Der Name einer Datei, eines Ordners oder einer musterbasierten Suche wie C:\Temp\*.tmp. Das <em>Dateimuster</em> befindet sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist.</p>
    <p>Sowohl Sternchen als auch Fragezeichen werden als Platzhalter unterstützt. Eine Übereinstimmung erfolgt, wenn das Muster mit dem langen/normalen oder <a href="#LoopFileShortName">8.3-kurzen</a> Dateinamen übereinstimmt.</p>
    <p>Wenn dieser Parameter eine Datei oder einen Ordner enthält (also ohne Platzhalter) und <em>Rekursiv</em> auf 1 gesetzt ist, dann werden mehrere Übereinstimmungen gefunden, sobald der angegebene Dateiname in mehreren Ordnern vorkommt.</p></td>
  </tr>
  <tr>
    <td>OrdnerEinbeziehen?</td>
    <td><p>Eine folgende Ziffer benutzen oder leer lassen, um den Standardwert zu verwenden:<br> 0 (Standard) Ordner werden nicht ermittelt (nur Dateien).<br> 1 Alle Dateien und Ordner, die der musterbasierten Suche entsprechen, werden ermittelt.<br> 2 Nur Ordner werden ermittelt (keine Dateien).</p>    </td>
  </tr>
  <tr>
    <td>Rekursiv?</td>
    <td>Eine folgende Ziffer benutzen oder leer lassen, um den Standardwert zu verwenden:<br> 0 (Standard) Unterordner werden nicht rekursiv behandelt.<br> 1 Unterordner werden rekursiv behandelt, damit die enthaltenen Dateien und Unterordner ermittelt werden, wenn sie mit dem <em>Dateimuster</em> übereinstimmen. Alle Unterordner werden rekursiv behandelt, nicht nur solche, die mit dem <em>Dateimuster</em> übereinstimmen. </td>
  </tr>
</table>

<h3>Besondere Variablen innerhalb einer dateilesenden Schleife</h3>
<p>Die folgenden Variablen gibt es innerhalb jeder dateilesenden Schleife. Wenn eine innere dateilesende Schleife durch eine äußere dateilesende Schleife eingeschlossen ist, dann hat die Datei innerhalb der Schleife Vorrang.</p>
<table class="info">
  <tr>
    <td>A_LoopFileName</td>
    <td><a name="LoopFileName" id="LoopFileName"></a>Der Name der Datei oder des Ordners, welche(r) zurzeit abgerufen wird (ohne den Pfad).</td>
  </tr>
  <tr>
    <td><a name="LoopFileExt"></a>A_LoopFileExt</td>
    <td>Die Dateierweiterung (z. B. TXT, DOC oder EXE). Der Punkt (.) ist nicht inbegriffen.</td>
  </tr>
  <tr>
    <td>A_LoopFileFullPath</td>
    <td><a name="LoopFileFullPath"></a>Der vollständige Pfad und Name der Datei/des Ordners, welche(r) zurzeit abgerufen wird. Wenn der <em>Dateimuster</em> allerdings einen relativen anstelle eines absoluten Pfads enthält, dann ist dieser Pfad hier auch relativ. Darüber hinaus sind kurze (8.3) Ordnernamen im <em>Dateimuster</em> immer noch kurz (siehe nächsten Punkt, um die lange Version zu erhalten). </td>
  </tr>
  <tr>
    <td>A_LoopFileLongPath</td>
    <td><a name="LoopFileLongPath"></a>Diese Variable unterscheidet sich von A_LoopFileFullPath wie folgt: 1) Es enthält immer den absoluten/kompletten Pfad der Datei, selbst wenn das <em>Dateimuster</em> einen relativen Pfad enthält; 2) Jeder kurze (8.3) Ordnername im <em>Dateimuster</em> wird in einem langen Namen umgewandelt; 3) Zeichen im <em>Dateimuster</em> werden in Groß- oder Kleinbuchstaben umgewandelt, damit sie mit den Zeichen im Dateisystem übereinstimmen. Das ist für die Umwandlung von Dateinamen (die beispielsweise mittels Befehlszeilenparameter an das Script übergeben werden) in ihre exakte Pfadnamen nützlich, wie sie vom Explorer angezeigt werden.</td>
  </tr>
  <tr>
    <td>A_LoopFileShortPath</td>
    <td><p><a name="LoopFileShortPath"></a>Der kurze Pfad (8.3) und Name der/des aktuell abgerufenen Ordners/Datei. Zum Beispiel: C:\MYDOCU~1\ADDRES~1.txt. Wenn der <em>Dateimuster</em> allerdings einen relativen anstelle eines absoluten Pfads enthält, dann ist dieser Pfad hier auch relativ.</p>
      <p>Um den kompletten 8.3-Pfad und Namen einer Datei oder eines Ordners abzurufen, verwendet folgenden Namen im <em>Dateimuster</em>:</p>
<pre>Loop, C:\Eigene Dokumente\Address List.txt
    ShortPathName = %A_LoopFileShortPath%</pre>
        <p>HINWEIS: Diese Variable ist <strong>leer</strong>, wenn die Datei keinen kurzen Namen hat, dass in Betriebssystemen passieren kann, die NtfsDisable8dot3NameCreation in der Registrierung aktiv haben. Sie ist auch leer, wenn das Dateimuster einen relativen Pfad enthält und der Schleifenkörper <a href="SetWorkingDir.htm">SetWorkingDir</a> verwendet, um vom eigentlichen Arbeitsverzeichnis der Schleife selbst weg zuschalten.</p></td>
  </tr>
  <tr>
    <td>A_LoopFileShortName</td>
    <td><a name="LoopFileShortName"></a>Der 8.3-Kurzname oder alternative Name der Datei. Wenn die Datei keinen Kurznamen hat (falls der lange Name kürzer als der 8.3-Name ist oder die Kurznamengenerierung auf einem NTFS-Dateisystem deaktiviert ist), dann wird stattdessen <em>A_LoopFileName</em> abgerufen. </td>
  </tr>
  <tr>
    <td>A_LoopFileDir</td>
    <td><a name="LoopFileDir"></a>Der vollständige Pfad des Verzeichnisses, in der sich <em>A_LoopFileName</em> befindet. Wenn der <em>Dateimuster</em> allerdings einen relativen anstelle eines absoluten Pfads enthält, dann ist dieser Pfad hier auch relativ. Ein Hauptverzeichnis wird keinen nachfolgenden Backslash enthalten. Zum Beispiel: C:</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeModified</td>
    <td><a name="LoopFileTimeModified"></a>Wann die Datei bearbeitet wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeCreated</td>
    <td><a name="LoopFileTimeCreated"></a>Wann die Datei erstellt wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeAccessed</td>
    <td><a name="LoopFileTimeAccessed"></a>Wann die Datei aufgerufen wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileAttrib</td>
    <td><a name="LoopFileAttrib"></a>Die <a href="FileGetAttrib.htm">Attribute</a> der Datei, welche zurzeit abgerufen wird.</td>
  </tr>
  <tr>
    <td>A_LoopFileSize</td>
    <td><a name="LoopFileSize"></a>Die Byte-Größe der Datei, welche zurzeit abgerufen wird. Dateien größer als 4 Gigabyte werden ebenfalls unterstützt.</td>
  </tr>
  <tr>
    <td>A_LoopFileSizeKB</td>
    <td><a name="LoopFileSizeKB"></a>Die KB-Größe der Datei, welche zurzeit abgerufen wird, abgerundet auf dem nächsten Integer-Wert. </td>
  </tr>
  <tr>
    <td>A_LoopFileSizeMB</td>
    <td><a name="LoopFileSizeMB"></a>Die MB-Größe der Datei, welche zurzeit abgerufen wird, abgerundet auf dem nächsten Integer-Wert. </td>
  </tr>
</table>
<h3>Bemerkungen</h3>
<p>Eine dateilesende Schleife ist nützlich, wenn der Benutzer eine Sammlung von Dateien und/oder Ordner bearbeiten will.</p>
<p>Alle übereinstimmenden Dateien werden ermittelt, einschließlich versteckte Dateien. Im Gegensatz dazu lassen OS-Funktionen wie der DIR-Befehl versteckte Dateien standardmäßig weg. Um die Bearbeitung von versteckten, schreibgeschützten und/oder System-Dateien zu vermeiden, verwendet beispielsweise Folgendes in der Schleife:</p>
<pre>If A_LoopFileAttrib contains H,R,S  <em>; Jede Datei überspringen, die H (versteckt), R (schreibgeschützt) oder S (vom System) ist. Hinweis: Keine Leerzeichen in "H,R,S".</em>
    continue  <em>; Diese Datei überspringen und zur Nächsten gehen</em></pre>
<p>Um die relativen anstelle der absoluten Pfade von Dateien während einer rekursiven Suche zu ermitteln, ändert mit <a href="SetWorkingDir.htm">SetWorkingDir</a> den Grundordner vor der Schleife und lasst dann den Pfad in der Schleife weg (z. B. Loop, *.*, 0, 1). Dadurch enthält <a href="#LoopFileFullPath">A_LoopFileFullPath</a> den relativen Pfad im Grundordner der Datei.</p>
<p>Eine dateilesende Schleife kann sich selbst unterbrechen, wenn sie Dateien oder Ordner innerhalb der eigenen Zuständigkeit erstellt oder umbenennt. Wenn sie zum Beispiel Dateien mittels <a href="FileMove.htm">FileMove</a> umbenennt, dann wird jede dieser Datei zweimal gefunden: einmal mit dem alten Namen und nochmal mit dem neuen Namen. Als Übergangslösung sollten die Dateien nur umbenannt werden, nachdem eine Liste von ihnen erstellt wurde. Zum Beispiel:</p>
<pre>Dateiliste =
Loop *.jpg
   Dateiliste = %Dateiliste%%A_LoopFileName%`n
Loop, parse, Dateiliste, `n
   FileMove, %A_LoopField%, unbenannt_%A_LoopField%</pre>
<p>Dateien in einem NTFS-Dateisystem werden wahrscheinlich immer in alphabetischer Reihenfolge abgerufen. Dateien in anderen Dateisystemen werden in keiner bestimmten Reihenfolge abgerufen. Um eine bestimmte Reihenfolge sicherzustellen, verwendet den Befehl <a href="Sort.htm">Sort</a>, wie unten im Abschnitt "Beispiele" gezeigt.</p>
<p>Dateien und Ordner mit einem kompletten Pfad länger als 259 Zeichen werden ignoriert, als würde sie nicht existieren. Solche Dateien sind selten, weil normalerweise das Betriebssystem das Erstellen solcher Dateien verbietet.</p>
<p>Siehe <a href="Loop.htm">Loop</a> für Informationen über <a href="Block.htm">Blocks</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index (die gibt es in jeder Schleifenvariante).</p>
<h3>Verwandte Befehle</h3>
<p><a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blocks</a>, <a href="SplitPath.htm">SplitPath</a>, <a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel #1:</em>
Loop, %A_ProgramFiles%\*.txt, , 1  <em>; Rekursiv in Unterordner.</em>
{
    MsgBox, 4, , Dateiname = %A_LoopFileFullPath%`n`nFortfahren?
    IfMsgBox, No
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Berechnet die Größe des Ordners, einschließlich seine Dateien und Unterordner:</em>
SetBatchLines, -1  <em>; Führt die Operation mit maximaler Geschwindigkeit aus.</em>
OrdnerGrößeKB = 0
FileSelectFolder, Ordner  <em>; Fordert den Benutzer auf, einen Ordner auszuwählen.</em>
Loop, %Ordner%\*.*, , 1
    OrdnerGrößeKB += %A_LoopFileSizeKB%
MsgBox Der Ordner %Ordner% hat eine Größe von %OrdnerGrößeKB% KB.</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Ruft Dateinamen ab, die nach Namen sortiert sind (siehe nächstes Beispiel, um nach Datum zu sortieren):</em>
Dateiliste =  <em>; Leere Variable initialisieren.</em>
Loop, C:\*.*
    Dateiliste = %Dateiliste%%A_LoopFileName%`n
Sort, Dateiliste, R  <em>; Die R-Option sortiert in umgekehrter Richtung. Siehe <a href="Sort.htm">Sort</a> für andere Optionen.</em>
Loop, parse, Dateiliste, `n
{
    If A_LoopField =  <em>; Ignoriert das leere Element am Ende der Liste.</em>
        continue
    MsgBox, 4,, Dateinummer %A_Index% ist %A_LoopField%.  Weiter?
    IfMsgBox, No
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #4: Ruft Dateinamen ab, die nach Erstellungsdatum sortiert sind:</em>
Dateiliste =
Loop, %A_MyDocuments%\Fotos\*.*, 1
    Dateiliste = %Dateiliste%%A_LoopFileTimeModified%`t%A_LoopFileName%`n
Sort, Dateiliste  <em>; Nach Datum sortieren.</em>
Loop, parse, Dateiliste, `n
{
    If A_LoopField =  <em>; Lässt das letzte LF-Zeichen (leeres Element) am Ende der Liste weg.</em>
        continue
    StringSplit, Dateielement, A_LoopField, %A_Tab%  <em>; In zwei Teile aufteilen.</em>
    MsgBox, 4,, Die nächste Datei ist (modifiziert am %Dateielement1%):`n%Dateielement2%`n`nWeiter?
    IfMsgBox, No
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #5: Kopiert nur Quelldateien ins Ziel, die neuer als ihr Gegenstück sind:</em>
KopierenWennNeuer:
<em>; Die Variablen KopieQuellmuster und KopieZiel wurden vorher gesetzt.</em>
Loop, %KopieQuellmuster%
{
    kopieren = n
    IfNotExist, %KopieZiel%\%A_LoopFileName%  <em>; Immer kopieren, wenn die Zieldatei noch nicht existiert.</em>
        kopieren = y
    Else
    {
        FileGetTime, Zeitstempel, %KopieZiel%\%A_LoopFileName%
        EnvSub, Zeitstempel, %A_LoopFileTimeModified%, seconds  <em>; Subtrahiert die Zeit der Quelldatei mit der Zeit der Zieldatei.</em>
        If Zeitstempel < 0  <em>; Quelldatei ist neuer als Zieldatei.</em>
            kopieren = y
    }
    If kopieren = y
    {
        FileCopy, %A_LoopFileFullPath%, %KopieZiel%\%A_LoopFileName%, 1   <em>; Kopieren und überschreiben.</em>
        If ErrorLevel
            MsgBox, "%A_LoopFileFullPath%" konnte nicht nach "%KopieZiel%\%A_LoopFileName%" kopiert werden.
    }
}
Return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #6: Konvertiert Dateinamen, die mittels Kommandozeilen-Parameter übergeben wurden, in lange Namen,
; vervollständigt den Pfad und korrigiert die Groß- und Kleinbuchstaben, wie sie im Dateisystem gespeichert sind.</em>
Loop %0%  <em>; Für jede Datei, die auf das Script abgelegt wurde (oder als Parameter übergeben wurde).</em>
{
    Pfadangabe := %A_Index%  <em>; Ermittelt den nächsten Befehlszeilenparameter.</em>
    Loop %Pfadangabe%, 1
        LangerPfad = %A_LoopFileLongPath%
    MsgBox Der zeichengenaue lange Pfadname der Datei `n%Pfadangabe%`n ist:`n%LangerPfad%
}</pre>

</body>
</html>
